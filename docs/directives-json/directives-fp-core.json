[
  {
    "name": "fp_purity",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "purity",
      "description": "Eliminates hidden state and ensures all functions are referentially transparent."
    },
    "description": "Enforces pure functions: deterministic output for given inputs, no external state or side effects.",
    "md_file_path": "directives/fp_purity.md",
    "workflow": {
      "trunk": "analyze_function",
      "branches": [
        {
          "if": "mutation_detected",
          "then": "refactor_to_pure",
          "details": {
            "explicit_params": true
          }
        },
        {
          "if": "external_state_access",
          "then": "isolate_side_effects"
        },
        {
          "if": "pure",
          "then": "mark_compliant"
        },
        {
          "if": "refactored",
          "then": "update_functions_table",
          "details": {
            "side_effects_json": "none",
            "purity_level": "pure"
          }
        },
        {
          "if": "low_confidence",
          "then": "prompt_user",
          "details": {
            "clarify": "Function purity uncertain"
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Function purity uncertain—refactor or confirm purity?",
            "log_note": true
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "stateful_function",
        "resolution": "Isolate state outside of function scope"
      },
      {
        "issue": "hidden_mutation",
        "resolution": "Refactor to pure function"
      },
      {
        "issue": "language_mismatch",
        "resolution": "Escalate to fp_language_standardization"
      },
      {
        "issue": "external_dependency",
        "resolution": "Pass as explicit parameter or isolate with fp_wrapper_generation"
      }
    ],
    "intent_keywords_json": [
      "pure",
      "no side effects",
      "deterministic"
    ],
    "confidence_threshold": 0.7,
    "notes": "Central FP rule; applies to all code generation and compliance checks. Links to project_compliance_check."
  },
  {
    "name": "fp_state_elimination",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "purity",
      "description": "Eliminates global or implicit state in function logic."
    },
    "description": "Detects and removes reliance on global variables or hidden mutable structures.",
    "md_file_path": "directives/fp_state_elimination.md",
    "workflow": {
      "trunk": "scan_scope",
      "branches": [
        {
          "if": "global_references",
          "then": "inline_dependencies"
        },
        {
          "if": "mutable_static_data",
          "then": "convert_to_immutable"
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Global or static dependencies unclear"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "global_dependency",
        "resolution": "Pass as explicit parameter"
      },
      {
        "issue": "static_mutable_data",
        "resolution": "Refactor to immutable constant"
      }
    ],
    "intent_keywords_json": [
      "global state",
      "stateless",
      "function scope"
    ],
    "confidence_threshold": 0.6,
    "notes": "Used during function analysis to strip implicit global state."
  },
  {
    "name": "fp_side_effect_detection",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "purity",
      "description": "Flags and isolates side effects like I/O, file writes, or logging."
    },
    "description": "Scans function bodies for I/O, print, logging, or mutation and isolates effects via wrappers.",
    "md_file_path": "directives/fp_side_effect_detection.md",
    "workflow": {
      "trunk": "scan_for_side_effects",
      "branches": [
        {
          "if": "io_operations_found",
          "then": "wrap_in_effect_function"
        },
        {
          "if": "logging_detected",
          "then": "redirect_to_logger_function"
        },
        {
          "if": "side_effects_isolated",
          "then": "update_side_effects_json",
          "details": {
            "link_to_project_update_db": true
          }
        },
        {
          "if": "low_confidence",
          "then": "prompt_user",
          "details": {
            "clarify": "Side effect detection uncertain"
          }
        },
        {
          "fallback": "mark_as_pure_if_none_found"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "untracked_side_effect",
        "resolution": "Use effect wrapper"
      },
      {
        "issue": "logging_in_function",
        "resolution": "Route through functional logger"
      },
      {
        "issue": "hidden_io",
        "resolution": "Escalate to fp_io_isolation"
      },
      {
        "issue": "language_specific_io",
        "resolution": "Use fp_cross_language_wrappers"
      }
    ],
    "intent_keywords_json": [
      "side effects",
      "io",
      "mutation"
    ],
    "confidence_threshold": 0.7,
    "notes": "Supports isolation of side effects for safe functional behavior. Links to project_update_db and project_compliance_check."
  },
  {
    "name": "fp_immutability",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "immutability",
      "description": "Promotes immutable values and avoids mutation of variables."
    },
    "description": "Ensures all variables and data structures are immutable by default and replaced, not modified.",
    "md_file_path": "directives/fp_immutability.md",
    "workflow": {
      "trunk": "analyze_variables",
      "branches": [
        {
          "if": "mutation_found",
          "then": "replace_with_copy"
        },
        {
          "if": "mutable_structure_detected",
          "then": "replace_with_tuple_or_const"
        },
        {
          "fallback": "mark_as_immutable"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "variable_reassignment",
        "resolution": "Use new variable binding"
      },
      {
        "issue": "mutable_container",
        "resolution": "Replace with immutable type"
      }
    ],
    "intent_keywords_json": [
      "immutable",
      "no mutation",
      "constant"
    ],
    "confidence_threshold": 0.6,
    "notes": "Foundational FP rule ensuring referential transparency and predictable state."
  },
  {
    "name": "fp_const_refactoring",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "immutability",
      "description": "Encourages constant declarations and immutable bindings."
    },
    "description": "Promotes use of constants; automatically lifts repeated literals to top-level immutable declarations.",
    "md_file_path": "directives/fp_const_refactoring.md",
    "workflow": {
      "trunk": "scan_assignments",
      "branches": [
        {
          "if": "repeated_literals",
          "then": "extract_to_const"
        },
        {
          "if": "mutable_bindings",
          "then": "convert_to_const"
        },
        {
          "fallback": "mark_compliant"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "duplicate_literals",
        "resolution": "Extract to shared const"
      },
      {
        "issue": "mutable_assignment",
        "resolution": "Enforce constant declaration"
      }
    ],
    "intent_keywords_json": [
      "const",
      "binding",
      "immutable variable"
    ],
    "confidence_threshold": 0.6,
    "notes": "Prevents accidental mutation and simplifies dependency tracking."
  },
  {
    "name": "fp_no_reassignment",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "immutability",
      "description": "Eliminates variable reassignment after initialization."
    },
    "description": "Disallows variable reassignment; enforces single-assignment semantics per scope.",
    "md_file_path": "directives/fp_no_reassignment.md",
    "workflow": {
      "trunk": "track_variable_bindings",
      "branches": [
        {
          "if": "reassignment_detected",
          "then": "create_new_binding"
        },
        {
          "fallback": "mark_as_compliant"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "reassignment_found",
        "resolution": "Replace with new variable name"
      }
    ],
    "intent_keywords_json": [
      "no reassignment",
      "immutable assignment"
    ],
    "confidence_threshold": 0.7,
    "notes": "Ensures all variable bindings are immutable; core immutability enforcement."
  },
  {
    "name": "fp_ownership_safety",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "ownership",
      "description": "Ensures safe data ownership, preventing unintended sharing or mutation."
    },
    "description": "Applies borrow or copy semantics to data passed between functions, preventing shared mutability.",
    "md_file_path": "directives/fp_ownership_safety.md",
    "workflow": {
      "trunk": "analyze_function_parameters",
      "branches": [
        {
          "if": "shared_reference_detected",
          "then": "apply_copy_semantics"
        },
        {
          "if": "borrow_pattern_safe",
          "then": "approve_function"
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Ownership unclear; copy or borrow?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "shared_mutation_risk",
        "resolution": "Duplicate or isolate data"
      },
      {
        "issue": "unclear_borrowing",
        "resolution": "Default to copy semantics"
      }
    ],
    "intent_keywords_json": [
      "ownership",
      "borrow",
      "copy"
    ],
    "confidence_threshold": 0.7,
    "notes": "Prevents shared mutable data between functions; vital for concurrency safety."
  },
  {
    "name": "fp_borrow_check",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "ownership",
      "description": "Validates data borrowing patterns."
    },
    "description": "Implements lightweight borrow-checking; warns if references outlive their data source.",
    "md_file_path": "directives/fp_borrow_check.md",
    "workflow": {
      "trunk": "analyze_borrow_scope",
      "branches": [
        {
          "if": "dangling_reference",
          "then": "error_borrow_violation"
        },
        {
          "if": "safe_borrow",
          "then": "mark_compliant"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "dangling_reference",
        "resolution": "Use copy or shorter scope"
      },
      {
        "issue": "borrow_lifetime_conflict",
        "resolution": "Restructure code for ownership clarity"
      }
    ],
    "intent_keywords_json": [
      "borrow check",
      "reference lifetime"
    ],
    "confidence_threshold": 0.6,
    "notes": "Emulates borrow semantics in dynamic languages to ensure safe ownership boundaries."
  },
  {
    "name": "fp_no_oop",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "anti_oop",
      "description": "Prohibits class-based programming constructs."
    },
    "description": "Detects OOP usage such as class, inheritance, and stateful methods; refactors into functional equivalents.",
    "md_file_path": "directives/fp_no_oop.md",
    "workflow": {
      "trunk": "scan_code_for_oop",
      "branches": [
        {
          "if": "class_detected",
          "then": "refactor_to_module_function"
        },
        {
          "if": "method_with_state",
          "then": "convert_to_pure_function"
        },
        {
          "fallback": "mark_as_compliant"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "oop_construct",
        "resolution": "Flatten class into module"
      },
      {
        "issue": "stateful_method",
        "resolution": "Convert to stateless function"
      }
    ],
    "intent_keywords_json": [
      "class",
      "oop",
      "inheritance"
    ],
    "confidence_threshold": 0.8,
    "notes": "Core anti-OOP directive; ensures functional procedural compliance."
  },
  {
    "name": "fp_wrapper_generation",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "anti_oop",
      "description": "Automatically creates wrappers for OOP libraries."
    },
    "description": "Detects OOP library imports and generates pure functional wrappers for AI-safe usage.",
    "md_file_path": "directives/fp_wrapper_generation.md",
    "workflow": {
      "trunk": "detect_oop_libraries",
      "branches": [
        {
          "if": "library_on_blacklist",
          "then": "generate_wrapper"
        },
        {
          "if": "unknown_library",
          "then": "prompt_for_wrapper"
        },
        {
          "fallback": "skip_if_pure"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "unwrapped_library",
        "resolution": "Generate wrapper via fp_wrapper_generation"
      },
      {
        "issue": "dynamic_import",
        "resolution": "Manual wrapper required"
      }
    ],
    "intent_keywords_json": [
      "wrapper",
      "library",
      "functional wrapper"
    ],
    "confidence_threshold": 0.6,
    "notes": "Maintains FP purity across legacy OOP dependencies."
  },
  {
    "name": "fp_inheritance_flattening",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "anti_oop",
      "description": "Removes class inheritance by flattening methods."
    },
    "description": "Converts class hierarchies into flattened procedural functions.",
    "md_file_path": "directives/fp_inheritance_flattening.md",
    "workflow": {
      "trunk": "scan_inheritance",
      "branches": [
        {
          "if": "inheritance_chain_detected",
          "then": "merge_methods"
        },
        {
          "fallback": "mark_as_functional"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "deep_inheritance",
        "resolution": "Flatten to module functions"
      },
      {
        "issue": "overridden_methods",
        "resolution": "Preserve order manually"
      }
    ],
    "intent_keywords_json": [
      "inheritance",
      "flatten",
      "class to function"
    ],
    "confidence_threshold": 0.6,
    "notes": "Ensures all logic is in flat procedural form, avoiding OOP hierarchies."
  },
  {
    "name": "fp_chaining",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "composition",
      "description": "Facilitates chaining of functions in sequence."
    },
    "description": "Encourages chaining of small functions using pipeline or composition syntax.",
    "md_file_path": "directives/fp_chaining.md",
    "workflow": {
      "trunk": "analyze_function_calls",
      "branches": [
        {
          "if": "independent_calls",
          "then": "convert_to_pipeline"
        },
        {
          "if": "nested_functions",
          "then": "flatten_to_chain"
        },
        {
          "fallback": "mark_as_compliant"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "deep_nesting",
        "resolution": "Flatten into chained composition"
      },
      {
        "issue": "redundant_calls",
        "resolution": "Simplify chain"
      }
    ],
    "intent_keywords_json": [
      "pipe",
      "chain",
      "compose"
    ],
    "confidence_threshold": 0.7,
    "notes": "Improves clarity and composability in generated functional code."
  },
  {
    "name": "fp_currying",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "composition",
      "description": "Transforms multi-argument functions into chained single-argument calls."
    },
    "description": "Refactors functions with multiple parameters into curried, single-argument forms for partial application.",
    "md_file_path": "directives/fp_currying.md",
    "workflow": {
      "trunk": "inspect_function_signature",
      "branches": [
        {
          "if": "multi_argument_function",
          "then": "transform_to_curried"
        },
        {
          "if": "already_curried",
          "then": "mark_as_compliant"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "parameter_dependency",
        "resolution": "Reorder for partial application"
      }
    ],
    "intent_keywords_json": [
      "curry",
      "partial",
      "functional chaining"
    ],
    "confidence_threshold": 0.6,
    "notes": "Supports partial application and higher-order reuse of generated functions."
  },
  {
    "name": "fp_pattern_matching",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "control_flow",
      "description": "Uses declarative pattern matching instead of conditionals."
    },
    "description": "Promotes pattern matching constructs for control flow instead of nested if/else.",
    "md_file_path": "directives/fp_pattern_matching.md",
    "workflow": {
      "trunk": "analyze_conditionals",
      "branches": [
        {
          "if": "nested_conditionals",
          "then": "convert_to_match"
        },
        {
          "if": "static_patterns",
          "then": "create_case_structures"
        },
        {
          "fallback": "mark_compliant"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "deep_if_else",
        "resolution": "Replace with match/case"
      },
      {
        "issue": "ambiguous_pattern",
        "resolution": "Prompt for explicit mapping"
      }
    ],
    "intent_keywords_json": [
      "pattern match",
      "case",
      "control flow"
    ],
    "confidence_threshold": 0.7,
    "notes": "Encourages declarative decision logic across all supported languages."
  },
  {
    "name": "fp_tail_recursion",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "control_flow",
      "description": "Optimizes recursion patterns to tail calls."
    },
    "description": "Refactors recursive calls to use tail recursion for stack safety and performance.",
    "md_file_path": "directives/fp_tail_recursion.md",
    "workflow": {
      "trunk": "analyze_recursion",
      "branches": [
        {
          "if": "non_tail_recursion",
          "then": "refactor_to_tail_call"
        },
        {
          "fallback": "mark_as_optimized"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "deep_recursion",
        "resolution": "Refactor to tail recursion or iteration"
      }
    ],
    "intent_keywords_json": [
      "tail recursion",
      "optimize recursion"
    ],
    "confidence_threshold": 0.6,
    "notes": "Ensures recursion efficiency and prevents stack overflows in AI-generated code."
  },
  {
    "name": "fp_type_safety",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "type_system",
      "description": "Guarantees all functions have explicit type annotations."
    },
    "description": "Verifies that all function signatures include type information and that return types are deterministic.",
    "md_file_path": "directives/fp_type_safety.md",
    "workflow": {
      "trunk": "check_function_signatures",
      "branches": [
        {
          "if": "missing_types",
          "then": "infer_and_insert"
        },
        {
          "if": "type_conflict",
          "then": "prompt_user"
        },
        {
          "fallback": "mark_compliant"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "missing_annotation",
        "resolution": "Infer or request explicit type"
      },
      {
        "issue": "type_mismatch",
        "resolution": "Resolve via type inference"
      }
    ],
    "intent_keywords_json": [
      "type",
      "annotation",
      "signature"
    ],
    "confidence_threshold": 0.7,
    "notes": "Enforces strong typing discipline within FP code."
  },
  {
    "name": "fp_type_inference",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "type_system",
      "description": "Performs static-like type inference for dynamic languages."
    },
    "description": "Uses AI-assisted inference to identify likely input/output types when not annotated explicitly.",
    "md_file_path": "directives/fp_type_inference.md",
    "workflow": {
      "trunk": "infer_types",
      "branches": [
        {
          "if": "ambiguous_types",
          "then": "prompt_user"
        },
        {
          "if": "clear_pattern",
          "then": "store_in_metadata"
        },
        {
          "fallback": "mark_as_inferred"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "unclear_type",
        "resolution": "Request user clarification"
      },
      {
        "issue": "inconsistent_type",
        "resolution": "Mark for review"
      }
    ],
    "intent_keywords_json": [
      "type inference",
      "deduce",
      "infer"
    ],
    "confidence_threshold": 0.6,
    "notes": "Adds soft type inference for dynamic contexts."
  },
  {
    "name": "fp_side_effects_flag",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "side_effects",
      "description": "Detects, isolates, and flags side effects."
    },
    "description": "Detects side effects and ensures they are either isolated or explicitly declared.",
    "md_file_path": "directives/fp_side_effects_flag.md",
    "workflow": {
      "trunk": "scan_for_effects",
      "branches": [
        {
          "if": "io_found",
          "then": "wrap_in_io_function"
        },
        {
          "if": "global_mutation",
          "then": "refactor_to_pure"
        },
        {
          "fallback": "mark_as_clean"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "hidden_side_effect",
        "resolution": "Wrap or isolate"
      },
      {
        "issue": "untracked_io",
        "resolution": "Use dedicated I/O handler"
      }
    ],
    "intent_keywords_json": [
      "side effects",
      "io",
      "mutation"
    ],
    "confidence_threshold": 0.7,
    "notes": "Ensures transparent handling of all side effects within FP boundaries."
  },
  {
    "name": "fp_concurrency_safety",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "concurrency",
      "description": "Ensures thread safety in concurrent FP operations."
    },
    "description": "Analyzes concurrency patterns to prevent race conditions and shared mutable state.",
    "md_file_path": "directives/fp_concurrency_safety.md",
    "workflow": {
      "trunk": "analyze_parallel_flows",
      "branches": [
        {
          "if": "shared_state",
          "then": "apply_lock_or_copy"
        },
        {
          "if": "immutable_flows",
          "then": "approve_concurrency"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "race_condition",
        "resolution": "Duplicate data or enforce locks"
      },
      {
        "issue": "shared_state",
        "resolution": "Use message passing"
      }
    ],
    "intent_keywords_json": [
      "thread safe",
      "parallel",
      "concurrent"
    ],
    "confidence_threshold": 0.7,
    "notes": "Ensures concurrent functional operations are free of shared mutable data."
  },
  {
    "name": "fp_dependency_tracking",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "introspection",
      "description": "Tracks relationships between functions for dependency mapping."
    },
    "description": "Analyzes function call graphs and stores dependency metadata for reasoning and code generation alignment.",
    "md_file_path": "directives/fp_dependency_tracking.md",
    "workflow": {
      "trunk": "trace_function_calls",
      "branches": [
        {
          "if": "dependency_detected",
          "then": "store_in_metadata"
        },
        {
          "if": "circular_dependency",
          "then": "alert_and_resolve"
        },
        {
          "fallback": "mark_as_clean"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "circular_dependency",
        "resolution": "Refactor to break loop"
      }
    ],
    "intent_keywords_json": [
      "dependency",
      "import",
      "call graph"
    ],
    "confidence_threshold": 0.7,
    "notes": "Provides dependency awareness to improve AIFP’s reasoning efficiency."
  },
  {
    "name": "fp_guard_clauses",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "control_flow",
      "description": "Uses guard clauses to simplify nested conditionals."
    },
    "description": "Rewrites nested conditional branches into early exit guard clauses for clarity and maintainability.",
    "md_file_path": "directives/fp_guard_clauses.md",
    "workflow": {
      "trunk": "analyze_conditionals",
      "branches": [
        {
          "if": "nested_if_detected",
          "then": "convert_to_guard_clause"
        },
        {
          "if": "redundant_conditions",
          "then": "simplify_flow"
        },
        {
          "fallback": "mark_as_simplified"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "deep_nesting",
        "resolution": "Introduce guard clause"
      },
      {
        "issue": "redundant_branch",
        "resolution": "Simplify flow"
      }
    ],
    "intent_keywords_json": [
      "guard clause",
      "early return",
      "flatten conditionals"
    ],
    "confidence_threshold": 0.7,
    "notes": "Encourages concise and readable control flow without branching complexity."
  },
  {
    "name": "fp_conditional_elimination",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "control_flow",
      "description": "Replaces imperative if/else with declarative expressions."
    },
    "description": "Refactors imperative conditionals into functional expressions using mapping or match constructs.",
    "md_file_path": "directives/fp_conditional_elimination.md",
    "workflow": {
      "trunk": "analyze_branching_logic",
      "branches": [
        {
          "if": "imperative_if_else",
          "then": "convert_to_expression"
        },
        {
          "if": "switch_detected",
          "then": "replace_with_match"
        },
        {
          "fallback": "mark_as_declarative"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "imperative_branching",
        "resolution": "Refactor to expression-based control"
      }
    ],
    "intent_keywords_json": [
      "if elimination",
      "declarative control"
    ],
    "confidence_threshold": 0.6,
    "notes": "Removes imperative control structures; promotes declarative, expression-based logic."
  },
  {
    "name": "fp_generic_constraints",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "type_system",
      "description": "Adds compile-time-like constraints for generic parameters."
    },
    "description": "Validates that generics or templates adhere to specified type constraints where possible.",
    "md_file_path": "directives/fp_generic_constraints.md",
    "workflow": {
      "trunk": "check_generic_bounds",
      "branches": [
        {
          "if": "unbounded_generic",
          "then": "infer_constraints"
        },
        {
          "if": "conflicting_bounds",
          "then": "prompt_user"
        },
        {
          "fallback": "mark_as_safe"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "unbounded_generic",
        "resolution": "Infer or specify constraint"
      },
      {
        "issue": "type_conflict",
        "resolution": "Manually verify bounds"
      }
    ],
    "intent_keywords_json": [
      "generic",
      "constraint",
      "bounded type"
    ],
    "confidence_threshold": 0.6,
    "notes": "Ensures correctness when using generics or polymorphic function templates."
  },
  {
    "name": "fp_runtime_type_check",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "type_system",
      "description": "Adds runtime type validation in dynamically typed environments."
    },
    "description": "Injects runtime guards or assertions to ensure type correctness when static typing is unavailable.",
    "md_file_path": "directives/fp_runtime_type_check.md",
    "workflow": {
      "trunk": "insert_type_checks",
      "branches": [
        {
          "if": "type_missing",
          "then": "insert_runtime_assert"
        },
        {
          "if": "type_mismatch",
          "then": "raise_validation_warning"
        },
        {
          "fallback": "mark_compliant"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "no_type_info",
        "resolution": "Add runtime guard"
      },
      {
        "issue": "dynamic_violation",
        "resolution": "Log or assert"
      }
    ],
    "intent_keywords_json": [
      "runtime type",
      "validation",
      "assert type"
    ],
    "confidence_threshold": 0.7,
    "notes": "Adds defensive checks to maintain type safety at runtime."
  },
  {
    "name": "fp_io_isolation",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "side_effects",
      "description": "Isolates input/output operations from logic layers."
    },
    "description": "Separates all input/output operations into dedicated effect functions or external modules.",
    "md_file_path": "directives/fp_io_isolation.md",
    "workflow": {
      "trunk": "detect_io_operations",
      "branches": [
        {
          "if": "io_inline",
          "then": "move_to_io_function"
        },
        {
          "if": "external_call",
          "then": "wrap_in_effect"
        },
        {
          "fallback": "mark_as_pure"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "inline_io",
        "resolution": "Move I/O to dedicated effect function"
      },
      {
        "issue": "external_api_call",
        "resolution": "Wrap in pure function boundary"
      }
    ],
    "intent_keywords_json": [
      "io",
      "input output",
      "effect isolation"
    ],
    "confidence_threshold": 0.7,
    "notes": "Maintains strict separation between I/O and logic for deterministic behavior."
  },
  {
    "name": "fp_logging_safety",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "side_effects",
      "description": "Ensures logging is functional and isolated."
    },
    "description": "Redirects logging to pure output streams or external effect handlers to avoid hidden state.",
    "md_file_path": "directives/fp_logging_safety.md",
    "workflow": {
      "trunk": "scan_for_logging",
      "branches": [
        {
          "if": "logging_inline",
          "then": "redirect_to_effect_handler"
        },
        {
          "if": "stateful_logger",
          "then": "refactor_to_pure_logger"
        },
        {
          "fallback": "mark_safe"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "inline_logging",
        "resolution": "Use stateless logger"
      },
      {
        "issue": "mutable_logger",
        "resolution": "Replace with functional logger"
      }
    ],
    "intent_keywords_json": [
      "log",
      "logger",
      "output safety"
    ],
    "confidence_threshold": 0.6,
    "notes": "Prevents stateful or side-effect-heavy logging inside functions."
  },
  {
    "name": "fp_parallel_purity",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "concurrency",
      "description": "Ensures parallel tasks are pure and independent."
    },
    "description": "Validates that functions running in parallel are independent and side-effect free.",
    "md_file_path": "directives/fp_parallel_purity.md",
    "workflow": {
      "trunk": "inspect_parallel_tasks",
      "branches": [
        {
          "if": "shared_resource_detected",
          "then": "copy_or_lock_resource"
        },
        {
          "if": "independent_tasks",
          "then": "approve_parallelism"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "shared_resource",
        "resolution": "Isolate data before parallelization"
      }
    ],
    "intent_keywords_json": [
      "parallel",
      "thread safe",
      "concurrent"
    ],
    "confidence_threshold": 0.7,
    "notes": "Protects functional integrity in parallel operations."
  },
  {
    "name": "fp_task_isolation",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "concurrency",
      "description": "Prevents cross-task data leakage in async or parallel flows."
    },
    "description": "Enforces isolation between parallel tasks by cloning or message-passing data.",
    "md_file_path": "directives/fp_task_isolation.md",
    "workflow": {
      "trunk": "analyze_task_flows",
      "branches": [
        {
          "if": "shared_state",
          "then": "duplicate_or_pass_copy"
        },
        {
          "if": "safe_isolation",
          "then": "approve_task"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "shared_task_state",
        "resolution": "Use immutable copy"
      }
    ],
    "intent_keywords_json": [
      "task isolation",
      "async",
      "parallel safety"
    ],
    "confidence_threshold": 0.7,
    "notes": "Maintains purity across concurrent functional tasks."
  },
  {
    "name": "fp_call_graph_generation",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "introspection",
      "description": "Generates a call graph for reasoning and debugging."
    },
    "description": "Builds an internal representation of all function calls for dependency and impact analysis.",
    "md_file_path": "directives/fp_call_graph_generation.md",
    "workflow": {
      "trunk": "scan_for_function_calls",
      "branches": [
        {
          "if": "function_call_detected",
          "then": "record_dependency"
        },
        {
          "if": "graph_complete",
          "then": "store_in_metadata"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "unresolved_symbol",
        "resolution": "Link or flag for analysis"
      }
    ],
    "intent_keywords_json": [
      "call graph",
      "dependency map"
    ],
    "confidence_threshold": 0.7,
    "notes": "Used by MCP for dependency reasoning and impact analysis."
  },
  {
    "name": "fp_reflection_limitation",
    "type": "fp",
    "parent_directive": null,
    "category": {
      "name": "introspection",
      "description": "Restricts reflection and dynamic code evaluation."
    },
    "description": "Detects and disallows reflection, dynamic eval, or runtime metaprogramming constructs.",
    "md_file_path": "directives/fp_reflection_limitation.md",
    "workflow": {
      "trunk": "scan_code_for_reflection",
      "branches": [
        {
          "if": "eval_or_reflect_found",
          "then": "block_or_warn"
        },
        {
          "fallback": "mark_as_safe"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "reflection_detected",
        "resolution": "Refactor to static binding"
      }
    ],
    "intent_keywords_json": [
      "reflection",
      "eval",
      "dynamic code"
    ],
    "confidence_threshold": 0.8,
    "notes": "Prevents runtime code generation that violates AIFP determinism."
  }
]