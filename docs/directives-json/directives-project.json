[
  {
    "name": "aifp_run",
    "type": "project",
    "level": 0,
    "parent_directive": null,
    "category": {
      "name": "orchestration",
      "description": "Gateway and reminder for AIFP directive application."
    },
    "description": "Gateway entry point for AIFP system. Returns guidance to AI assistant on when and how to use AIFP directives. Does NOT execute directives itself - AI receives guidance and decides next action based on task type (coding, project management, or simple discussion). Always assume AIFP applies unless user explicitly rejects. First action should be calling aifp_status to understand current project state.",
    "md_file_path": "directives/aifp_run.md",
    "workflow": {
      "trunk": "evaluate_is_new_session_parameter",
      "branches": [
        {
          "if": "is_new_session_true",
          "then": "bundle_session_startup_data",
          "details": {
            "call_helpers": [
              "aifp_status() - comprehensive project state",
              "get_user_settings() - all user settings",
              "get_fp_directive_index() - FP directives grouped by category"
            ],
            "cache_in_context": true,
            "return_with_suggestions": true,
            "message": "Bundling session startup data (status + settings + FP index)",
            "guidance": {
              "cache_bundle": "Cache entire bundle (status, settings, fp_index) in your context to avoid re-fetching",
              "when_to_refresh": "Call aifp_run(is_new_session=true) again after: (1) major state changes (init/milestone complete), (2) long breaks, (3) new conversation",
              "use_for_navigation": "Use returned state with get_next_directives_from_status() to find appropriate next directives",
              "fp_reference": "Use fp_index for quick FP directive lookup by category. Call search_directives(type='fp') or get_directive_by_name(name) for directive JSON. If more context needed, read MD file directly (path provided in directive object's md_file_path field)",
              "settings_usage": "Apply user_settings preferences during directive execution (code style, task granularity, etc.)"
            }
          }
        },
        {
          "if": "is_new_session_false_or_default",
          "then": "return_lightweight_guidance",
          "details": {
            "assume_ai_has_cached_data": true,
            "message": "AIFP MCP available (continuation mode)",
            "common_starting_points": [
              "aifp_status - Get comprehensive project state (if not cached)",
              "project_init - Initialize new AIFP project",
              "project_file_write - Write code and update database",
              "project_task_create - Create new tasks",
              "project_task_complete - Mark task as complete and loop back to status"
            ],
            "guidance": {
              "directive_access": "Call get_all_directives() if you don't have them in memory. Call get_directive(name) or search_directives(keyword, category, type) for specific details.",
              "when_to_use": "Use AIFP directives when coding or when project management action/reaction is needed.",
              "assumption": "Always assume AIFP applies unless user explicitly rejects it with 'do not use aifp for this task'.",
              "status_based_navigation": "If you have status cached, query directive_flow table with get_next_directives_from_status(current_directive, state_object) to find next steps",
              "directive_flow_queries": [
                "get_next_directives_from_status(current_directive, state_object)",
                "get_conditional_work_paths(state_object)",
                "get_completion_loop_target(completion_directive_name)",
                "get_directive_flows(flow_category='fp') - query FP flows",
                "get_directive_flows(flow_category='git') - query git flows"
              ],
              "when_to_get_fresh_bundle": "Call aifp_run(is_new_session=true) if: (1) new session, (2) after major state change, (3) unsure of current state, (4) user asks for status",
              "available_helpers": [
                "get_all_directives",
                "get_directive",
                "search_directives",
                "get_next_directives_from_status",
                "get_user_settings",
                "get_fp_directive_index",
                "get_directive_flows",
                "query_mcp_db",
                "get_project_context",
                "get_project_status",
                "get_project_files",
                "get_project_functions",
                "get_project_tasks",
                "query_project_db"
              ]
            },
            "ai_decision_flow": [
              "1. If new session or unclear context: Consider calling aifp_run(is_new_session=true) for fresh bundle",
              "2. Check project type: Query project.user_directives_status (NULL=Use Case 1, 'in_progress'/'active'/'disabled'=Use Case 2)",
              "3. Evaluate: Is this coding, project management, or user directive automation?",
              "4. Check: Do I have directives in memory?",
              "5. If no directives: Call get_all_directives() to load 125 directives",
              "6. If you have cached status: Use directive_flow queries to determine next appropriate directive",
              "7. If coding: Apply FP directives (how to code) + project directives (DB updates)",
              "8. If project management: Apply project directives based on status and user intent",
              "9. If user directive task (Use Case 2): Apply user directive system directives (parse/validate/implement/approve/activate pipeline)",
              "10. If simple discussion: No directives needed unless decision impacts project"
            ]
          }
        }
      ],
      "error_handling": {
        "on_failure": "return_guidance_anyway"
      }
    },
    "roadblocks_json": [
      {
        "issue": "ai_bypasses_aifp",
        "resolution": "System prompt should enforce: 'If AIFP MCP present, always call aifp_run unless explicitly rejected'"
      },
      {
        "issue": "ai_forgets_directives",
        "resolution": "AI should call get_all_directives() when directives not in memory"
      },
      {
        "issue": "ai_unsure_when_to_use",
        "resolution": "Guidance clarifies: coding + project management = use directives"
      },
      {
        "issue": "ai_starts_without_context",
        "resolution": "Call aifp_status first to understand project state and current focus"
      }
    ],
    "intent_keywords_json": [
      "run",
      "execute",
      "aifp",
      "start",
      "continue",
      "status",
      "resume"
    ],
    "confidence_threshold": 1.0
  },
  {
    "name": "project_init",
    "type": "project",
    "level": 1,
    "parent_directive": "aifp_run",
    "category": {
      "name": "initialization",
      "description": "Handles creation and setup of new AIFP projects with ProjectBlueprint.md creation."
    },
    "description": "Initializes a new AIFP project by creating .aifp-project/ folder structure, generating ProjectBlueprint.md through interactive prompts, initializing project.db and user_preferences.db, and populating with initial infrastructure, themes, flows, and completion path. Wraps the standalone initialization script (aifp.scripts.init_aifp_project) helper functions to ensure consistent setup. Checks for existing .aifp-project/ or .git/.aifp/ folders before initialization. Scans existing codebase for OOP patterns and aborts initialization if OOP detected (AIFP is FP-only). Offers restoration from .git/.aifp/ backup if found.",
    "md_file_path": "directives/project_init.md",
    "workflow": {
      "trunk": "check_existing_state",
      "branches": [
        {
          "if": "aifp_folder_exists",
          "then": "call_aifp_status",
          "details": {
            "message": ".aifp-project/ folder already exists"
          }
        },
        {
          "if": "existing_code_detected_no_aifp",
          "then": "scan_for_oop_patterns",
          "details": {
            "scan_patterns": {
              "oop_indicators": [
                "class .*\\(.*\\):",
                "self\\.",
                "this\\.",
                "__init__",
                "def .*\\(self",
                "extends ",
                "implements ",
                "interface ",
                "abstract class"
              ],
              "file_types": ["*.py", "*.js", "*.ts", "*.java", "*.cpp", "*.cs", "*.rb", "*.php"],
              "threshold": "3+ OOP patterns detected across multiple files"
            },
            "trigger": "fp_no_oop directive for pattern detection",
            "note": "Scans existing codebase before initialization to detect OOP patterns"
          }
        },
        {
          "if": "oop_detected_in_existing_code",
          "then": "abort_initialization_with_message",
          "details": {
            "action": "abort_without_init",
            "message": "ðŸ›‘ AIFP Incompatible Project Detected\n\nThis directory contains existing OOP-based code. AIFP is designed exclusively for Functional Procedural (FP) codebases.\n\nYour options:\n1. Convert this project to FP first (major refactor - use AIFP in a separate directory to help)\n2. Disable/uninstall AIFP MCP server for this project\n3. Start a new FP-compliant project in a different directory\n\nAIFP cannot manage OOP projects - it enforces pure functions, immutability, and no classes with methods.",
            "exit_directive": true,
            "do_not_initialize": true
          }
        },
        {
          "if": "existing_code_is_fp_or_empty",
          "then": "proceed_with_initialization",
          "details": {
            "message": "Existing code appears FP-compliant or directory is empty. Proceeding with initialization.",
            "continue_to_next_branch": true
          }
        },
        {
          "if": "git_aifp_backup_exists",
          "then": "prompt_restore_or_new",
          "details": {
            "check_path": ".git/.aifp/ProjectBlueprint.md"
          }
        },
        {
          "if": "restore_chosen",
          "then": "restore_from_git_backup",
          "details": {
            "copy_from": ".git/.aifp/",
            "copy_to": ".aifp-project/"
          }
        },
        {
          "if": "new_project_chosen",
          "then": "interactive_blueprint_creation",
          "details": {
            "prompts": [
              "project_name",
              "purpose",
              "goals",
              "language",
              "build_tool"
            ]
          }
        },
        {
          "if": "blueprint_prompts_complete",
          "then": "create_project_structure",
          "details": {
            "module": "aifp.scripts.init_aifp_project",
            "parameters": {
              "target_path": "user_working_dir"
            },
            "create_folders": [
              ".aifp-project/",
              ".aifp-project/backups/"
            ],
            "note": "Uses standalone initialization script helper function"
          }
        },
        {
          "if": "structure_created",
          "then": "generate_project_blueprint",
          "details": {
            "module": "aifp.scripts.init_aifp_project",
            "parameters": {
              "aifp_dir": ".aifp-project/",
              "metadata": "from_prompts"
            },
            "template": "ProjectBlueprint_template.md",
            "output": ".aifp-project/ProjectBlueprint.md",
            "note": "Uses standalone initialization script helper function"
          }
        },
        {
          "if": "blueprint_generated",
          "then": "initialize_databases",
          "details": {
            "module": "aifp.scripts.init_aifp_project",
            "parameters": {
              "aifp_dir": ".aifp-project/",
              "project_metadata": "from_prompts"
            },
            "databases": [
              "project.db",
              "user_preferences.db"
            ],
            "schemas": [
              "project_db_schema.sql",
              "user_preferences_schema.sql"
            ],
            "note": "Uses standalone initialization script helper functions"
          }
        },
        {
          "if": "databases_initialized",
          "then": "validate_initialization",
          "details": {
            "module": "aifp.scripts.init_aifp_project",
            "parameters": {
              "aifp_dir": ".aifp-project/"
            },
            "checks": [
              "project.db exists and has metadata",
              "user_preferences.db has schema",
              "ProjectBlueprint.md exists",
              "all required tables created"
            ],
            "note": "Validates complete initialization using script function"
          }
        },
        {
          "if": "validation_passed",
          "then": "populate_project_data",
          "details": {
            "tables": [
              "project",
              "infrastructure",
              "completion_path",
              "milestones"
            ],
            "note": "Project metadata already populated by initialize_project_db helper"
          }
        },
        {
          "if": "project_data_populated",
          "then": "create_initial_completion_path",
          "details": {
            "stages": [
              "Setup",
              "Core Development",
              "Finalization"
            ]
          }
        },
        {
          "if": "completion_path_created",
          "then": "prompt_user_directives_init",
          "details": {
            "prompt": "Initialize user directives system? (y/n)",
            "optional": true
          }
        },
        {
          "if": "user_directives_yes",
          "then": "init_user_directives_db",
          "details": {
            "create_db": "user_directives.db",
            "apply_schema": "user_directives_schema.sql",
            "set_status": "in_progress"
          }
        },
        {
          "if": "user_directives_no_or_complete",
          "then": "initialize_git_if_needed",
          "details": {
            "trigger": "git_init directive",
            "action": "Initialize or integrate with Git repository"
          }
        },
        {
          "if": "git_initialized",
          "then": "backup_blueprint",
          "details": {
            "backup_to": ".aifp-project/backups/ProjectBlueprint.md.backup"
          }
        },
        {
          "if": "backup_complete",
          "then": "report_success",
          "details": {
            "show": [
              "project_name",
              "blueprint_path",
              "databases",
              "completion_stages",
              "user_directives_status",
              "git_status"
            ]
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Provide missing project details or choose restoration option"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user",
        "retry": "max 2 attempts"
      }
    },
    "roadblocks_json": [
      {
        "issue": "oop_detected_in_existing_code",
        "resolution": "Abort initialization and inform user that AIFP cannot manage OOP projects. Suggest: 1) Convert to FP first, 2) Disable AIFP MCP server, 3) Start new FP project elsewhere"
      },
      {
        "issue": "db_creation_failed",
        "resolution": "Check file permissions or re-run as admin"
      },
      {
        "issue": "schema_missing",
        "resolution": "Verify schema file in /schemas/"
      },
      {
        "issue": "aifp_folder_exists",
        "resolution": "Call aifp_status to show existing project state"
      },
      {
        "issue": "blueprint_generation_failed",
        "resolution": "Use default template and prompt user for manual completion"
      },
      {
        "issue": "git_backup_corrupted",
        "resolution": "Prompt user to start fresh or provide backup manually"
      }
    ],
    "intent_keywords_json": [
      "create project",
      "initialize",
      "start project",
      "init project",
      "new project"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_task_decomposition",
    "type": "project",
    "level": 2,
    "parent_directive": "aifp_run",
    "category": {
      "name": "task_management",
      "description": "Manages decomposition of user goals into AIFP-aligned tasks, subtasks, and sidequests."
    },
    "description": "Decomposes high-level user requests into completion_path, milestones, tasks, subtasks, and items. When tasks require code generation, use project_reserve_finalize before project_file_write to reserve names and get database IDs. Respects user preferences for task granularity, naming conventions, and decomposition style. Creates roadmap structure and ensures hierarchy consistency. Central decomposition directive; translates user intent into actionable milestones.",
    "md_file_path": "directives/project_task_decomposition.md",
    "workflow": {
      "trunk": "check_user_preferences",
      "branches": [
        {
          "if": "directive_preferences_exist",
          "then": "load_task_preferences",
          "details": {
            "query": "SELECT preference_key, preference_value FROM directive_preferences WHERE directive_name='project_task_decomposition' AND active=1",
            "common_preferences": [
              "naming_convention",
              "auto_create_items",
              "default_priority"
            ]
          }
        },
        {
          "if": "preferences_loaded",
          "then": "decompose_with_preferences",
          "details": {
            "apply_granularity": true,
            "respect_naming_convention": true
          }
        },
        {
          "if": "task_decomposition_requested",
          "then": "call_aifp_status",
          "details": {
            "purpose": "Understand current context before creating new tasks",
            "brief": true
          }
        },
        {
          "if": "status_obtained",
          "then": "review_open_tasks",
          "details": {
            "check_sidequests": true,
            "check_subtasks": true,
            "check_tasks": true
          }
        },
        {
          "if": "related_to_open_task",
          "then": "update_if_needed",
          "details": {
            "check_alignment": true
          }
        },
        {
          "if": "new_task_needed",
          "then": "create_new_task",
          "details": {
            "link_to_completion_path": true,
            "update_project_version": true
          }
        },
        {
          "if": "subtask_needed",
          "then": "create_subtask",
          "details": {
            "table": "subtasks",
            "priority": "high",
            "pause_parent_task": true
          }
        },
        {
          "if": "sidequest_needed",
          "then": "create_sidequest",
          "details": {
            "table": "sidequests",
            "priority": "low",
            "link_to_project": true
          }
        },
        {
          "if": "interruption_detected",
          "then": "handle_subtask_priority",
          "details": {
            "notify_user": true,
            "options": "complete/discard/resume"
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Is this a new task, subtask, or sidequest?"
          }
        },
        {
          "parallel": [
            "execute_code_gen",
            "update_db"
          ],
          "details": {
            "if_code_and_db": true
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user",
        "retry": "max 2 attempts"
      }
    },
    "roadblocks_json": [
      {
        "issue": "task vs subtask vs sidequest ambiguity",
        "resolution": "Prompt user for clarification, log in notes"
      },
      {
        "issue": "no matching open task",
        "resolution": "Create new task or sidequest, align to completion_path"
      },
      {
        "issue": "status_unavailable",
        "resolution": "Continue with decomposition but warn user about potential context issues"
      }
    ],
    "intent_keywords_json": [
      "decompose task",
      "break down",
      "plan steps",
      "explore"
    ],
    "confidence_threshold": 0.5
  },
  {
    "name": "project_add_path",
    "type": "project",
    "level": 2,
    "parent_directive": "project_task_decomposition",
    "category": {
      "name": "task_management",
      "description": "Handles roadmap and completion_path modifications."
    },
    "description": "Creates or updates completion_path, milestones, and tasks in project.db to maintain project roadmap continuity. Maintains structural coherence of project paths and milestones.",
    "md_file_path": "directives/project_add_path.md",
    "workflow": {
      "trunk": "modify_path",
      "branches": [
        {
          "if": "new_path",
          "then": "insert_completion_path",
          "details": {
            "order_index": true
          }
        },
        {
          "if": "new_task",
          "then": "insert_task",
          "details": {
            "link_to_milestone": true
          }
        },
        {
          "if": "new_subtask",
          "then": "insert_subtask",
          "details": {
            "table": "subtasks",
            "priority": "high"
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Add to roadmap?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "path_misaligned",
        "resolution": "Prompt user for roadmap alignment"
      },
      {
        "issue": "duplicate_entry",
        "resolution": "Verify milestone/task uniqueness"
      }
    ],
    "intent_keywords_json": [
      "add path",
      "update roadmap",
      "milestone"
    ],
    "confidence_threshold": 0.6
  },
  {
    "name": "project_file_write",
    "type": "project",
    "level": 3,
    "parent_directive": "project_add_path",
    "category": {
      "name": "file_operations",
      "description": "Handles file generation and metadata updates."
    },
    "description": "Writes new or modified files using the AIFP-compliant output pattern, validates via FP directives, enforces DRY principle by extracting IDENTICAL functions to shared modules at appropriate scope level (avoid forced DRY with god functions), and updates project.db accordingly. Should use project_reserve_finalize BEFORE writing to get database IDs for embedding in filenames/function names. Detects user directive generated files and marks them with appropriate metadata. Applies user preferences from directive_preferences table (e.g., always_add_docstrings, max_function_length, prefer_guard_clauses) loaded by user_preferences_sync. Core file generation directive; bridges code creation and database synchronization.",
    "md_file_path": "directives/project_file_write.md",
    "workflow": {
      "trunk": "check_user_preferences",
      "branches": [
        {
          "if": "directive_preferences_exist",
          "then": "load_and_apply_preferences",
          "details": {
            "query": "SELECT preference_key, preference_value FROM directive_preferences WHERE directive_name='project_file_write' AND active=1",
            "apply_to": "code_generation_context",
            "common_preferences": [
              "always_add_docstrings",
              "max_function_length",
              "prefer_guard_clauses",
              "code_style",
              "indent_style"
            ]
          }
        },
        {
          "if": "preferences_applied",
          "then": "generate_file_with_preferences",
          "details": {
            "respect_user_settings": true,
            "fallback_to_defaults": "if_preference_missing"
          }
        },
        {
          "if": "file_path_starts_with_.aifp-project/user-directives/generated/",
          "then": "mark_as_user_directive_implementation",
          "details": {
            "metadata_tag": "user_directive_generated",
            "still_apply_fp_checks": true
          }
        },
        {
          "if": "user_directive_file_and_compliant",
          "then": "write_file_and_link_to_directive",
          "details": {
            "update_db": true,
            "update_directive_implementations_table": true,
            "link_to_user_directive": true
          }
        },
        {
          "if": "code_compliant",
          "then": "write_file",
          "details": {
            "metadata": true,
            "update_db": true
          }
        },
        {
          "if": "non_compliant",
          "then": "fp_compliance_check",
          "details": {
            "escalate_to_fp_directives": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Fix compliance before write?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "missing_metadata",
        "resolution": "Add AIFP_METADATA, prompt user"
      },
      {
        "issue": "fp_violation",
        "resolution": "Trigger fp_compliance_check"
      },
      {
        "issue": "user_directive_link_missing",
        "resolution": "Parse file for directive reference in AIFP_METADATA or prompt user"
      }
    ],
    "intent_keywords_json": [
      "create file",
      "write code",
      "generate file"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_reserve_finalize",
    "type": "project",
    "level": 3,
    "parent_directive": "project_file_write",
    "category": {
      "name": "database_operations",
      "description": "Reservation and finalization workflow for files, functions, and types."
    },
    "description": "Manages reservation and finalization of files, functions, and types in project database. AI reserves names BEFORE writing code to receive database IDs, embeds IDs in code for instant lookups (filename_id_42.py, function_name_id_99), and finalizes reservations after implementation. Prevents naming collisions, enables rename-proof references, and dramatically reduces API query costs by using integer lookups instead of string matching.",
    "md_file_path": "directives/project_reserve_finalize.md",
    "workflow": {
      "trunk": "reserve_entities",
      "branches": [
        {
          "if": "reserving_file",
          "then": "reserve_file_name",
          "details": {
            "helper": "reserve_file(name, path, language)",
            "returns": "file_id for embedding"
          }
        },
        {
          "if": "reserving_function",
          "then": "reserve_function_name",
          "details": {
            "helper": "reserve_function(name, file_id, purpose)",
            "returns": "function_id for embedding"
          }
        },
        {
          "if": "reserving_type",
          "then": "reserve_type_name",
          "details": {
            "helper": "reserve_type(name, file_id, purpose)",
            "returns": "type_id for embedding"
          }
        },
        {
          "if": "reserved_successfully",
          "then": "write_with_embedded_id",
          "details": {
            "naming": "filename_id_42.py, function_name_id_99(), TypeName_id_7",
            "id_comment": "# AIFP:FUNC:42 or AIFP-ID: 42 in docstring"
          }
        },
        {
          "if": "code_written",
          "then": "finalize_reservation",
          "details": {
            "helpers": "finalize_file(file_id), finalize_function(function_id), finalize_type(type_id)",
            "updates": "name field with embedded ID (e.g., calculate_sum -> calculate_sum_id_99)",
            "sets": "is_reserved=FALSE"
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "reservation_failed_or_unclear"
          }
        }
      ],
      "error_handling": {
        "on_failure": "check_collision_or_retry"
      }
    },
    "roadblocks_json": [
      {
        "issue": "name_collision",
        "resolution": "Suggest alternative names with v2/alt suffix"
      },
      {
        "issue": "reservation_without_implementation",
        "resolution": "Cleanup reservation or mark abandoned"
      },
      {
        "issue": "finalize_without_reserve",
        "resolution": "Verify entity exists and is_reserved flag"
      }
    ],
    "intent_keywords_json": [
      "reserve",
      "finalize",
      "embed ID",
      "database ID",
      "prevent collision"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_update_db",
    "type": "project",
    "level": 3,
    "parent_directive": "project_file_write",
    "category": {
      "name": "file_operations",
      "description": "Synchronizes generated code metadata with the project database."
    },
    "description": "Parses generated code for functions, dependencies, and metadata, then updates project.db tables accordingly to maintain accurate state tracking. Should finalize reservations (via project_reserve_finalize) to update names with embedded IDs and set is_reserved=FALSE after successful file writes. Handles user directive generated files by also updating user_directives.db tables (directive_implementations). Central DB synchronization directive; ensures project.db accurately reflects file and function states after each generation cycle.",
    "md_file_path": "directives/project_update_db.md",
    "workflow": {
      "trunk": "parse_content",
      "branches": [
        {
          "if": "user_directive_generated_file",
          "then": "update_user_directives_db",
          "details": {
            "table": "directive_implementations",
            "link_to_user_directive": true,
            "store_file_path": true,
            "update_status": "implemented"
          }
        },
        {
          "if": "user_directive_implementation_updated",
          "then": "continue_with_project_db_update",
          "details": {
            "proceed_to_standard_flow": true
          }
        },
        {
          "if": "new_file",
          "then": "update_files_table",
          "details": {
            "checksum": true
          }
        },
        {
          "if": "new_function",
          "then": "update_functions_table",
          "details": {
            "deps_json": true
          }
        },
        {
          "if": "task_related",
          "then": "update_items_subtasks",
          "details": {
            "link_to_completion_path": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Update DB for what component?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "missing_metadata",
        "resolution": "Parse again or prompt user for function metadata"
      },
      {
        "issue": "checksum_mismatch",
        "resolution": "Recalculate and resync file entry"
      },
      {
        "issue": "user_directive_not_found",
        "resolution": "Parse file for directive reference or prompt user to link manually"
      }
    ],
    "intent_keywords_json": [
      "update db",
      "track file",
      "metadata"
    ],
    "confidence_threshold": 0.6
  },
  {
    "name": "project_compliance_check",
    "type": "fp",
    "level": null,
    "parent_directive": null,
    "activation_required": "tracking_settings.compliance_checking = enabled",
    "token_overhead": "~5-10% per check",
    "category": {
      "name": "analytics",
      "description": "Optional FP compliance pattern analytics (tracking only, NOT validation)"
    },
    "description": "OPTIONAL analytics directive that tracks FP compliance patterns over time. DISABLED by default (requires tracking_settings.compliance_checking = enabled). NOT a validation gatekeeper - FP compliance is baseline behavior enforced by system prompt. Provides compliance reports and analytics for audits, research, or educational purposes only. Never automatically called by project directives.",
    "md_file_path": "directives/project_compliance_check.md",
    "workflow": {
      "trunk": "check_tracking_enabled",
      "branches": [
        {
          "if": "tracking_disabled",
          "then": "skip",
          "details": {
            "query": "SELECT enabled FROM tracking_settings WHERE feature_name='compliance_checking'",
            "action": "Return early without checking",
            "result": "No token overhead, no analytics collected",
            "note": "Most common path - tracking disabled by default"
          }
        },
        {
          "if": "tracking_enabled",
          "then": "collect_analytics",
          "details": {
            "query_project_db": "SELECT * FROM functions",
            "analyze": "FP patterns, purity levels, compliance distribution",
            "log_to": "fp_flow_tracking table (if enabled)",
            "note": "Non-blocking, fire-and-forget analytics collection"
          }
        },
        {
          "if": "user_requested_report",
          "then": "generate_report",
          "details": {
            "generate": "Compliance summary from project.db",
            "include": "Function purity distribution, FP patterns used",
            "return": "Report to user"
          }
        },
        {
          "fallback": "skip",
          "details": {
            "note": "Graceful failure - tracking errors don't affect development"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "tracking_disabled",
        "resolution": "Enable via tracking_toggle directive with user consent"
      },
      {
        "issue": "performance_impact",
        "resolution": "Use sampling mode (10% tracking) or disable tracking"
      }
    ],
    "intent_keywords_json": [
      "compliance report",
      "compliance analytics",
      "track compliance",
      "compliance patterns"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_completion_check",
    "type": "project",
    "level": 4,
    "parent_directive": "project_milestone_complete",
    "category": {
      "name": "compliance",
      "description": "Evaluates roadmap progress and completion readiness."
    },
    "description": "Checks completion_path, milestones, and tasks for status updates. Marks completion milestones when conditions are met and logs alignment notes. Monitors roadmap alignment, marks progress milestones, and prevents premature completion marking.",
    "md_file_path": "directives/project_completion_check.md",
    "workflow": {
      "trunk": "check_progress",
      "branches": [
        {
          "if": "criteria_met",
          "then": "mark_done",
          "details": {
            "update_status": true
          }
        },
        {
          "if": "drift_detected",
          "then": "alert_user",
          "details": {
            "log_note": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Adjust roadmap or tasks?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "roadmap_drift",
        "resolution": "Prompt user to realign completion_path"
      },
      {
        "issue": "incomplete_tasks",
        "resolution": "Auto-mark pending subtasks or prompt user"
      }
    ],
    "intent_keywords_json": [
      "progress",
      "check completion",
      "roadmap"
    ],
    "confidence_threshold": 0.6
  },
  {
    "name": "project_error_handling",
    "type": "project",
    "level": 4,
    "parent_directive": null,
    "category": {
      "name": "error_handling",
      "description": "Handles directive failures, logging, and escalation to user."
    },
    "description": "Monitors directive execution for known or unknown failures, applies stored roadblock resolutions, and logs issues to the notes table for transparency. Provides universal error recovery handling for all project-level directives. Integrates with the notes table for traceability.",
    "md_file_path": "directives/project_error_handling.md",
    "workflow": {
      "trunk": "check_roadblocks",
      "branches": [
        {
          "if": "known_issue",
          "then": "apply_resolution",
          "details": {
            "log_note": true
          }
        },
        {
          "if": "unknown_issue",
          "then": "prompt_user",
          "details": {
            "escalate_to_md": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Resolve error manually?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "log_and_halt"
      }
    },
    "roadblocks_json": [
      {
        "issue": "generic_error",
        "resolution": "Prompt user and record in notes"
      },
      {
        "issue": "workflow_failure",
        "resolution": "Escalate to associated .md file for guidance"
      }
    ],
    "intent_keywords_json": [
      "error",
      "failure",
      "roadblock",
      "issue"
    ],
    "confidence_threshold": 0.5
  },
  {
    "name": "project_evolution",
    "type": "project",
    "level": 4,
    "parent_directive": "project_completion_check",
    "category": {
      "name": "evolution_tracking",
      "description": "Tracks changes to project idea, goals, purpose, and updates ProjectBlueprint.md accordingly."
    },
    "description": "Handles versioning and pivot tracking for evolving project goals. Updates ProjectBlueprint.md sections when project-wide changes occur (architecture, goals, themes, flows, infrastructure, completion path). Logs changes in notes and updates roadmap and completion paths accordingly. Captures and logs project pivots for transparency in long-running projects. Updates project.version and completion paths.",
    "md_file_path": "directives/project_evolution.md",
    "workflow": {
      "trunk": "detect_project_wide_change",
      "branches": [
        {
          "if": "architecture_change",
          "then": "update_blueprint_section_2",
          "details": {
            "section": "Technical Blueprint",
            "update_db": [
              "project.version",
              "infrastructure"
            ],
            "increment_version": true,
            "backup_blueprint": true
          }
        },
        {
          "if": "goals_change",
          "then": "update_blueprint_section_1",
          "details": {
            "section": "Project Overview",
            "update_db": [
              "project.goals_json",
              "project.version"
            ],
            "increment_version": true,
            "backup_blueprint": true
          }
        },
        {
          "if": "themes_or_flows_change",
          "then": "update_blueprint_section_3",
          "details": {
            "section": "Project Themes & Flows",
            "update_db": [
              "themes",
              "flows",
              "project.version"
            ],
            "increment_version": true,
            "backup_blueprint": true
          }
        },
        {
          "if": "completion_path_change",
          "then": "update_blueprint_section_4",
          "details": {
            "section": "Completion Path",
            "update_db": [
              "completion_path",
              "milestones",
              "project.version"
            ],
            "increment_version": true,
            "backup_blueprint": true
          }
        },
        {
          "if": "infrastructure_change",
          "then": "update_blueprint_section_2_infrastructure",
          "details": {
            "section": "Technical Blueprint - Key Infrastructure",
            "update_db": [
              "infrastructure",
              "project.version"
            ],
            "increment_version": true,
            "backup_blueprint": true
          }
        },
        {
          "if": "pivot_detected",
          "then": "increment_version",
          "details": {
            "update_goals": true,
            "update_blueprint_section_1": true
          }
        },
        {
          "if": "path_affected",
          "then": "update_completion_path",
          "details": {
            "log_note": true,
            "update_blueprint_section_4": true
          }
        },
        {
          "if": "blueprint_updated",
          "then": "add_evolution_history",
          "details": {
            "section": "Section 5: Evolution History",
            "log_change": true,
            "show_version": true
          }
        },
        {
          "parallel": [
            "backup_blueprint_to_aifp_backups",
            "log_evolution_to_notes"
          ],
          "details": {
            "backup_path": ".aifp-project/backups/",
            "note_type": "evolution",
            "source": "directive",
            "directive_name": "project_evolution"
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Confirm pivot or adjust roadmap?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "pivot_ambiguity",
        "resolution": "Prompt user for new purpose and goals"
      },
      {
        "issue": "version_conflict",
        "resolution": "Reconcile project version and completion_path entries"
      },
      {
        "issue": "blueprint_missing",
        "resolution": "Generate new ProjectBlueprint.md from current database state"
      },
      {
        "issue": "blueprint_update_failed",
        "resolution": "Backup current state and prompt user for manual update"
      }
    ],
    "intent_keywords_json": [
      "pivot",
      "evolve",
      "update goals",
      "project change",
      "change architecture",
      "update infrastructure"
    ],
    "confidence_threshold": 0.6
  },
  {
    "name": "project_user_referral",
    "type": "project",
    "level": 4,
    "parent_directive": "project_error_handling",
    "category": {
      "name": "error_handling",
      "description": "Delegates unresolved issues back to the user."
    },
    "description": "When confidence is low or a workflow fails, prompts the user for guidance and logs the clarification request to notes for review. Standard fallback directive for AIâ€“user collaboration. Ensures ambiguous operations always route through human confirmation.",
    "md_file_path": "directives/project_user_referral.md",
    "workflow": {
      "trunk": "check_confidence",
      "branches": [
        {
          "if": "low_confidence",
          "then": "prompt_user",
          "details": {
            "log_note": true
          }
        },
        {
          "if": "workflow_failure",
          "then": "escalate_to_md",
          "details": {
            "prompt_user": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Resolve or confirm intended action?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "log_and_halt"
      }
    },
    "roadblocks_json": [
      {
        "issue": "unresolved_issue",
        "resolution": "Prompt user and record clarification in notes"
      },
      {
        "issue": "low_confidence_path",
        "resolution": "Escalate to user confirmation"
      }
    ],
    "intent_keywords_json": [
      "clarify",
      "user input",
      "confirmation",
      "resolve"
    ],
    "confidence_threshold": 0.5
  },
  {
    "name": "project_theme_flow_mapping",
    "type": "project",
    "level": 3,
    "parent_directive": "project_file_write",
    "category": {
      "name": "theme_mapping",
      "description": "Links generated code elements to project themes and flows, triggers ProjectBlueprint.md updates."
    },
    "description": "Infers or assigns flow and theme groupings based on file metadata, updating linking tables for file_flows and flow_themes within project.db. Maintains thematic and procedural grouping across project files. Supports roadmap visualization and organization. Triggers project_evolution directive when themes or flows are added or modified to update ProjectBlueprint.md accordingly.",
    "md_file_path": "directives/project_theme_flow_mapping.md",
    "workflow": {
      "trunk": "infer_metadata",
      "branches": [
        {
          "if": "metadata_present",
          "then": "update_flow_themes",
          "details": {
            "confidence_score": true
          }
        },
        {
          "if": "no_metadata",
          "then": "prompt_user",
          "details": {
            "assign_default": true
          }
        },
        {
          "if": "theme_or_flow_updated",
          "then": "call_project_evolution",
          "details": {
            "change_type": "themes_or_flows_change",
            "trigger_blueprint_update": true,
            "update_section": 3
          }
        },
        {
          "if": "new_theme_created",
          "then": "call_project_evolution",
          "details": {
            "change_type": "themes_or_flows_change",
            "trigger_blueprint_update": true
          }
        },
        {
          "if": "new_flow_created",
          "then": "call_project_evolution",
          "details": {
            "change_type": "themes_or_flows_change",
            "trigger_blueprint_update": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Assign theme and flow manually?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "ambiguous_mapping",
        "resolution": "Prompt user to specify theme or flow"
      },
      {
        "issue": "missing_metadata",
        "resolution": "Parse file for AIFP_METADATA or prompt user"
      },
      {
        "issue": "blueprint_update_failed",
        "resolution": "Continue with DB update but log warning about blueprint sync"
      }
    ],
    "intent_keywords_json": [
      "theme",
      "flow",
      "grouping",
      "categorize"
    ],
    "confidence_threshold": 0.5
  },
  {
    "name": "project_metrics",
    "type": "project",
    "level": 4,
    "parent_directive": "project_completion_check",
    "category": {
      "name": "metrics",
      "description": "Tracks quantitative and qualitative project progress metrics."
    },
    "description": "Calculates project completion percentage, directive success rates, and task distribution to inform AI reasoning and user summaries. Provides periodic project health reports for both AI and user reference. Logged in notes for transparency.",
    "md_file_path": "directives/project_metrics.md",
    "workflow": {
      "trunk": "gather_metrics",
      "branches": [
        {
          "if": "completion_path_available",
          "then": "compute_progress",
          "details": {
            "aggregate": true
          }
        },
        {
          "if": "function_table_updated",
          "then": "calculate_compliance_score",
          "details": {
            "fp_links": true
          }
        },
        {
          "fallback": "log_metrics_to_notes"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "missing_task_data",
        "resolution": "Requery project.db and retry"
      },
      {
        "issue": "stale_metrics",
        "resolution": "Recalculate from base tables"
      }
    ],
    "intent_keywords_json": [
      "progress",
      "metrics",
      "statistics"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_performance_summary",
    "type": "project",
    "level": 4,
    "parent_directive": "project_metrics",
    "category": {
      "name": "metrics",
      "description": "Generates a summary of recent directive and workflow performance."
    },
    "description": "Summarizes recent directive outcomes, including successes, retries, and failures, and stores summaries in notes for audit. Keeps a rolling summary of directive performance for reliability tracking.",
    "md_file_path": "directives/project_performance_summary.md",
    "workflow": {
      "trunk": "summarize_recent_runs",
      "branches": [
        {
          "if": "error_logs_present",
          "then": "analyze_failures"
        },
        {
          "if": "recent_successes",
          "then": "record_success_rate"
        },
        {
          "fallback": "write_summary_to_notes"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "missing_logs",
        "resolution": "Query notes table for directive references"
      }
    ],
    "intent_keywords_json": [
      "summary",
      "audit",
      "performance"
    ],
    "confidence_threshold": 0.6
  },
  {
    "name": "project_dependency_sync",
    "type": "project",
    "level": 3,
    "parent_directive": "project_update_db",
    "category": {
      "name": "dependency_management",
      "description": "Reconciles mismatched dependencies between code and project.db."
    },
    "description": "Compares functions and flows in files against database records, resolving missing or outdated dependencies. Maintains consistency between the physical codebase and project metadata.",
    "md_file_path": "directives/project_dependency_sync.md",
    "workflow": {
      "trunk": "compare_db_and_files",
      "branches": [
        {
          "if": "missing_function_in_db",
          "then": "insert_function_entry"
        },
        {
          "if": "db_function_stale",
          "then": "update_dependency_entry"
        },
        {
          "if": "unlinked_file",
          "then": "link_to_flow"
        },
        {
          "fallback": "log_sync_status"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "unresolved_dependency",
        "resolution": "Prompt user to confirm update direction"
      }
    ],
    "intent_keywords_json": [
      "dependency",
      "sync",
      "link"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_integrity_check",
    "type": "project",
    "level": 4,
    "parent_directive": "project_dependency_sync",
    "category": {
      "name": "dependency_management",
      "description": "Performs integrity verification on project.db."
    },
    "description": "Runs validation queries to detect orphaned records, missing links, and checksum mismatches within project.db. Ensures internal DB consistency, preventing corruption during iterative project growth.",
    "md_file_path": "directives/project_integrity_check.md",
    "workflow": {
      "trunk": "run_integrity_queries",
      "branches": [
        {
          "if": "missing_foreign_key",
          "then": "repair_link"
        },
        {
          "if": "checksum_error",
          "then": "recalculate_file_checksum"
        },
        {
          "fallback": "log_integrity_status"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "data_misalignment",
        "resolution": "Auto-correct links where safe"
      }
    ],
    "intent_keywords_json": [
      "integrity",
      "verify database",
      "consistency"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_auto_resume",
    "type": "project",
    "level": 3,
    "parent_directive": "aifp_run",
    "category": {
      "name": "recovery_automation",
      "description": "Automatically resumes interrupted tasks or workflows."
    },
    "description": "Detects unfinished tasks or subtasks from project.db and resumes execution at the appropriate directive entry point. Restores workflow continuity between user sessions or interruptions.",
    "md_file_path": "directives/project_auto_resume.md",
    "workflow": {
      "trunk": "detect_incomplete_tasks",
      "branches": [
        {
          "if": "task_paused",
          "then": "resume_from_checkpoint"
        },
        {
          "if": "sidequest_paused",
          "then": "prompt_resume"
        },
        {
          "fallback": "mark_as_resolved"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "resume_conflict",
        "resolution": "Prompt user to choose branch or discard task"
      }
    ],
    "intent_keywords_json": [
      "resume",
      "continue",
      "checkpoint"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_backup_restore",
    "type": "project",
    "level": 4,
    "parent_directive": "project_integrity_check",
    "category": {
      "name": "recovery_automation",
      "description": "Manages project database and file backups."
    },
    "description": "Creates periodic backups of project.db and associated files, and restores them on demand or after failure detection. Protects project state from corruption or user error. Integrates with integrity check for recovery decisions.",
    "md_file_path": "directives/project_backup_restore.md",
    "workflow": {
      "trunk": "perform_backup",
      "branches": [
        {
          "if": "scheduled_backup_time",
          "then": "execute_backup"
        },
        {
          "if": "restore_requested",
          "then": "load_backup"
        },
        {
          "fallback": "log_backup_status"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "backup_failure",
        "resolution": "Prompt user to retry or restore manually"
      }
    ],
    "intent_keywords_json": [
      "backup",
      "restore",
      "recovery"
    ],
    "confidence_threshold": 0.6
  },
  {
    "name": "project_archive",
    "type": "project",
    "level": 4,
    "parent_directive": "project_completion_check",
    "category": {
      "name": "archival_refactor",
      "description": "Archives completed projects for long-term storage."
    },
    "description": "Packages the final project.db, all files, and completion reports into an archive format and marks project status as 'archived'. Preserves completed project versions and prepares exportable deliverables.",
    "md_file_path": "directives/project_archive.md",
    "workflow": {
      "trunk": "prepare_archive",
      "branches": [
        {
          "if": "project_completed",
          "then": "compress_and_store"
        },
        {
          "if": "incomplete_milestones",
          "then": "prompt_user_to_finalize"
        },
        {
          "fallback": "log_archive_status"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "archive_incomplete",
        "resolution": "Prompt user for approval before packaging"
      }
    ],
    "intent_keywords_json": [
      "archive",
      "package",
      "finalize"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_refactor_path",
    "type": "project",
    "level": 3,
    "parent_directive": "project_evolution",
    "category": {
      "name": "archival_refactor",
      "description": "Refactors roadmap paths and milestones."
    },
    "description": "Allows restructuring of completion_path sequences for clarity, merging or reordering tasks while maintaining linkage integrity. Provides roadmap reorganization utilities for evolving projects.",
    "md_file_path": "directives/project_refactor_path.md",
    "workflow": {
      "trunk": "analyze_completion_path",
      "branches": [
        {
          "if": "duplicate_milestone",
          "then": "merge_entries"
        },
        {
          "if": "order_misaligned",
          "then": "reorder_path"
        },
        {
          "fallback": "log_changes"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "path_conflict",
        "resolution": "Prompt user for reorder approval"
      }
    ],
    "intent_keywords_json": [
      "refactor path",
      "reorder roadmap"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_dependency_map",
    "type": "project",
    "level": 3,
    "parent_directive": "project_dependency_sync",
    "category": {
      "name": "dependency_management",
      "description": "Generates visual dependency maps across project entities."
    },
    "description": "Queries relationships between files, functions, flows, and tasks to produce a dependency graph for reasoning or visualization. Improves transparency and traceability across project elements for AIFP reasoning.",
    "md_file_path": "directives/project_dependency_map.md",
    "workflow": {
      "trunk": "generate_dependency_graph",
      "branches": [
        {
          "if": "linked_entities_found",
          "then": "store_dependency_map"
        },
        {
          "fallback": "log_dependency_status"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "missing_links",
        "resolution": "Rebuild function-to-task relationships"
      }
    ],
    "intent_keywords_json": [
      "dependency map",
      "graph",
      "visualize"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_auto_summary",
    "type": "project",
    "level": 4,
    "parent_directive": "project_metrics",
    "category": {
      "name": "metrics",
      "description": "Automatically summarizes project status and context."
    },
    "description": "Generates a human-readable summary of project purpose, progress, and open tasks. Stores summary in notes table with note_type='auto_summary' for future reference and outputs to terminal. Provides quick, automated overviews of project state for both AI and user consumption.",
    "md_file_path": "directives/project_auto_summary.md",
    "workflow": {
      "trunk": "summarize_project_state",
      "branches": [
        {
          "if": "active_tasks_found",
          "then": "summarize_by_path"
        },
        {
          "if": "completed_milestones",
          "then": "log_completion_summary"
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Include additional context?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "summary_generation_failed",
        "resolution": "Retry summary or prompt user for context"
      }
    ],
    "intent_keywords_json": [
      "summary",
      "status",
      "report"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "aifp_status",
    "type": "project",
    "level": 1,
    "parent_directive": "aifp_run",
    "category": {
      "name": "status_management",
      "description": "Retrieves comprehensive project status with context-aware task continuation support."
    },
    "description": "Retrieves comprehensive project status with historical context for task continuation. For existing projects: reads ProjectBlueprint.md, loads infrastructure, builds priority status tree (sidequests â†’ subtasks â†’ tasks), provides historical context from previous tasks, checks for ambiguities, and generates status report. For new projects: checks for .aifp/ folder, checks .git/.aifp/ backup, prompts for restoration or initialization.",
    "md_file_path": "directives/aifp_status.md",
    "workflow": {
      "trunk": "determine_project_state",
      "branches": [
        {
          "if": "aifp_folder_exists",
          "then": "sync_git_state_on_boot",
          "details": {
            "trigger": "git_sync_state directive",
            "action": "Detect external changes and sync Git hash"
          }
        },
        {
          "if": "git_synced",
          "then": "get_existing_project_status",
          "details": {}
        },
        {
          "if": "no_aifp_folder",
          "then": "check_git_aifp_backup",
          "details": {
            "check_path": ".git/.aifp/ProjectBlueprint.md"
          }
        },
        {
          "if": "git_backup_found",
          "then": "prompt_restore_or_init",
          "details": {
            "options": [
              "restore",
              "init_new",
              "exit"
            ]
          }
        },
        {
          "if": "no_backups",
          "then": "prompt_init_new_project",
          "details": {
            "suggest_project_init": true
          }
        },
        {
          "if": "existing_project",
          "then": "read_project_blueprint",
          "details": {
            "path": ".aifp-project/ProjectBlueprint.md"
          }
        },
        {
          "if": "blueprint_read",
          "then": "load_infrastructure_context",
          "details": {
            "query": "SELECT type, value, description FROM infrastructure WHERE project_id = ?"
          }
        },
        {
          "if": "infrastructure_loaded",
          "then": "check_user_directives_status",
          "details": {
            "query": "SELECT user_directives_status FROM project WHERE id = ?",
            "include_in_report": true
          }
        },
        {
          "if": "user_directives_active",
          "then": "query_user_directive_stats",
          "details": {
            "count_active": true,
            "get_last_execution": true,
            "get_error_count": true
          }
        },
        {
          "if": "user_directive_stats_gathered",
          "then": "build_priority_status_tree",
          "details": {
            "priority_order": [
              "sidequests",
              "subtasks",
              "tasks"
            ],
            "context_limit": 10
          }
        },
        {
          "if": "open_sidequests_found",
          "then": "get_sidequest_context",
          "details": {
            "get_parent_task": true,
            "get_all_items": true,
            "get_previous_task_if_no_completed": true,
            "previous_task_item_limit": 10
          }
        },
        {
          "if": "no_sidequests_open_subtasks",
          "then": "get_subtask_context",
          "details": {
            "get_parent_task": true,
            "get_all_items": true,
            "get_previous_task_if_no_completed": true,
            "previous_task_item_limit": 10
          }
        },
        {
          "if": "no_subtasks_open_tasks",
          "then": "get_task_context",
          "details": {
            "get_all_items": true,
            "evaluate_completed_vs_incomplete": true,
            "order_incomplete": true
          }
        },
        {
          "if": "context_gathered",
          "then": "check_for_ambiguities",
          "details": {
            "query_notes": true,
            "filter_severity": [
              "warning",
              "error"
            ],
            "filter_source": [
              "directive",
              "ai"
            ],
            "limit": 5
          }
        },
        {
          "if": "auto_run_mode",
          "then": "auto_browse_for_context",
          "details": {
            "browse_flows": true,
            "browse_functions": true,
            "browse_notes": true
          }
        },
        {
          "if": "status_complete",
          "then": "generate_status_report",
          "details": {
            "sections": [
              "current_focus",
              "open_items",
              "recently_completed",
              "historical_context",
              "ambiguities",
              "next_actions"
            ]
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Unable to determine project state"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "blueprint_missing",
        "resolution": "Attempt to load from database, generate new blueprint if needed"
      },
      {
        "issue": "no_open_work_items",
        "resolution": "Report project as idle, suggest next milestone or task creation"
      },
      {
        "issue": "database_empty",
        "resolution": "Inform user project initialized but no tasks created yet"
      },
      {
        "issue": "ambiguity_detected",
        "resolution": "Present ambiguities to user and offer to browse DB for more context"
      }
    ],
    "intent_keywords_json": [
      "status",
      "continue",
      "resume",
      "what's next",
      "show status",
      "project status",
      "where were we"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_blueprint_read",
    "type": "project",
    "level": 2,
    "parent_directive": "aifp_status",
    "category": {
      "name": "blueprint_management",
      "description": "Standard helper for reading and parsing ProjectBlueprint.md."
    },
    "description": "Reads and parses ProjectBlueprint.md into structured data. Returns project metadata (name, version, status, goals), technical blueprint (language, runtime, architecture), themes, flows, and completion path. Falls back to database if blueprint file missing.",
    "md_file_path": "directives/project_blueprint_read.md",
    "workflow": {
      "trunk": "read_blueprint_file",
      "branches": [
        {
          "if": "blueprint_exists",
          "then": "parse_markdown_sections",
          "details": {
            "sections": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "return_structured_data": true
          }
        },
        {
          "if": "blueprint_missing",
          "then": "check_database_fallback",
          "details": {
            "query_project_table": true,
            "query_infrastructure": true,
            "query_themes": true,
            "query_flows": true
          }
        },
        {
          "if": "database_fallback_success",
          "then": "return_db_data",
          "details": {
            "warn_user": "Blueprint missing, using database data"
          }
        },
        {
          "if": "parse_complete",
          "then": "return_structured_data",
          "details": {
            "return_structured_data": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Blueprint not found and database empty"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "blueprint_corrupted",
        "resolution": "Attempt to parse sections individually, use database fallback for missing sections"
      },
      {
        "issue": "markdown_parse_error",
        "resolution": "Use database data and offer to regenerate blueprint"
      },
      {
        "issue": "checksum_mismatch",
        "resolution": "Warn user about potential blueprint/DB desync"
      }
    ],
    "intent_keywords_json": [
      "read blueprint",
      "load blueprint",
      "parse blueprint"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_blueprint_update",
    "type": "project",
    "level": 2,
    "parent_directive": "project_evolution",
    "category": {
      "name": "blueprint_management",
      "description": "Standard helper for updating specific sections of ProjectBlueprint.md."
    },
    "description": "Updates specific section of ProjectBlueprint.md with new content. Backs up current blueprint before modification, replaces section content, optionally increments version and adds evolution history entry. Used by project_evolution and other directives when project-wide changes occur.",
    "md_file_path": "directives/project_blueprint_update.md",
    "workflow": {
      "trunk": "validate_parameters",
      "branches": [
        {
          "if": "parameters_valid",
          "then": "read_current_blueprint",
          "details": {}
        },
        {
          "if": "blueprint_read",
          "then": "backup_current_blueprint",
          "details": {
            "backup_to": ".aifp-project/backups/ProjectBlueprint.md.v{version}",
            "include_timestamp": true
          }
        },
        {
          "if": "backup_complete",
          "then": "replace_section_content",
          "details": {
            "section_number": "from_params",
            "new_content": "from_params"
          }
        },
        {
          "if": "increment_version_requested",
          "then": "update_version_and_date",
          "details": {
            "increment_project_version_in_db": true,
            "update_last_updated_date": true
          }
        },
        {
          "if": "version_incremented",
          "then": "add_evolution_history_entry",
          "details": {
            "section": 5,
            "log_change": true,
            "show_version": true,
            "show_date": true
          }
        },
        {
          "if": "section_replaced",
          "then": "write_updated_blueprint",
          "details": {
            "path": ".aifp-project/ProjectBlueprint.md"
          }
        },
        {
          "if": "write_complete",
          "then": "return_success",
          "details": {
            "show_new_version": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Blueprint update failed"
          }
        }
      ],
      "error_handling": {
        "on_failure": "restore_from_backup",
        "prompt_user": true
      }
    },
    "roadblocks_json": [
      {
        "issue": "section_not_found",
        "resolution": "Warn user and append new section to blueprint"
      },
      {
        "issue": "backup_failed",
        "resolution": "Abort update and prompt user"
      },
      {
        "issue": "write_failed",
        "resolution": "Restore from backup and prompt user"
      },
      {
        "issue": "version_conflict",
        "resolution": "Prompt user to resolve version manually"
      }
    ],
    "intent_keywords_json": [
      "update blueprint",
      "modify blueprint",
      "change blueprint section"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_file_read",
    "type": "project",
    "level": 3,
    "parent_directive": "project_file_write",
    "category": {
      "name": "file_operations",
      "description": "Context-aware file reading with database metadata"
    },
    "description": "Intelligent file reader that provides file content with full database context including metadata, functions, dependencies, theme/flow associations, and checksum verification. Detects if file changed since last DB update.",
    "md_file_path": "directives/project_file_read.md",
    "workflow": {
      "trunk": "validate_file_path",
      "branches": [
        {
          "if": "file_exists_in_db",
          "then": "load_with_context"
        },
        {
          "if": "file_not_in_db_but_exists",
          "then": "load_without_context"
        },
        {
          "if": "checksum_mismatch",
          "then": "warn_file_changed"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "file_not_found",
        "resolution": "Verify path and prompt user"
      },
      {
        "issue": "file_not_tracked",
        "resolution": "Suggest running project_file_write"
      }
    ],
    "intent_keywords_json": [
      "read file",
      "load file",
      "file context"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_file_delete",
    "type": "project",
    "level": 3,
    "parent_directive": "project_file_write",
    "category": {
      "name": "file_operations",
      "description": "Safe file deletion with database cleanup"
    },
    "description": "Safe file remover that ensures filesystem and database consistency. Uses ERROR-first approach: delete_file() returns error if dependencies exist (functions, types, file_flows). AI must systematically delete functions (which checks types_functions), remove file_flows entries, then retry file deletion. No automatic cascading - forces intentional cleanup to prevent accidental data loss.",
    "md_file_path": "directives/project_file_delete.md",
    "workflow": {
      "trunk": "validate_delete_request",
      "branches": [
        {
          "if": "file_tracked_in_db",
          "then": "call_delete_file_helper"
        },
        {
          "if": "delete_file_returns_error",
          "then": "dependencies_exist_cleanup_loop",
          "details": {
            "error_structure": "{success: false, error: 'dependencies_exist', functions: [...], types: [...], file_flows: [...]}",
            "cleanup_steps": [
              "1. For each function: call delete_function() - may error if types_functions exist",
              "2. If delete_function errors: unlink types_functions entries first, then retry",
              "3. Remove file_flows entries manually",
              "4. Retry delete_file() - should now succeed"
            ]
          }
        },
        {
          "if": "delete_file_success",
          "then": "remove_from_filesystem"
        },
        {
          "fallback": "prompt_user_for_clarification"
        }
      ],
      "error_handling": {
        "on_failure": "return_error_with_dependency_details"
      }
    },
    "roadblocks_json": [
      {
        "issue": "dependencies_exist",
        "resolution": "Systematically delete functions, unlink types_functions, remove file_flows, then retry"
      },
      {
        "issue": "types_functions_exist_when_deleting_function",
        "resolution": "Unlink types_functions entries before deleting function"
      }
    ],
    "intent_keywords_json": [
      "delete file",
      "remove file",
      "file cleanup"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_task_create",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_decomposition",
    "category": {
      "name": "task_management",
      "description": "Atomic task creation"
    },
    "description": "Atomic task constructor for creating new independent tasks. Links to milestone, sets initial status, assigns priority, validates inputs, and returns task ID for immediate use.",
    "md_file_path": "directives/project_task_create.md",
    "workflow": {
      "trunk": "validate_inputs",
      "branches": [
        {
          "if": "inputs_valid",
          "then": "check_milestone_exists"
        },
        {
          "if": "milestone_valid",
          "then": "check_duplicate_tasks"
        },
        {
          "if": "no_duplicates_or_confirmed",
          "then": "create_task_record"
        },
        {
          "if": "task_created",
          "then": "return_task_id"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "duplicate_task",
        "resolution": "Prompt user to confirm or rename"
      },
      {
        "issue": "invalid_milestone",
        "resolution": "Prompt user to select valid milestone"
      }
    ],
    "intent_keywords_json": [
      "create task",
      "new task",
      "add task"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_task_update",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_decomposition",
    "category": {
      "name": "task_management",
      "description": "Task lifecycle state management"
    },
    "description": "Central task state manager for updating status, priority, and metadata. Delegates completion workflows to specialized completion directives. Maintains roadmap integrity and triggers downstream actions.",
    "md_file_path": "directives/project_task_update.md",
    "workflow": {
      "trunk": "identify_update_type",
      "branches": [
        {
          "if": "status_update_requested",
          "then": "update_task_status",
          "details": {
            "validate_transition": true,
            "update_timestamp": true
          }
        },
        {
          "if": "task_status_changed_to_completed",
          "then": "delegate_to_project_task_complete",
          "details": {
            "delegate_to": "project_task_complete",
            "pass_task_id": true,
            "pass_milestone_id": true
          }
        },
        {
          "if": "subtask_status_changed_to_completed",
          "then": "delegate_to_project_subtask_complete",
          "details": {
            "delegate_to": "project_subtask_complete",
            "pass_subtask_id": true,
            "pass_parent_task_id": true
          }
        },
        {
          "if": "sidequest_status_changed_to_completed",
          "then": "delegate_to_project_sidequest_complete",
          "details": {
            "delegate_to": "project_sidequest_complete",
            "pass_sidequest_id": true,
            "pass_paused_task_id": true
          }
        },
        {
          "if": "priority_update_requested",
          "then": "update_task_priority",
          "details": {
            "validate_priority": true,
            "log_change": true
          }
        },
        {
          "if": "description_update_requested",
          "then": "update_description",
          "details": {
            "log_change": true
          }
        },
        {
          "if": "task_cancelled",
          "then": "cancel_task",
          "details": {
            "mark_items_cancelled": true,
            "log_reason": true,
            "do_not_resume_parent": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "What aspect of the task needs updating?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user",
        "retry": "max 1 attempt"
      }
    },
    "roadblocks_json": [
      {
        "issue": "invalid_state_transition",
        "resolution": "Warn user about valid transitions"
      },
      {
        "issue": "completed_task_reopened",
        "resolution": "Block reopening completed tasks"
      }
    ],
    "intent_keywords_json": [
      "update task",
      "mark complete",
      "change status",
      "task priority"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_subtask_create",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_decomposition",
    "category": {
      "name": "task_management",
      "description": "Atomic subtask creation with parent management"
    },
    "description": "Atomic subtask constructor that creates focused, high-priority subtasks and automatically pauses parent tasks until completion. Subtasks are immediate-focus work that blocks parent task progress.",
    "md_file_path": "directives/project_subtask_create.md",
    "workflow": {
      "trunk": "validate_inputs",
      "branches": [
        {
          "if": "inputs_valid",
          "then": "check_parent_task_exists"
        },
        {
          "if": "parent_task_valid",
          "then": "check_active_subtasks"
        },
        {
          "if": "no_blocking_subtasks_or_confirmed",
          "then": "create_subtask_record"
        },
        {
          "if": "subtask_created",
          "then": "pause_parent_task"
        },
        {
          "if": "parent_paused",
          "then": "return_subtask_id"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "parent_task_completed",
        "resolution": "Cannot create subtask for completed task"
      },
      {
        "issue": "multiple_active_subtasks",
        "resolution": "Warn about context switching"
      }
    ],
    "intent_keywords_json": [
      "create subtask",
      "new subtask",
      "refine task"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_item_create",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_decomposition",
    "category": {
      "name": "task_management",
      "description": "Atomic item creation for granular tracking"
    },
    "description": "Atomic item constructor for creating smallest work units within tasks. Links to parent task, supports optional file/function references, and enables fine-grained progress tracking.",
    "md_file_path": "directives/project_item_create.md",
    "workflow": {
      "trunk": "validate_inputs",
      "branches": [
        {
          "if": "inputs_valid",
          "then": "check_parent_task_exists"
        },
        {
          "if": "parent_task_valid",
          "then": "check_duplicate_items"
        },
        {
          "if": "no_duplicates_or_confirmed",
          "then": "create_item_record"
        },
        {
          "if": "item_created",
          "then": "return_item_id"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "parent_task_completed",
        "resolution": "Cannot add items to completed task"
      },
      {
        "issue": "duplicate_item",
        "resolution": "Prompt user to confirm"
      }
    ],
    "intent_keywords_json": [
      "create item",
      "new item",
      "add checklist"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_sidequest_create",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_decomposition",
    "category": {
      "name": "task_management",
      "description": "Exploratory work tracking"
    },
    "description": "Atomic sidequest constructor for creating exploratory interruptions. Handles fixes, pivots, or unrelated work that pauses tasks. Default low priority for exploratory work outside main roadmap.",
    "md_file_path": "directives/project_sidequest_create.md",
    "workflow": {
      "trunk": "validate_inputs",
      "branches": [
        {
          "if": "linked_to_task",
          "then": "create_with_task_link"
        },
        {
          "if": "exploratory_work",
          "then": "create_standalone"
        },
        {
          "if": "bug_fix",
          "then": "create_fix_sidequest"
        },
        {
          "if": "pivot_exploration",
          "then": "create_pivot_sidequest"
        },
        {
          "fallback": "prompt_user"
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user"
      }
    },
    "roadblocks_json": [
      {
        "issue": "too_many_sidequests",
        "resolution": "Warn about focus fragmentation"
      },
      {
        "issue": "sidequest_should_be_task",
        "resolution": "Suggest creating task instead"
      }
    ],
    "intent_keywords_json": [
      "create sidequest",
      "exploratory work",
      "bug fix",
      "interruption"
    ],
    "confidence_threshold": 0.7
  },
  {
    "name": "project_task_complete",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_update",
    "category": {
      "name": "task_management",
      "description": "Post-task completion workflow and next-step planning"
    },
    "description": "Handles post-task completion workflow: marks task and items complete, checks milestone progress, reviews completion_path, and engages user to plan next task. Ensures continuous forward progress by automatically reviewing roadmap status after each task completion.",
    "md_file_path": "directives/project_task_complete.md",
    "workflow": {
      "trunk": "mark_task_complete",
      "branches": [
        {
          "if": "task_valid_for_completion",
          "then": "mark_complete_and_items",
          "details": {
            "update_task_status": "completed",
            "mark_all_items_complete": true,
            "log_completion_time": true
          }
        },
        {
          "if": "task_completed",
          "then": "check_milestone_status",
          "details": {
            "query": "SELECT COUNT(*) FROM tasks WHERE milestone_id = ? AND status NOT IN ('completed', 'cancelled')",
            "check_all_tasks_complete": true
          }
        },
        {
          "if": "milestone_complete",
          "then": "call_project_milestone_complete",
          "details": {
            "delegate_to": "project_milestone_complete",
            "pass_milestone_id": true
          }
        },
        {
          "if": "milestone_not_complete",
          "then": "review_next_steps",
          "details": {
            "call_aifp_status": true,
            "brief": true,
            "show_completion_path_progress": true,
            "show_milestone_progress": true,
            "query_pending_tasks": "SELECT id, name, description FROM tasks WHERE milestone_id = ? AND status = 'pending' ORDER BY priority DESC LIMIT 5",
            "discuss_with_user": true,
            "prompt_template": "Task '[task_name]' completed successfully! Milestone '[milestone_name]' progress: [X/Y tasks complete]. Next steps?",
            "offer_options": [
              "Continue with next task",
              "Create new task",
              "Pivot to different milestone",
              "Review completion path"
            ]
          }
        },
        {
          "if": "user_chooses_next_task",
          "then": "set_next_task_in_progress",
          "details": {
            "update_task_status": "in_progress"
          }
        },
        {
          "if": "user_chooses_create_task",
          "then": "call_project_task_create",
          "details": {
            "delegate_to": "project_task_create",
            "auto_create_items": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "What would you like to work on next?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user",
        "retry": "max 1 attempt"
      }
    },
    "roadblocks_json": [
      {
        "issue": "active_subtasks_blocking",
        "resolution": "Cannot complete task with active subtasks - complete or cancel them first"
      },
      {
        "issue": "no_pending_tasks",
        "resolution": "Offer to create new task or move to next milestone"
      },
      {
        "issue": "user_unavailable",
        "resolution": "Log completion and defer next-step planning to next session"
      }
    ],
    "intent_keywords_json": [
      "complete task",
      "finish task",
      "task done",
      "mark complete"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_subtask_complete",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_update",
    "category": {
      "name": "task_management",
      "description": "Post-subtask completion workflow and parent resumption"
    },
    "description": "Handles post-subtask completion workflow: marks subtask complete, checks all subtasks for parent task, resumes parent task when all subtasks complete. Ensures parent task automatically resumes when blocking subtasks are finished.",
    "md_file_path": "directives/project_subtask_complete.md",
    "workflow": {
      "trunk": "mark_subtask_complete",
      "branches": [
        {
          "if": "subtask_valid_for_completion",
          "then": "mark_complete",
          "details": {
            "update_subtask_status": "completed",
            "log_completion_time": true
          }
        },
        {
          "if": "subtask_completed",
          "then": "check_parent_subtasks",
          "details": {
            "query": "SELECT COUNT(*) FROM subtasks WHERE parent_task_id = ? AND status NOT IN ('completed', 'cancelled')",
            "check_all_subtasks_complete": true
          }
        },
        {
          "if": "all_subtasks_complete",
          "then": "resume_parent_task",
          "details": {
            "update_parent_status": "in_progress",
            "log_resume": true,
            "notify_user": "All subtasks complete for task '[parent_task_name]'. Parent task resumed.",
            "call_aifp_status": true,
            "brief": true
          }
        },
        {
          "if": "subtasks_remaining",
          "then": "notify_remaining_work",
          "details": {
            "query": "SELECT id, name FROM subtasks WHERE parent_task_id = ? AND status = 'pending' ORDER BY priority DESC",
            "show_remaining_subtasks": true,
            "prompt_user": "Subtask '[subtask_name]' complete. [X] subtasks remaining for parent task."
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Subtask completion issue - manual intervention needed"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user",
        "retry": "max 1 attempt"
      }
    },
    "roadblocks_json": [
      {
        "issue": "parent_task_not_paused",
        "resolution": "Log warning - parent should be paused when subtasks exist"
      },
      {
        "issue": "parent_task_completed",
        "resolution": "Cannot resume completed parent - this is a data integrity issue"
      }
    ],
    "intent_keywords_json": [
      "complete subtask",
      "finish subtask",
      "subtask done",
      "resume parent"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_sidequest_complete",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_update",
    "category": {
      "name": "task_management",
      "description": "Post-sidequest completion workflow and work resumption"
    },
    "description": "Handles post-sidequest completion workflow: marks sidequest complete, logs outcome and lessons learned, optionally resumes paused task. Captures exploratory work results for future reference.",
    "md_file_path": "directives/project_sidequest_complete.md",
    "workflow": {
      "trunk": "mark_sidequest_complete",
      "branches": [
        {
          "if": "sidequest_valid_for_completion",
          "then": "mark_complete_and_log",
          "details": {
            "update_sidequest_status": "completed",
            "log_completion_time": true,
            "prompt_for_outcome": true
          }
        },
        {
          "if": "sidequest_completed",
          "then": "capture_lessons_learned",
          "details": {
            "prompt_user": "What did you learn from this sidequest?",
            "log_to_notes": true,
            "note_type": "task_context",
            "reference_table": "sidequests",
            "source": "user",
            "directive_name": "project_sidequest_complete"
          }
        },
        {
          "if": "linked_to_paused_task",
          "then": "prompt_resume_work",
          "details": {
            "query": "SELECT task_id FROM sidequests WHERE id = ?",
            "notify_user": "Sidequest '[sidequest_name]' complete. Resume paused task '[task_name]'?",
            "offer_options": [
              "Resume paused task",
              "Continue with different work",
              "Create new task based on sidequest findings"
            ]
          }
        },
        {
          "if": "user_chooses_resume",
          "then": "resume_paused_task",
          "details": {
            "update_task_status": "in_progress",
            "log_resume": true
          }
        },
        {
          "if": "sidequest_revealed_new_work",
          "then": "offer_task_creation",
          "details": {
            "prompt_user": "Should we create a new task based on sidequest findings?",
            "delegate_to": "project_task_create"
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Sidequest complete - what's next?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user",
        "retry": "max 1 attempt"
      }
    },
    "roadblocks_json": [
      {
        "issue": "sidequest_reveals_pivot",
        "resolution": "Capture findings in notes, discuss with user if project direction should change"
      },
      {
        "issue": "paused_task_no_longer_relevant",
        "resolution": "Offer to cancel paused task instead of resuming"
      }
    ],
    "intent_keywords_json": [
      "complete sidequest",
      "finish sidequest",
      "sidequest done",
      "exploratory work done"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "project_milestone_complete",
    "type": "project",
    "level": 3,
    "parent_directive": "project_task_complete",
    "category": {
      "name": "task_management",
      "description": "Post-milestone completion workflow and next-milestone planning"
    },
    "description": "Handles post-milestone completion workflow: marks milestone complete, updates completion_path progress, reviews overall project status, moves to next milestone, and creates first task. Ensures continuous project momentum by automatically planning next phase.",
    "md_file_path": "directives/project_milestone_complete.md",
    "workflow": {
      "trunk": "mark_milestone_complete",
      "branches": [
        {
          "if": "milestone_valid_for_completion",
          "then": "mark_complete_and_update_path",
          "details": {
            "update_milestone_status": "completed",
            "log_completion_time": true,
            "query_completion_path": "SELECT id, status FROM completion_path WHERE id = (SELECT completion_path_id FROM milestones WHERE id = ?)",
            "check_path_completion": true
          }
        },
        {
          "if": "completion_path_complete",
          "then": "mark_path_complete",
          "details": {
            "update_completion_path_status": "completed",
            "log_path_completion": true
          }
        },
        {
          "if": "completion_path_complete",
          "then": "check_project_completion",
          "details": {
            "query": "SELECT COUNT(*) FROM completion_path WHERE project_id = ? AND status NOT IN ('completed')",
            "check_all_paths_complete": true
          }
        },
        {
          "if": "project_complete",
          "then": "call_project_completion_check",
          "details": {
            "delegate_to": "project_completion_check",
            "trigger_final_review": true
          }
        },
        {
          "if": "project_not_complete",
          "then": "move_to_next_milestone",
          "details": {
            "call_aifp_status": true,
            "brief": true,
            "show_completion_path_progress": true,
            "query_next_milestone": "SELECT m.id, m.name, m.description FROM milestones m JOIN completion_path cp ON m.completion_path_id = cp.id WHERE cp.project_id = ? AND m.status = 'pending' ORDER BY cp.order_index, m.id LIMIT 1",
            "prompt_template": "Milestone '[milestone_name]' completed! Project progress: [X/Y completion paths complete]. Moving to next milestone: '[next_milestone_name]'."
          }
        },
        {
          "if": "next_milestone_identified",
          "then": "discuss_first_task",
          "details": {
            "discuss_with_user": true,
            "prompt_user": "Next milestone: '[milestone_name]'. What should be the first task?",
            "offer_options": [
              "Let AI suggest first task based on milestone description",
              "User defines first task",
              "Review milestone details before deciding"
            ]
          }
        },
        {
          "if": "user_chooses_ai_suggestion",
          "then": "suggest_and_create_task",
          "details": {
            "analyze_milestone_description": true,
            "suggest_task_name": true,
            "suggest_task_items": true,
            "prompt_user_approval": true,
            "delegate_to": "project_task_create"
          }
        },
        {
          "if": "user_defines_task",
          "then": "create_user_defined_task",
          "details": {
            "prompt_for_task_name": true,
            "prompt_for_task_description": true,
            "prompt_for_items": true,
            "delegate_to": "project_task_create"
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "How should we proceed with next milestone?"
          }
        }
      ],
      "error_handling": {
        "on_failure": "prompt_user",
        "retry": "max 1 attempt"
      }
    },
    "roadblocks_json": [
      {
        "issue": "no_next_milestone",
        "resolution": "All milestones complete - trigger project completion check"
      },
      {
        "issue": "next_milestone_unclear",
        "resolution": "Review ProjectBlueprint.md with user to clarify roadmap"
      },
      {
        "issue": "user_wants_pivot",
        "resolution": "Call project_evolution to handle roadmap change"
      }
    ],
    "intent_keywords_json": [
      "complete milestone",
      "finish milestone",
      "milestone done",
      "next milestone"
    ],
    "confidence_threshold": 0.8
  },
  {
    "name": "aifp_help",
    "type": "project",
    "level": 1,
    "parent_directive": "aifp_run",
    "category": {
      "name": "orchestration",
      "description": "Documentation and guidance access for AIFP directives"
    },
    "description": "Loads detailed documentation for a specific directive. Uses get_directive_by_name helper to retrieve directive JSON (includes workflow, description, category, md_file_path). If comprehensive context needed, reads MD file directly for purpose, examples, edge cases, and related directives. Provides guidance beyond basic directive metadata.",
    "md_file_path": "directives/aifp_help.md",
    "workflow": {
      "trunk": "load_directive_documentation",
      "branches": [
        {
          "if": "directive_name_provided",
          "then": "call_helper",
          "details": {
            "parameters": [
              "directive_name"
            ],
            "returns": "Directive JSON (includes workflow, description, category, md_file_path). Read MD file directly if detailed context needed."
          }
        },
        {
          "if": "documentation_loaded",
          "then": "display_to_user",
          "details": {
            "format": "markdown",
            "sections": [
              "Purpose",
              "When to Apply",
              "Workflow",
              "Examples",
              "Edge Cases",
              "Related Directives",
              "Helper Functions",
              "Database Operations"
            ]
          }
        },
        {
          "if": "no_directive_specified",
          "then": "show_available_directives",
          "details": {
            "prompt": "Which directive do you need help with? (name, keyword, or category)"
          }
        },
        {
          "if": "directive_not_found",
          "then": "suggest_similar",
          "details": {
            "use": "search_directives",
            "fuzzy_match": true
          }
        },
        {
          "fallback": "prompt_user",
          "details": {
            "clarify": "Please specify a directive name (e.g., 'fp_purity', 'project_file_write')"
          }
        }
      ],
      "error_handling": {
        "on_failure": "show_directive_list",
        "retry": "max 2 attempts"
      }
    },
    "roadblocks_json": [
      {
        "issue": "directive_not_found",
        "resolution": "Use search_directives to find similar directives"
      },
      {
        "issue": "md_file_missing",
        "resolution": "Fall back to basic directive metadata from database"
      }
    ],
    "intent_keywords_json": [
      "help with directive",
      "show documentation",
      "explain directive",
      "how does",
      "what is",
      "directive info"
    ],
    "confidence_threshold": 0.7
  }
]
