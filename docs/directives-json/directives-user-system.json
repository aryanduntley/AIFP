{
  "directive_set": "user_system",
  "version": "1.0",
  "description": "Directives for managing user-defined domain-specific directives (home automation, cloud infrastructure, etc.). When user directives are initialized, the AIFP project's purpose becomes implementing and executing those directives. The AI builds all necessary code, dependencies, helpers, cron jobs, and automations to fulfill the user directives. Status progression: parse → validate → implement (in_progress) → user testing → user approval (active) → modifications trigger return to in_progress.",
  "purpose_when_active": "The AIFP project serves as the execution engine for user directives. All project development focuses on meeting user directive requirements.",
  "status_semantics": {
    "NULL": "No user directives initialized",
    "in_progress": "AI is building/modifying the project to implement directives, OR user is testing implementation before approval",
    "active": "User has approved implementation, directives are successfully running",
    "disabled": "All directives paused but implementation preserved"
  },
  "directives": [
    {
      "name": "user_directive_parse",
      "type": "project",
      "level": 2,
      "parent_directive": "aifp_run",
      "description": "Parse user directive files (YAML/JSON/TXT) and extract structured directives",
      "workflow": {
        "trunk": "parse_directive_file",
        "branches": [
          {
            "step": "detect_format",
            "actions": [
              {"check": "file extension", "determine": "format (yaml/json/txt)"},
              {"load": "appropriate parser (parse_yaml/parse_json/parse_txt)"}
            ]
          },
          {
            "step": "parse_content",
            "actions": [
              {"parse": "directive file using format-specific parser"},
              {"extract": "directives list from parsed content"},
              {"validate": "basic structure (name, trigger, action required)"}
            ]
          },
          {
            "step": "identify_ambiguities",
            "actions": [
              {"analyze": "trigger specifications", "flag": "ambiguous time/conditions/events"},
              {"analyze": "action specifications", "flag": "missing parameters/endpoints"},
              {"analyze": "dependencies", "flag": "required APIs/packages/services"},
              {"collect": "all ambiguities for validation phase"}
            ]
          },
          {
            "step": "store_raw_directives",
            "actions": [
              {"calculate": "file_checksum for change detection"},
              {"insert": "source_files table (file_path, format, checksum, parse_status)"},
              {"for_each": "directive", "insert": "user_directives table (status=pending_validation, raw_content)"},
              {"log": "parse result to .aifp/logs/user-directives.log"}
            ]
          },
          {
            "step": "update_project_status",
            "actions": [
              {"check": "project.user_directives_status is NULL (first time initialization)"},
              {"if_null": "update project.user_directives_status='in_progress'"},
              {"note": "Status remains 'in_progress' until first directive is activated"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_parse_error_to_file_and_prompt_user",
          "retry": "max 2 attempts",
          "rollback": "mark source_file as parse_error status"
        }
      },
      "intent_keywords": ["parse directives", "read directive file", "load directives", "import directives"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ParseResult with directives list and ambiguities",
        "failure": "ParseError with details"
      }
    },

    {
      "name": "user_directive_validate",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_parse",
      "description": "Validate parsed directives through interactive Q&A to resolve ambiguities",
      "workflow": {
        "trunk": "validate_directives",
        "branches": [
          {
            "step": "interactive_clarification",
            "actions": [
              {"for_each": "ambiguity in directive", "prompt_user": "clarifying question with options if available"},
              {"store": "validation_questions and validation_answers in user_directives table"},
              {"timeout": "30 seconds per question with default fallback"}
            ]
          },
          {
            "step": "resolve_ambiguities",
            "actions": [
              {"apply": "user answers to directive config"},
              {"generate": "validated_content JSON with resolved values"},
              {"infer": "missing optional fields from context"}
            ]
          },
          {
            "step": "confirm_understanding",
            "actions": [
              {"present": "validated directive interpretation to user"},
              {"prompt": "Is this correct? (yes/no/modify)"},
              {"if_no": "re-prompt for clarification with previous answers"},
              {"if_modify": "allow user to edit specific fields"}
            ]
          },
          {
            "step": "store_validated_directives",
            "actions": [
              {"update": "user_directives table (status=validated, validated_content, validated_at)"},
              {"write": "validated directive file to .aifp/user-directives/validated/ folder"},
              {"log": "validation success to .aifp/logs/user-directives.log"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_validation_error_and_retry_with_simpler_questions",
          "retry": "max 3 attempts",
          "escalate": "if user cannot provide answers, mark directive as manual_validation_required"
        }
      },
      "intent_keywords": ["validate directives", "confirm directives", "check directives", "verify directives"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ValidatedDirective with resolved configuration",
        "failure": "ValidationError with remaining ambiguities"
      }
    },

    {
      "name": "user_directive_implement",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_validate",
      "description": "Build the entire AIFP project to implement user directives. Generate all necessary FP-compliant code, install dependencies, create helper functions, set up cron jobs, configure automations, and build supporting infrastructure. The project's purpose becomes executing these directives.",
      "workflow": {
        "trunk": "generate_implementation_code",
        "branches": [
          {
            "step": "analyze_requirements",
            "actions": [
              {"determine": "implementation_type (handler/scheduler/service/function) based on trigger type"},
              {"identify": "required dependencies from action config"},
              {"check": "dependency availability in directive_dependencies table"}
            ]
          },
          {
            "step": "handle_dependencies",
            "actions": [
              {"for_each": "missing dependency", "prompt_user": "Install {package} (version {version})? (y/n) - Required for {reason}"},
              {"if_yes": "install_dependency and mark status=installed, user_confirmed=true"},
              {"if_no": "mark status=not_installed, check if required or optional"},
              {"if_required_missing": "abort implementation with error"},
              {"update": "directive_dependencies table with installation status"}
            ]
          },
          {
            "step": "generate_code",
            "actions": [
              {"load": "code generation template for implementation_type"},
              {"apply": "validated_content to template placeholders"},
              {"generate": "FP-compliant Python code with pure functions and immutable config"},
              {"apply": "fp_purity directive to ensure logic functions have no side effects"},
              {"apply": "fp_immutability directive to ensure configuration is frozen"},
              {"apply": "fp_side_effect_detection directive to isolate I/O in effect functions"}
            ]
          },
          {
            "step": "write_implementation_files",
            "actions": [
              {"write": "generated code to .aifp/user-directives/generated/{subdirectory}/"},
              {"write": "helper functions to appropriate project directories"},
              {"write": "cron job configurations if needed"},
              {"write": "automation scripts and service files"},
              {"calculate": "file_checksum for change detection"},
              {"insert": "directive_implementations table (file_path, implementation_type, function_name, checksum)"},
              {"update": "user_directives (status=implemented, implementation_status=completed, implementation_file_path)"}
            ]
          },
          {
            "step": "update_project_purpose",
            "actions": [
              {"check": "if project.purpose should be updated to reflect user directives"},
              {"if_no_existing_purpose": "update project.purpose to describe user directive implementation"},
              {"update": "project.goals_json to include user directive requirements"},
              {"note": "Project purpose now focused on executing user directives"}
            ]
          },
          {
            "parallel": [
              "call_project_file_write_for_generated_code",
              "update_project_db_files_table",
              "update_project_db_functions_table",
              "update_project_db_infrastructure_table"
            ],
            "details": {
              "apply_fp_compliance_check": true,
              "track_generated_functions": true,
              "track_dependencies": true
            }
          },
          {
            "step": "prepare_for_user_testing",
            "actions": [
              {"create": "testing instructions document for user"},
              {"log": "Implementation complete. Status remains 'in_progress' until user testing and approval."},
              {"note": "project.user_directives_status stays 'in_progress' - waiting for user approval"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_implementation_error_and_rollback_generated_files",
          "retry": "max 2 attempts",
          "rollback": "delete generated files, update status to validation for retry"
        }
      },
      "intent_keywords": ["implement directive", "generate code", "create implementation", "code directive"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ImplementationResult with file_path and function_name",
        "failure": "ImplementationError with details"
      }
    },

    {
      "name": "user_directive_approve",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_implement",
      "description": "User approves tested implementation, transitioning project from 'in_progress' to 'active' status. Called after user has tested the implementation and confirmed it meets their requirements.",
      "workflow": {
        "trunk": "approve_implementation",
        "branches": [
          {
            "step": "confirm_user_approval",
            "actions": [
              {"prompt": "Have you tested the implementation? Is it working as expected? (yes/no/needs_changes)"},
              {"if_yes": "proceed_to_approval"},
              {"if_no": "return_to_implementation_with_feedback"},
              {"if_needs_changes": "collect_feedback_and_modify"}
            ]
          },
          {
            "step": "collect_testing_feedback",
            "actions": [
              {"if_needs_changes": "prompt user for specific issues or changes needed"},
              {"log": "user feedback to notes table"},
              {"if_changes_needed": "call user_directive_update to modify implementation"}
            ]
          },
          {
            "step": "mark_approved",
            "actions": [
              {"update": "user_directives (approved=true, approved_at=current_timestamp)"},
              {"insert": "notes table (content='User approved directive implementation', note_type='approval', source='user')"},
              {"log": "User approved implementation", "to": ".aifp/logs/user-directives.log"}
            ]
          },
          {
            "step": "transition_to_active",
            "actions": [
              {"note": "Approval complete. Ready for activation."},
              {"prompt": "Activate directives now? (yes/no)"},
              {"if_yes": "call user_directive_activate"},
              {"if_no": "log 'Approved but not yet activated. Call activate when ready.'"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_approval_error_and_keep_status_in_progress"
        }
      },
      "intent_keywords": ["approve directives", "confirm implementation", "testing complete", "approve changes"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ApprovalResult with approved=true, ready for activation",
        "failure": "Feedback collected, returns to implementation phase"
      }
    },

    {
      "name": "user_directive_activate",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_approve",
      "description": "Deploy and activate approved directives for real-time execution. Only called after user approval.",
      "workflow": {
        "trunk": "activate_directive",
        "branches": [
          {
            "step": "verify_approval",
            "actions": [
              {"check": "user_directives.approved == true"},
              {"if_not_approved": "prompt user: 'Directive not yet approved. Run user_directive_approve first.'"},
              {"if_not_approved": "abort activation"}
            ]
          },
          {
            "step": "verify_implementation",
            "actions": [
              {"check": "implementation_file_path exists and is readable"},
              {"check": "all required dependencies installed (status=installed)"},
              {"validate": "entry_point is executable (syntax check)"},
              {"check": "no conflicting directives (same trigger time/condition)"}
            ]
          },
          {
            "step": "deploy_implementation",
            "actions": [
              {"if": "implementation_type == scheduler", "then": "register_with_apscheduler", "start": "scheduler daemon"},
              {"if": "implementation_type == service", "then": "start_background_service", "capture": "process_id"},
              {"if": "implementation_type == event_handler", "then": "register_event_listener", "setup": "webhook/MQTT/watcher"},
              {"if": "implementation_type == function", "then": "mark_ready_for_manual_execution"},
              {"store": "process_id and deployment details in directive_implementations"}
            ]
          },
          {
            "step": "initialize_execution_tracking",
            "actions": [
              {"insert": "directive_executions table (initial stats: total=0, success=0, error=0)"},
              {"calculate": "next_scheduled_time for time-based triggers"},
              {"update": "user_directives (status=active, activated_at=current_timestamp)"}
            ]
          },
          {
            "step": "initialize_logging",
            "actions": [
              {"setup": "execution log handler (rotating file: .aifp/logs/execution/)"},
              {"setup": "error log handler (rotating file: .aifp/logs/errors/)"},
              {"log": "Directive activated: {name} (type: {implementation_type}, PID: {process_id})", "to": ".aifp/logs/user-directives.log"}
            ]
          },
          {
            "step": "update_project_status_to_active",
            "actions": [
              {"check": "project.user_directives_status is 'in_progress' or 'disabled'"},
              {"if_true": "update project.user_directives_status='active'"},
              {"note": "Status set to active when first directive is activated or when reactivating after disable"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "rollback_activation_stop_services_and_log_error",
          "retry": "max 1 attempt",
          "rollback": "stop any started processes, update status to implemented"
        }
      },
      "intent_keywords": ["activate directive", "start directive", "enable directive", "deploy directive"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ActivationResult with status=active and next_execution_time",
        "failure": "ActivationError with details"
      }
    },

    {
      "name": "user_directive_monitor",
      "type": "project",
      "level": 3,
      "parent_directive": "user_directive_activate",
      "description": "Monitor active directive executions, track statistics, and handle errors",
      "workflow": {
        "trunk": "monitor_directive_execution",
        "branches": [
          {
            "step": "track_executions",
            "actions": [
              {"on_execution_start": "log timestamp and directive name to execution log file"},
              {"on_execution_end": "log result, duration_ms, and metadata to execution log file"},
              {"update": "directive_executions (total_executions++, last_execution_time, avg_execution_time_ms)"},
              {"if_success": "increment success_count"},
              {"calculate": "running average of execution time"}
            ]
          },
          {
            "step": "handle_errors",
            "actions": [
              {"on_error": "log error details (type, message, stack_trace) to error log file"},
              {"update": "directive_executions (error_count++, last_error_time, last_error_type, last_error_message)"},
              {"if": "error_count > threshold (e.g., 5 consecutive errors)", "then": "update status to error and notify user"},
              {"check": "error patterns for common issues (connection errors, auth failures, etc.)"}
            ]
          },
          {
            "step": "rotate_logs",
            "actions": [
              {"check": "execution log file size or date against rotation policy"},
              {"if": "rotation_trigger_met", "then": "rotate log file to archive with timestamp"},
              {"if": "retention_period_exceeded", "then": "compress old archives (.gz) or delete"},
              {"apply": "same rotation logic to error logs"}
            ]
          },
          {
            "step": "health_check",
            "actions": [
              {"check": "background services are still running (verify PID)"},
              {"check": "schedulers are properly registered"},
              {"if_service_died": "attempt restart or update status to error"},
              {"log": "health check results to lifecycle log"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_monitor_error_to_error_log_and_continue",
          "note": "monitoring should be resilient and not crash on errors"
        }
      },
      "intent_keywords": ["monitor directives", "check directive status", "directive health", "show execution logs"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "MonitoringReport with statistics and health status",
        "failure": "MonitoringError with details (but monitoring continues)"
      }
    },

    {
      "name": "user_directive_update",
      "type": "project",
      "level": 2,
      "parent_directive": "aifp_run",
      "description": "Handle changes to user directive source files. When modifications are detected, status returns to 'in_progress', directives are deactivated if active, re-implemented, and require user approval again before reactivation.",
      "workflow": {
        "trunk": "detect_and_update_directive",
        "branches": [
          {
            "step": "detect_source_file_change",
            "actions": [
              {"watch": "source_files for checksum changes (periodic check or file watcher)"},
              {"on_change_detected": "trigger update workflow"},
              {"compare": "old_checksum vs new_checksum to confirm change"}
            ]
          },
          {
            "step": "parse_updated_file",
            "actions": [
              {"call": "user_directive_parse for updated file"},
              {"compare": "new directives vs existing directives by name"},
              {"identify": "changed directives (modified), new directives (added), removed directives (deleted)"}
            ]
          },
          {
            "step": "handle_changes",
            "actions": [
              {"for_each": "modified directive", "actions": [
                {"if_active": "call user_directive_deactivate first"},
                {"update": "user_directives (approved=false, status=pending_validation)"},
                {"update": "project.user_directives_status='in_progress'"},
                {"log": "Directive modified. Returning to in_progress status. Re-implementation and user approval required."},
                {"call": "user_directive_validate for modified directive"},
                {"call": "user_directive_implement to regenerate code"},
                {"note": "Status remains 'in_progress' until user approves via user_directive_approve"},
                {"prompt": "Implementation updated. Please test and approve when ready."}
              ]},
              {"for_each": "new directive", "actions": [
                {"call": "user_directive_validate"},
                {"call": "user_directive_implement"},
                {"prompt": "Activate new directive {name}? (y/n)"}
              ]},
              {"for_each": "removed directive", "actions": [
                {"if_active": "call user_directive_deactivate"},
                {"update": "user_directives (status=deprecated)"},
                {"log": "Directive removed from source file"}
              ]}
            ]
          },
          {
            "step": "update_source_file_record",
            "actions": [
              {"update": "source_files (file_checksum, last_parsed_at, directive_count)"},
              {"log": "Source file updated: {file_path}", "to": ".aifp/logs/user-directives.log"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "rollback_to_previous_version_and_reactivate_old_implementation",
          "retry": "max 2 attempts",
          "rollback": "restore previous implementation files and reactivate"
        }
      },
      "intent_keywords": ["update directives", "reload directives", "refresh directives", "detect changes"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "UpdateResult with changed/added/removed directive counts",
        "failure": "UpdateError with rollback details"
      }
    },

    {
      "name": "user_directive_deactivate",
      "type": "project",
      "level": 2,
      "parent_directive": "aifp_run",
      "description": "Stop execution of active directives and clean up resources",
      "workflow": {
        "trunk": "deactivate_directive",
        "branches": [
          {
            "step": "stop_execution",
            "actions": [
              {"if": "implementation_type == scheduler", "then": "unregister_job_from_apscheduler"},
              {"if": "implementation_type == service", "then": "stop_background_service (send SIGTERM to PID, wait for graceful shutdown)"},
              {"if": "implementation_type == event_handler", "then": "unregister_event_listener (close webhooks, disconnect MQTT, etc.)"},
              {"timeout": "10 seconds for graceful shutdown, then SIGKILL if necessary"}
            ]
          },
          {
            "step": "update_status",
            "actions": [
              {"update": "user_directives (status=paused)"},
              {"update": "directive_implementations (deployed=false, process_id=null)"},
              {"log": "Directive deactivated: {name}", "to": ".aifp/logs/user-directives.log"}
            ]
          },
          {
            "step": "finalize_logs",
            "actions": [
              {"flush": "execution log handler (write buffered logs)"},
              {"rotate": "logs if needed (close current session)"},
              {"archive": "current execution session logs to dated file"}
            ]
          },
          {
            "step": "preserve_statistics",
            "actions": [
              {"keep": "directive_executions record intact for historical reference"},
              {"note": "Statistics are preserved even when directive is deactivated"}
            ]
          },
          {
            "step": "check_remaining_active_directives",
            "actions": [
              {"query": "user_directives table for any remaining directives with status='active'"},
              {"if_none_active": "update project.user_directives_status='disabled'"},
              {"if_any_active": "keep project.user_directives_status='active'"},
              {"note": "Only set to disabled if ALL directives are deactivated"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "force_kill_processes_and_log_error",
          "retry": "max 1 attempt with force kill",
          "cleanup": "always update status to paused even if stop fails"
        }
      },
      "intent_keywords": ["deactivate directive", "stop directive", "disable directive", "pause directive"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "DeactivationResult with status=paused",
        "failure": "DeactivationError with forced cleanup details"
      }
    },

    {
      "name": "user_directive_status",
      "type": "project",
      "level": 1,
      "parent_directive": "aifp_run",
      "description": "Get comprehensive status report for all user directives",
      "workflow": {
        "trunk": "get_user_directive_status",
        "branches": [
          {
            "step": "check_user_directives_db_exists",
            "actions": [
              {"check": ".aifp/user_directives.db exists"},
              {"if_not_exists": "return message: 'No user directives initialized'"},
              {"if_exists": "proceed with status retrieval"}
            ]
          },
          {
            "step": "query_directive_statistics",
            "actions": [
              {"query": "user_directives table for all directives grouped by status"},
              {"query": "directive_executions table for execution statistics"},
              {"calculate": "totals: active, paused, error, pending_validation, implemented"}
            ]
          },
          {
            "step": "build_status_report",
            "actions": [
              {"for_each": "active directive", "include": "name, status, next_execution_time, total_executions, success_rate, last_execution, last_error"},
              {"for_each": "paused directive", "include": "name, reason_paused, total_executions, last_execution"},
              {"for_each": "error directive", "include": "name, last_error_type, last_error_message, error_count"},
              {"for_each": "pending directive", "include": "name, current_phase (parsing/validation/implementation)"}
            ]
          },
          {
            "step": "include_log_paths",
            "actions": [
              {"include": "execution log path (.aifp/logs/execution/current.log)"},
              {"include": "error log path (.aifp/logs/errors/current_errors.log)"},
              {"include": "lifecycle log path (.aifp/logs/user-directives.log)"}
            ]
          }
        ],
        "error_handling": {
          "on_failure": "return_partial_status_with_error_note"
        }
      },
      "intent_keywords": ["user directive status", "show directives", "list directives", "directive stats"],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "StatusReport with detailed information for all directives",
        "failure": "PartialStatusReport with error details"
      }
    }
  ],

  "helper_functions": [
    {
      "name": "parse_directive_file",
      "file_path": "helpers/user_directives/parse_directive_file.py",
      "parameters": ["file_path", "file_format"],
      "purpose": "Parse user directive file and extract directives with ambiguity detection",
      "error_handling": "Log parse errors to .aifp/logs/errors/ and prompt user"
    },
    {
      "name": "validate_user_directive",
      "file_path": "helpers/user_directives/validate_user_directive.py",
      "parameters": ["directive", "interactive"],
      "purpose": "Validate directive through interactive Q&A to resolve ambiguities",
      "error_handling": "Log validation errors and retry with simpler questions"
    },
    {
      "name": "generate_implementation_code",
      "file_path": "helpers/user_directives/generate_implementation_code.py",
      "parameters": ["directive", "template"],
      "purpose": "Generate FP-compliant implementation code from directive and template",
      "error_handling": "Log generation errors and rollback any partial writes"
    },
    {
      "name": "detect_dependencies",
      "file_path": "helpers/user_directives/detect_dependencies.py",
      "parameters": ["directive"],
      "purpose": "Detect required dependencies (packages, APIs, env vars) from directive config",
      "error_handling": "Return empty list on error, log warning"
    },
    {
      "name": "install_dependency",
      "file_path": "helpers/user_directives/install_dependency.py",
      "parameters": ["package", "version", "prompt_user"],
      "purpose": "Install Python package dependency with user confirmation",
      "error_handling": "Log installation errors to .aifp/logs/errors/ and mark dependency as failed"
    },
    {
      "name": "activate_directive",
      "file_path": "helpers/user_directives/activate_directive.py",
      "parameters": ["directive_id"],
      "purpose": "Deploy and activate directive implementation for real-time execution",
      "error_handling": "Rollback activation, stop services, log error"
    },
    {
      "name": "monitor_directive_execution",
      "file_path": "helpers/user_directives/monitor_directive_execution.py",
      "parameters": ["directive_id"],
      "purpose": "Track directive execution statistics and handle errors",
      "error_handling": "Log monitoring errors but continue monitoring"
    },
    {
      "name": "get_user_directive_status",
      "file_path": "helpers/user_directives/get_user_directive_status.py",
      "parameters": [],
      "purpose": "Build comprehensive status report for all user directives",
      "error_handling": "Return partial status with error note"
    },
    {
      "name": "update_directive",
      "file_path": "helpers/user_directives/update_directive.py",
      "parameters": ["directive_id", "changes"],
      "purpose": "Handle directive updates (re-parse, re-validate, re-implement)",
      "error_handling": "Rollback to previous version and reactivate old implementation"
    },
    {
      "name": "deactivate_directive",
      "file_path": "helpers/user_directives/deactivate_directive.py",
      "parameters": ["directive_id"],
      "purpose": "Stop directive execution and clean up resources",
      "error_handling": "Force kill processes if graceful shutdown fails"
    }
  ],

  "logging_configuration": {
    "execution_logs": {
      "location": ".aifp/logs/execution/",
      "format": "json_lines",
      "rotation": "daily",
      "retention_days": 30,
      "compress_after_days": 7
    },
    "error_logs": {
      "location": ".aifp/logs/errors/",
      "format": "json_lines",
      "rotation": "10MB",
      "retention_days": 90
    },
    "lifecycle_log": {
      "location": ".aifp/logs/user-directives.log",
      "format": "human_readable",
      "rotation": "weekly",
      "retention_days": 90
    },
    "database_logging": {
      "store_statistics": true,
      "store_last_error_only": true,
      "store_execution_history": false
    }
  }
}
