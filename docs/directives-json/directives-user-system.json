{
  "directive_set": "user_system",
  "version": "1.0",
  "description": "Directives for managing user-defined domain-specific directives (home automation, cloud infrastructure, etc.). When user directives are initialized, the AIFP project's purpose becomes implementing and executing those directives. The AI builds all necessary code, dependencies, helpers, cron jobs, and automations to fulfill the user directives. Status progression: parse → validate → implement (in_progress) → user testing → user approval (active) → modifications trigger return to in_progress.",
  "purpose_when_active": "The AIFP project serves as the execution engine for user directives. All project development focuses on meeting user directive requirements.",
  "status_semantics": {
    "NULL": "No user directives initialized",
    "in_progress": "AI is building/modifying the project to implement directives, OR user is testing implementation before approval",
    "active": "User has approved implementation, directives are successfully running",
    "disabled": "All directives paused but implementation preserved"
  },
  "directives": [
    {
      "name": "user_directive_parse",
      "type": "project",
      "level": 2,
      "parent_directive": "aifp_run",
      "md_file_path": "directives/user_directive_parse.md",
      "description": "Parse user directive files (YAML/JSON/TXT) from wherever user placed them in their project. User tells AI the file path (e.g., 'directives/lights.yaml', 'automations.yaml', etc.).",
      "parameters": {
        "file_path": "Path to user's directive file relative to project root"
      },
      "workflow": {
        "trunk": "parse_directive_file",
        "branches": [
          {
            "step": "locate_file",
            "actions": [
              {
                "resolve": "file_path to absolute path from project root"
              },
              {
                "check": "file exists and is readable"
              },
              {
                "if_not_found": "prompt user for correct path"
              }
            ]
          },
          {
            "step": "detect_format",
            "actions": [
              {
                "check": "file extension",
                "determine": "format (yaml/json/txt)"
              },
              {
                "load": "appropriate parser (parse_yaml/parse_json/parse_txt)"
              }
            ]
          },
          {
            "step": "parse_content",
            "actions": [
              {
                "parse": "directive file using format-specific parser"
              },
              {
                "extract": "directives list from parsed content"
              },
              {
                "validate": "basic structure (name, trigger, action required)"
              }
            ]
          },
          {
            "step": "identify_ambiguities",
            "actions": [
              {
                "analyze": "trigger specifications",
                "flag": "ambiguous time/conditions/events"
              },
              {
                "analyze": "action specifications",
                "flag": "missing parameters/endpoints"
              },
              {
                "analyze": "dependencies",
                "flag": "required APIs/packages/services"
              },
              {
                "collect": "all ambiguities for validation phase"
              }
            ]
          },
          {
            "step": "store_raw_directives",
            "actions": [
              {
                "calculate": "file_checksum for change detection"
              },
              {
                "insert": "source_files table (absolute file_path, format, checksum, parse_status)"
              },
              {
                "for_each": "directive",
                "insert": "user_directives table (status=pending_validation, raw_content, source_file_reference)"
              },
              {
                "log": "parse result to .aifp-project/logs/user-directives.log"
              },
              {
                "note": "File stays where user put it - we just track the reference"
              }
            ]
          },
          {
            "step": "update_project_status",
            "actions": [
              {
                "check": "project.user_directives_status is NULL (first time initialization)"
              },
              {
                "if_null": "update project.user_directives_status='in_progress'"
              },
              {
                "note": "Status remains 'in_progress' until first directive is activated"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_parse_error_to_file_and_prompt_user",
          "retry": "max 2 attempts",
          "rollback": "mark source_file as parse_error status"
        }
      },
      "intent_keywords": [
        "parse directives",
        "read directive file",
        "load directives",
        "import directives"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ParseResult with directives list and ambiguities",
        "failure": "ParseError with details"
      }
    },
    {
      "name": "user_directive_validate",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_parse",
      "md_file_path": "directives/user_directive_validate.md",
      "description": "Validate parsed directives through interactive Q&A to resolve ambiguities",
      "workflow": {
        "trunk": "validate_directives",
        "branches": [
          {
            "step": "interactive_clarification",
            "actions": [
              {
                "for_each": "ambiguity in directive",
                "prompt_user": "clarifying question with options if available"
              },
              {
                "store": "validation_questions and validation_answers in user_directives table"
              },
              {
                "timeout": "30 seconds per question with default fallback"
              }
            ]
          },
          {
            "step": "resolve_ambiguities",
            "actions": [
              {
                "apply": "user answers to directive config"
              },
              {
                "generate": "validated_content JSON with resolved values"
              },
              {
                "infer": "missing optional fields from context"
              }
            ]
          },
          {
            "step": "confirm_understanding",
            "actions": [
              {
                "present": "validated directive interpretation to user"
              },
              {
                "prompt": "Is this correct? (yes/no/modify)"
              },
              {
                "if_no": "re-prompt for clarification with previous answers"
              },
              {
                "if_modify": "allow user to edit specific fields"
              }
            ]
          },
          {
            "step": "store_validated_directives",
            "actions": [
              {
                "update": "user_directives table (status=validated, validated_content, validated_at)"
              },
              {
                "log": "validation success to .aifp-project/logs/user-directives.log"
              },
              {
                "note": "Validated content stored in database only - user's source file unchanged"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_validation_error_and_retry_with_simpler_questions",
          "retry": "max 3 attempts",
          "escalate": "if user cannot provide answers, mark directive as manual_validation_required"
        }
      },
      "intent_keywords": [
        "validate directives",
        "confirm directives",
        "check directives",
        "verify directives"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ValidatedDirective with resolved configuration",
        "failure": "ValidationError with remaining ambiguities"
      }
    },
    {
      "name": "user_directive_implement",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_validate",
      "md_file_path": "directives/user_directive_implement.md",
      "description": "Build the entire AIFP project to implement user directives. Reserve names via project_reserve_finalize before generating code to get database IDs for embedding. Generate all necessary FP-compliant code with embedded IDs, install dependencies, create helper functions, set up cron jobs, configure automations, and build supporting infrastructure. The project's purpose becomes executing these directives.",
      "workflow": {
        "trunk": "generate_implementation_code",
        "branches": [
          {
            "step": "analyze_requirements",
            "actions": [
              {
                "determine": "implementation_type (handler/scheduler/service/function) based on trigger type"
              },
              {
                "identify": "required dependencies from action config"
              },
              {
                "check": "dependency availability in directive_dependencies table"
              }
            ]
          },
          {
            "step": "handle_dependencies",
            "actions": [
              {
                "for_each": "missing dependency",
                "prompt_user": "Install {package} (version {version})? (y/n) - Required for {reason}"
              },
              {
                "if_yes": "install_dependency and mark status=installed, user_confirmed=true"
              },
              {
                "if_no": "mark status=not_installed, check if required or optional"
              },
              {
                "if_required_missing": "abort implementation with error"
              },
              {
                "update": "directive_dependencies table with installation status"
              }
            ]
          },
          {
            "step": "generate_code",
            "actions": [
              {
                "load": "code generation template for implementation_type"
              },
              {
                "apply": "validated_content to template placeholders"
              },
              {
                "generate": "FP-compliant Python code with pure functions and immutable config"
              },
              {
                "apply": "fp_purity directive to ensure logic functions have no side effects"
              },
              {
                "apply": "fp_immutability directive to ensure configuration is frozen"
              },
              {
                "apply": "fp_side_effect_detection directive to isolate I/O in effect functions"
              }
            ]
          },
          {
            "step": "write_implementation_files",
            "actions": [
              {
                "write": "generated FP-compliant code to src/{module_name}.py - this is the ACTUAL PROJECT CODE"
              },
              {
                "write": "generated tests to tests/test_{module_name}.py"
              },
              {
                "write": "helper functions to src/helpers/ if needed"
              },
              {
                "write": "scheduler/service configuration to project root if needed"
              },
              {
                "update": "requirements.txt with detected dependencies"
              },
              {
                "calculate": "file_checksum for change detection"
              },
              {
                "insert": "directive_implementations table (links directive to src/ files)"
              },
              {
                "update": "user_directives (status=implemented, implementation_status=completed, implementation_file_path)"
              }
            ],
            "note": "Generated code becomes the project's src/ codebase. Project.db tracks these files like any AIFP project. User directives are definitions (.aifp-project/directives/source/), generated code is the actual implementation (src/)."
          },
          {
            "step": "update_project_purpose",
            "actions": [
              {
                "check": "if project.purpose should be updated to reflect user directives"
              },
              {
                "if_no_existing_purpose": "update project.purpose to describe user directive implementation"
              },
              {
                "update": "project.goals_json to include user directive requirements"
              },
              {
                "note": "Project purpose now focused on executing user directives"
              }
            ]
          },
          {
            "parallel": [
              "call_project_file_write_for_generated_code",
              "update_project_db_files_table",
              "update_project_db_functions_table",
              "update_project_db_infrastructure_table"
            ],
            "details": {
              "apply_fp_compliance_check": true,
              "track_generated_functions": true,
              "track_dependencies": true
            }
          },
          {
            "step": "prepare_for_user_testing",
            "actions": [
              {
                "create": "testing instructions document for user"
              },
              {
                "log": "Implementation complete. Status remains 'in_progress' until user testing and approval."
              },
              {
                "note": "project.user_directives_status stays 'in_progress' - waiting for user approval"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_implementation_error_and_rollback_generated_files",
          "retry": "max 2 attempts",
          "rollback": "delete generated files, update status to validation for retry"
        }
      },
      "intent_keywords": [
        "implement directive",
        "generate code",
        "create implementation",
        "code directive"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ImplementationResult with file_path and function_name",
        "failure": "ImplementationError with details"
      }
    },
    {
      "name": "user_directive_approve",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_implement",
      "md_file_path": "directives/user_directive_approve.md",
      "description": "User approves tested implementation, transitioning project from 'in_progress' to 'active' status. Called after user has tested the implementation and confirmed it meets their requirements.",
      "workflow": {
        "trunk": "approve_implementation",
        "branches": [
          {
            "step": "confirm_user_approval",
            "actions": [
              {
                "prompt": "Have you tested the implementation? Is it working as expected? (yes/no/needs_changes)"
              },
              {
                "if_yes": "proceed_to_approval"
              },
              {
                "if_no": "return_to_implementation_with_feedback"
              },
              {
                "if_needs_changes": "collect_feedback_and_modify"
              }
            ]
          },
          {
            "step": "collect_testing_feedback",
            "actions": [
              {
                "if_needs_changes": "prompt user for specific issues or changes needed"
              },
              {
                "log": "user feedback to notes table"
              },
              {
                "if_changes_needed": "call user_directive_update to modify implementation"
              }
            ]
          },
          {
            "step": "mark_approved",
            "actions": [
              {
                "update": "user_directives (approved=true, approved_at=current_timestamp)"
              },
              {
                "insert": "notes table (content='User approved directive implementation', note_type='decision', source='user')"
              },
              {
                "log": "User approved implementation",
                "to": ".aifp-project/logs/user-directives.log"
              }
            ]
          },
          {
            "step": "transition_to_active",
            "actions": [
              {
                "note": "Approval complete. Ready for activation."
              },
              {
                "prompt": "Activate directives now? (yes/no)"
              },
              {
                "if_yes": "call user_directive_activate"
              },
              {
                "if_no": "log 'Approved but not yet activated. Call activate when ready.'"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_approval_error_and_keep_status_in_progress"
        }
      },
      "intent_keywords": [
        "approve directives",
        "confirm implementation",
        "testing complete",
        "approve changes"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ApprovalResult with approved=true, ready for activation",
        "failure": "Feedback collected, returns to implementation phase"
      }
    },
    {
      "name": "user_directive_activate",
      "type": "project",
      "level": 2,
      "parent_directive": "user_directive_approve",
      "md_file_path": "directives/user_directive_activate.md",
      "description": "Deploy and activate approved directives for real-time execution. Only called after user approval.",
      "workflow": {
        "trunk": "activate_directive",
        "branches": [
          {
            "step": "verify_approval",
            "actions": [
              {
                "check": "user_directives.approved == true"
              },
              {
                "if_not_approved": "prompt user: 'Directive not yet approved. Run user_directive_approve first.'"
              },
              {
                "if_not_approved": "abort activation"
              }
            ]
          },
          {
            "step": "verify_implementation",
            "actions": [
              {
                "check": "implementation_file_path exists and is readable"
              },
              {
                "check": "all required dependencies installed (status=installed)"
              },
              {
                "validate": "entry_point is executable (syntax check)"
              },
              {
                "check": "no conflicting directives (same trigger time/condition)"
              }
            ]
          },
          {
            "step": "deploy_implementation",
            "actions": [
              {
                "if": "implementation_type == scheduler",
                "then": "register_with_apscheduler",
                "start": "scheduler daemon"
              },
              {
                "if": "implementation_type == service",
                "then": "start_background_service",
                "capture": "process_id"
              },
              {
                "if": "implementation_type == event_handler",
                "then": "register_event_listener",
                "setup": "webhook/MQTT/watcher"
              },
              {
                "if": "implementation_type == function",
                "then": "mark_ready_for_manual_execution"
              },
              {
                "store": "process_id and deployment details in directive_implementations"
              }
            ]
          },
          {
            "step": "initialize_execution_tracking",
            "actions": [
              {
                "insert": "directive_executions table (initial stats: total=0, success=0, error=0)"
              },
              {
                "calculate": "next_scheduled_time for time-based triggers"
              },
              {
                "update": "user_directives (status=active, activated_at=current_timestamp)"
              }
            ]
          },
          {
            "step": "initialize_logging",
            "actions": [
              {
                "setup": "execution log handler (rotating file: .aifp-project/logs/execution/)"
              },
              {
                "setup": "error log handler (rotating file: .aifp-project/logs/errors/)"
              },
              {
                "log": "Directive activated: {name} (type: {implementation_type}, PID: {process_id})",
                "to": ".aifp-project/logs/user-directives.log"
              }
            ]
          },
          {
            "step": "update_project_status_to_active",
            "actions": [
              {
                "check": "project.user_directives_status is 'in_progress' or 'disabled'"
              },
              {
                "if_true": "update project.user_directives_status='active'"
              },
              {
                "note": "Status set to active when first directive is activated or when reactivating after disable"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "rollback_activation_stop_services_and_log_error",
          "retry": "max 1 attempt",
          "rollback": "stop any started processes, update status to implemented"
        }
      },
      "intent_keywords": [
        "activate directive",
        "start directive",
        "enable directive",
        "deploy directive"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "ActivationResult with status=active and next_execution_time",
        "failure": "ActivationError with details"
      }
    },
    {
      "name": "user_directive_monitor",
      "type": "project",
      "level": 3,
      "parent_directive": "user_directive_activate",
      "md_file_path": "directives/user_directive_monitor.md",
      "description": "Monitor active directive executions, track statistics, and handle errors",
      "workflow": {
        "trunk": "monitor_directive_execution",
        "branches": [
          {
            "step": "track_executions",
            "actions": [
              {
                "on_execution_start": "log timestamp and directive name to execution log file"
              },
              {
                "on_execution_end": "log result, duration_ms, and metadata to execution log file"
              },
              {
                "update": "directive_executions (total_executions++, last_execution_time, avg_execution_time_ms)"
              },
              {
                "if_success": "increment success_count"
              },
              {
                "calculate": "running average of execution time"
              }
            ]
          },
          {
            "step": "handle_errors",
            "actions": [
              {
                "on_error": "log error details (type, message, stack_trace) to error log file"
              },
              {
                "update": "directive_executions (error_count++, last_error_time, last_error_type, last_error_message)"
              },
              {
                "if": "error_count > threshold (e.g., 5 consecutive errors)",
                "then": "update status to error and notify user"
              },
              {
                "check": "error patterns for common issues (connection errors, auth failures, etc.)"
              }
            ]
          },
          {
            "step": "rotate_logs",
            "actions": [
              {
                "check": "execution log file size or date against rotation policy"
              },
              {
                "if": "rotation_trigger_met",
                "then": "rotate log file to archive with timestamp"
              },
              {
                "if": "retention_period_exceeded",
                "then": "compress old archives (.gz) or delete"
              },
              {
                "apply": "same rotation logic to error logs"
              }
            ]
          },
          {
            "step": "health_check",
            "actions": [
              {
                "check": "background services are still running (verify PID)"
              },
              {
                "check": "schedulers are properly registered"
              },
              {
                "if_service_died": "attempt restart or update status to error"
              },
              {
                "log": "health check results to lifecycle log"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "log_monitor_error_to_error_log_and_continue",
          "note": "monitoring should be resilient and not crash on errors"
        }
      },
      "intent_keywords": [
        "monitor directives",
        "check directive status",
        "directive health",
        "show execution logs"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "MonitoringReport with statistics and health status",
        "failure": "MonitoringError with details (but monitoring continues)"
      }
    },
    {
      "name": "user_directive_update",
      "type": "project",
      "level": 2,
      "parent_directive": "aifp_run",
      "md_file_path": "directives/user_directive_update.md",
      "description": "Handle changes to user directive source files. When modifications are detected, status returns to 'in_progress', directives are deactivated if active, re-implemented, and require user approval again before reactivation.",
      "workflow": {
        "trunk": "detect_and_update_directive",
        "branches": [
          {
            "step": "detect_source_file_change",
            "actions": [
              {
                "watch": "source_files for checksum changes (periodic check or file watcher)"
              },
              {
                "on_change_detected": "trigger update workflow"
              },
              {
                "compare": "old_checksum vs new_checksum to confirm change"
              }
            ]
          },
          {
            "step": "parse_updated_file",
            "actions": [
              {
                "call": "user_directive_parse for updated file"
              },
              {
                "compare": "new directives vs existing directives by name"
              },
              {
                "identify": "changed directives (modified), new directives (added), removed directives (deleted)"
              }
            ]
          },
          {
            "step": "handle_changes",
            "actions": [
              {
                "for_each": "modified directive",
                "actions": [
                  {
                    "if_active": "call user_directive_deactivate first"
                  },
                  {
                    "update": "user_directives (approved=false, status=pending_validation)"
                  },
                  {
                    "update": "project.user_directives_status='in_progress'"
                  },
                  {
                    "log": "Directive modified. Returning to in_progress status. Re-implementation and user approval required."
                  },
                  {
                    "call": "user_directive_validate for modified directive"
                  },
                  {
                    "call": "user_directive_implement to regenerate code"
                  },
                  {
                    "note": "Status remains 'in_progress' until user approves via user_directive_approve"
                  },
                  {
                    "prompt": "Implementation updated. Please test and approve when ready."
                  }
                ]
              },
              {
                "for_each": "new directive",
                "actions": [
                  {
                    "call": "user_directive_validate"
                  },
                  {
                    "call": "user_directive_implement"
                  },
                  {
                    "prompt": "Activate new directive {name}? (y/n)"
                  }
                ]
              },
              {
                "for_each": "removed directive",
                "actions": [
                  {
                    "if_active": "call user_directive_deactivate"
                  },
                  {
                    "update": "user_directives (status=deprecated)"
                  },
                  {
                    "log": "Directive removed from source file"
                  }
                ]
              }
            ]
          },
          {
            "step": "update_source_file_record",
            "actions": [
              {
                "update": "source_files (file_checksum, last_parsed_at, directive_count)"
              },
              {
                "log": "Source file updated: {file_path}",
                "to": ".aifp-project/logs/user-directives.log"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "rollback_to_previous_version_and_reactivate_old_implementation",
          "retry": "max 2 attempts",
          "rollback": "restore previous implementation files and reactivate"
        }
      },
      "intent_keywords": [
        "update directives",
        "reload directives",
        "refresh directives",
        "detect changes"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "UpdateResult with changed/added/removed directive counts",
        "failure": "UpdateError with rollback details"
      }
    },
    {
      "name": "user_directive_deactivate",
      "type": "project",
      "level": 2,
      "parent_directive": "aifp_run",
      "md_file_path": "directives/user_directive_deactivate.md",
      "description": "Stop execution of active directives and clean up resources",
      "workflow": {
        "trunk": "deactivate_directive",
        "branches": [
          {
            "step": "stop_execution",
            "actions": [
              {
                "if": "implementation_type == scheduler",
                "then": "unregister_job_from_apscheduler"
              },
              {
                "if": "implementation_type == service",
                "then": "stop_background_service (send SIGTERM to PID, wait for graceful shutdown)"
              },
              {
                "if": "implementation_type == event_handler",
                "then": "unregister_event_listener (close webhooks, disconnect MQTT, etc.)"
              },
              {
                "timeout": "10 seconds for graceful shutdown, then SIGKILL if necessary"
              }
            ]
          },
          {
            "step": "update_status",
            "actions": [
              {
                "update": "user_directives (status=paused)"
              },
              {
                "update": "directive_implementations (deployed=false, process_id=null)"
              },
              {
                "log": "Directive deactivated: {name}",
                "to": ".aifp-project/logs/user-directives.log"
              }
            ]
          },
          {
            "step": "finalize_logs",
            "actions": [
              {
                "flush": "execution log handler (write buffered logs)"
              },
              {
                "rotate": "logs if needed (close current session)"
              },
              {
                "archive": "current execution session logs to dated file"
              }
            ]
          },
          {
            "step": "preserve_statistics",
            "actions": [
              {
                "keep": "directive_executions record intact for historical reference"
              },
              {
                "note": "Statistics are preserved even when directive is deactivated"
              }
            ]
          },
          {
            "step": "check_remaining_active_directives",
            "actions": [
              {
                "query": "user_directives table for any remaining directives with status='active'"
              },
              {
                "if_none_active": "update project.user_directives_status='disabled'"
              },
              {
                "if_any_active": "keep project.user_directives_status='active'"
              },
              {
                "note": "Only set to disabled if ALL directives are deactivated"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "force_kill_processes_and_log_error",
          "retry": "max 1 attempt with force kill",
          "cleanup": "always update status to paused even if stop fails"
        }
      },
      "intent_keywords": [
        "deactivate directive",
        "stop directive",
        "disable directive",
        "pause directive"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "DeactivationResult with status=paused",
        "failure": "DeactivationError with forced cleanup details"
      }
    },
    {
      "name": "user_directive_status",
      "type": "project",
      "level": 1,
      "parent_directive": "aifp_run",
      "md_file_path": "directives/user_directive_status.md",
      "description": "Get comprehensive status report for all user directives",
      "workflow": {
        "trunk": "get_user_directive_status",
        "branches": [
          {
            "step": "check_user_directives_db_exists",
            "actions": [
              {
                "check": ".aifp-project/user_directives.db exists"
              },
              {
                "if_not_exists": "return message: 'No user directives initialized'"
              },
              {
                "if_exists": "proceed with status retrieval"
              }
            ]
          },
          {
            "step": "query_directive_statistics",
            "actions": [
              {
                "query": "user_directives table for all directives grouped by status"
              },
              {
                "query": "directive_executions table for execution statistics"
              },
              {
                "calculate": "totals: active, paused, error, pending_validation, implemented"
              }
            ]
          },
          {
            "step": "build_status_report",
            "actions": [
              {
                "for_each": "active directive",
                "include": "name, status, next_execution_time, total_executions, success_rate, last_execution, last_error"
              },
              {
                "for_each": "paused directive",
                "include": "name, reason_paused, total_executions, last_execution"
              },
              {
                "for_each": "error directive",
                "include": "name, last_error_type, last_error_message, error_count"
              },
              {
                "for_each": "pending directive",
                "include": "name, current_phase (parsing/validation/implementation)"
              }
            ]
          },
          {
            "step": "include_log_paths",
            "actions": [
              {
                "include": "execution log path (.aifp-project/logs/execution/current.log)"
              },
              {
                "include": "error log path (.aifp-project/logs/errors/current_errors.log)"
              },
              {
                "include": "lifecycle log path (.aifp-project/logs/user-directives.log)"
              }
            ]
          }
        ],
        "error_handling": {
          "on_failure": "return_partial_status_with_error_note"
        }
      },
      "intent_keywords": [
        "user directive status",
        "show directives",
        "list directives",
        "directive stats"
      ],
      "confidence_threshold": 0.7,
      "outputs": {
        "success": "StatusReport with detailed information for all directives",
        "failure": "PartialStatusReport with error details"
      }
    }
  ],
  "logging_configuration": {
    "execution_logs": {
      "location": ".aifp-project/logs/execution/",
      "format": "json_lines",
      "rotation": "daily",
      "retention_days": 30,
      "compress_after_days": 7
    },
    "error_logs": {
      "location": ".aifp-project/logs/errors/",
      "format": "json_lines",
      "rotation": "10MB",
      "retention_days": 90
    },
    "lifecycle_log": {
      "location": ".aifp-project/logs/user-directives.log",
      "format": "human_readable",
      "rotation": "weekly",
      "retention_days": 90
    },
    "database_logging": {
      "store_statistics": true,
      "store_last_error_only": true,
      "store_execution_history": false
    }
  }
}
