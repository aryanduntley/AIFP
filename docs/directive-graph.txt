This is a very strong design already. What you’re missing is **not more hierarchy**, but a **first-class *directive navigation model*** that the AI can *reason over*, not just query.

Below is a concrete, FP-compatible way to add a **directive path tree / graph layer** that fits *exactly* with how your MCP server works (directive-driven, stateful, DB-centric, no code-path following).

---

# Reframe the Problem (Important)

You are **not** doing “pathfinding” in the classic sense.

You are doing:

> **State-conditioned directive traversal in a declarative control system**

So the correct structure is **not a simple tree** and not a single graph either — it is a:

> **Typed, state-aware directive graph with canonical traversal paths**

Your current schema already contains 80% of what’s needed.

What’s missing is:

* A **canonical traversal layer**
* A **directive “why/when” path**
* A **single authoritative map AI can load mentally**

---

# The Right Abstraction: Directive Navigation Graph (DNG)

Think of this as a **meta-graph over your directives** that answers:

* *Where am I?*
* *What directives are valid next?*
* *Which ones are canonical vs situational?*
* *What path would a “perfect run” take?*

This graph is:

* Read-only
* Precomputed or declaratively defined
* Queried, not executed

---

# Why Your Existing Tables Aren’t Enough (Yet)

You already have:

* `parent_directive` → hierarchy
* `directives_interactions` → relationships
* `workflow JSON` → internal flow
* `level` → project phase
* `intent keywords` → discovery

But AI still has to **mentally infer**:

* Primary paths vs exceptions
* Phase transitions
* Canonical sequences
* “You are here” semantics

That’s cognitive load you can remove.

---

# Add One New Concept (Minimal, Powerful)

## 1️⃣ `directive_paths` (Canonical Paths)

This defines **authoritative directive traversal paths**.

```sql
CREATE TABLE IF NOT EXISTS directive_paths (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,                -- e.g. 'default_project_lifecycle'
    description TEXT,
    entry_directive TEXT NOT NULL,            -- usually 'aifp_run'
    exit_directive TEXT,                      -- e.g. 'project_complete'
    path_type TEXT CHECK (path_type IN (
        'canonical',
        'error_recovery',
        'maintenance',
        'user_override'
    )) NOT NULL DEFAULT 'canonical',
    applies_when JSON,                        -- conditions on project state
    confidence REAL DEFAULT 1.0               -- how authoritative this path is
);
```

---

## 2️⃣ `directive_path_steps`

This is the **actual tree / graph ordering**.

```sql
CREATE TABLE IF NOT EXISTS directive_path_steps (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path_id INTEGER NOT NULL,

    step_order INTEGER NOT NULL,
    directive_name TEXT NOT NULL,

    required BOOLEAN DEFAULT 1,
    allows_branch BOOLEAN DEFAULT 0,
    branch_condition JSON,                    -- e.g. "if tasks_pending == true"

    next_on_success TEXT,                     -- override normal sequence
    next_on_failure TEXT,

    FOREIGN KEY (path_id) REFERENCES directive_paths(id)
);
```

This gives you:

* A **tree (branches)**
* A **linear happy path**
* Explicit **fallbacks**

---

# How AI Uses This (Critical)

### On `aifp_run`:

1. AI loads:

   * Current project state (from project DB)
   * Active directive path(s) whose `applies_when` match
2. AI identifies:

   * Current directive position in path
   * Completed steps
3. AI chooses:

   * Next directive from path
   * Or deviation if `confidence_threshold` violated

No inference. No guessing.

---

# This Solves Your Exact Goals

### ✔ “Full understanding at any time”

The AI can literally ask:

```sql
SELECT * FROM directive_path_steps
WHERE path_id = :active_path
ORDER BY step_order;
```

That’s the *map*.

---

### ✔ FP-Aligned

* No execution logic
* No mutable control flow
* Declarative state → directive selection

---

### ✔ Rejects OOP Cleanly

You can attach:

```json
applies_when: {
  "project.paradigm": "functional"
}
```

If violated → path invalid → escalation directive.

---

### ✔ No Context Reload Needed

Because:

* State lives in DB
* Path lives in DB
* AI only needs to re-scan pointers

---

# Optional (But Extremely Powerful)

## 3️⃣ `directive_state_contracts`

This makes paths **provably correct**.

```sql
CREATE TABLE IF NOT EXISTS directive_state_contracts (
    directive_name TEXT PRIMARY KEY,
    requires_state JSON,
    produces_state JSON,
    invalidates_state JSON
);
```

Now AI can:

* Validate path correctness
* Detect impossible transitions
* Explain *why* it chose a directive

---

# Mental Model for AI (Put This in System Prompt)

> “You do not infer workflows.
> You locate the active directive path.
> You execute the next valid directive according to the path and current state.”

This reduces hallucination dramatically.

---

# Final Recommendation (Concise)

**Do not build a generic tree.**
Build a **Directive Navigation Graph** with:

1. Canonical paths (`directive_paths`)
2. Ordered steps (`directive_path_steps`)
3. State-aware activation
4. Optional state contracts

Your existing schema already supports this with minimal extension.

---

If you want, next I can:

* Design the **exact `aifp_run` algorithm**
* Show **SQL queries AI would use**
* Help you **auto-generate a visual directive map**
* Stress-test this against failure modes

This is a genuinely solid architecture.


==========================

Absolutely! Given your architecture and the goal to reduce the AI's cognitive load (by not making it think about query construction), you can centralize common operations into **helper functions**. These will abstract away the complexity of interacting with the `directive_paths`, `directive_path_steps`, and `directive_state_contracts` tables, so AI can simply call well-defined, reusable functions.

Here’s a list of useful helper functions for these new tables, organized by general use case:

---

### **1. Helper Functions for `directive_paths` Table**

These functions deal with managing and querying the high-level paths and their conditions.

#### 1.1. **Create/Update Path**

* **Function Name**: `create_or_update_directive_path`
* **Purpose**: Creates a new directive path or updates an existing one.
* **Parameters**: `name, entry_directive, exit_directive, path_type, applies_when, confidence`
* **Returns**: `path_id`
* **SQL Example**:

  ```sql
  INSERT INTO directive_paths (name, entry_directive, exit_directive, path_type, applies_when, confidence)
  VALUES (?, ?, ?, ?, ?, ?)
  ON CONFLICT(name) DO UPDATE SET 
      entry_directive = excluded.entry_directive,
      exit_directive = excluded.exit_directive,
      path_type = excluded.path_type,
      applies_when = excluded.applies_when,
      confidence = excluded.confidence;
  ```

#### 1.2. **Get Path by ID**

* **Function Name**: `get_directive_path_by_id`
* **Purpose**: Retrieves the details of a specific directive path.
* **Parameters**: `path_id`
* **Returns**: A single record containing the `name`, `entry_directive`, `exit_directive`, etc.
* **SQL Example**:

  ```sql
  SELECT * FROM directive_paths WHERE id = ?;
  ```

#### 1.3. **Get Path by Name**

* **Function Name**: `get_directive_path_by_name`
* **Purpose**: Retrieves the details of a specific directive path by its `name`.
* **Parameters**: `path_name`
* **Returns**: A single record or `null` if no path is found.
* **SQL Example**:

  ```sql
  SELECT * FROM directive_paths WHERE name = ?;
  ```

#### 1.4. **Get Active Paths**

* **Function Name**: `get_active_directive_paths`
* **Purpose**: Retrieves all active directive paths that apply under current conditions.
* **Parameters**: `current_state` (for `applies_when` conditions)
* **Returns**: List of paths.
* **SQL Example**:

  ```sql
  SELECT * FROM directive_paths WHERE applies_when @> ?;
  ```

---

### **2. Helper Functions for `directive_path_steps` Table**

These functions focus on the steps inside a directive path, including ordering and conditions for branching.

#### 2.1. **Add Step to Path**

* **Function Name**: `add_step_to_directive_path`
* **Purpose**: Adds a new step to a directive path.
* **Parameters**: `path_id, step_order, directive_name, required, allows_branch, next_on_success, next_on_failure`
* **Returns**: `step_id`
* **SQL Example**:

  ```sql
  INSERT INTO directive_path_steps (path_id, step_order, directive_name, required, allows_branch, next_on_success, next_on_failure)
  VALUES (?, ?, ?, ?, ?, ?, ?);
  ```

#### 2.2. **Get Steps for Path**

* **Function Name**: `get_steps_for_directive_path`
* **Purpose**: Retrieves all steps for a specific directive path, ordered by `step_order`.
* **Parameters**: `path_id`
* **Returns**: List of steps in the correct order.
* **SQL Example**:

  ```sql
  SELECT * FROM directive_path_steps WHERE path_id = ? ORDER BY step_order;
  ```

#### 2.3. **Get Next Step in Path**

* **Function Name**: `get_next_step_in_path`
* **Purpose**: Retrieves the next valid step in a given directive path, based on `step_order`.
* **Parameters**: `path_id, current_step_order`
* **Returns**: Next step in the path.
* **SQL Example**:

  ```sql
  SELECT * FROM directive_path_steps 
  WHERE path_id = ? AND step_order > ? 
  ORDER BY step_order LIMIT 1;
  ```

#### 2.4. **Get Fallback Step**

* **Function Name**: `get_fallback_step`
* **Purpose**: Retrieves the fallback step for a given directive path when a failure occurs.
* **Parameters**: `path_id, current_step_id`
* **Returns**: The fallback step.
* **SQL Example**:

  ```sql
  SELECT * FROM directive_path_steps WHERE path_id = ? AND next_on_failure = ? LIMIT 1;
  ```

#### 2.5. **Get Branch Steps**

* **Function Name**: `get_branch_steps_for_directive_path`
* **Purpose**: Retrieves all steps that allow branching based on certain conditions.
* **Parameters**: `path_id`
* **Returns**: List of steps with `allows_branch = 1`.
* **SQL Example**:

  ```sql
  SELECT * FROM directive_path_steps WHERE path_id = ? AND allows_branch = 1;
  ```

---

### **3. Helper Functions for `directive_state_contracts` Table**

These functions allow the AI to understand what states a directive requires, produces, and invalidates.

#### 3.1. **Create/Update Directive State Contract**

* **Function Name**: `create_or_update_directive_state_contract`
* **Purpose**: Creates or updates the state contract for a directive.
* **Parameters**: `directive_name, requires_state, produces_state, invalidates_state`
* **Returns**: None
* **SQL Example**:

  ```sql
  INSERT INTO directive_state_contracts (directive_name, requires_state, produces_state, invalidates_state)
  VALUES (?, ?, ?, ?)
  ON CONFLICT(directive_name) DO UPDATE SET
      requires_state = excluded.requires_state,
      produces_state = excluded.produces_state,
      invalidates_state = excluded.invalidates_state;
  ```

#### 3.2. **Get Directive State Contract**

* **Function Name**: `get_directive_state_contract`
* **Purpose**: Retrieves the state contract for a given directive.
* **Parameters**: `directive_name`
* **Returns**: State contract JSON (includes `requires_state`, `produces_state`, `invalidates_state`)
* **SQL Example**:

  ```sql
  SELECT * FROM directive_state_contracts WHERE directive_name = ?;
  ```

#### 3.3. **Validate State for Directive**

* **Function Name**: `validate_state_for_directive`
* **Purpose**: Validates if a directive’s state contract allows it to be executed based on the current state.
* **Parameters**: `directive_name, current_state`
* **Returns**: Boolean (valid or invalid)
* **SQL Example**:

  ```sql
  SELECT CASE
      WHEN (SELECT produces_state FROM directive_state_contracts WHERE directive_name = ?) @> ? THEN 1
      ELSE 0
  END;
  ```

---

### **4. Helper Functions for Traversing Paths**

These functions help the AI traverse the paths and maintain context about its position.

#### 4.1. **Get Current Path for Project**

* **Function Name**: `get_current_directive_path_for_project`
* **Purpose**: Retrieves the currently active directive path for a specific project.
* **Parameters**: `project_id`
* **Returns**: `path_id`
* **SQL Example**:

  ```sql
  SELECT path_id FROM project_state WHERE project_id = ?;
  ```

#### 4.2. **Update Current Path for Project**

* **Function Name**: `update_current_path_for_project`
* **Purpose**: Updates the current directive path for a project, marking its progress.
* **Parameters**: `project_id, path_id`
* **Returns**: None
* **SQL Example**:

  ```sql
  UPDATE project_state SET path_id = ? WHERE project_id = ?;
  ```

#### 4.3. **Get Next Valid Step in Path for Project**

* **Function Name**: `get_next_valid_step_in_path_for_project`
* **Purpose**: Given the current step in a project, retrieves the next valid step in its path.
* **Parameters**: `project_id, current_step_order`
* **Returns**: Next step’s directive
* **SQL Example**:

  ```sql
  SELECT * FROM directive_path_steps WHERE path_id = (SELECT path_id FROM project_state WHERE project_id = ?) 
  AND step_order > ? ORDER BY step_order LIMIT 1;
  ```

---

### **General Utility Functions**

#### 5.1. **Get Directive Path Summary**

* **Function Name**: `get_directive_path_summary`
* **Purpose**: Retrieves a full summary of a directive path, including entry, exit, and steps.
* **Parameters**: `path_id`
* **Returns**: JSON summary (path details + steps)
* **SQL Example**:

  ```sql
  SELECT dp.name, dp.entry_directive, dp.exit_directive, json_group_array(dps.step_order || ': ' || dps.directive_name) AS steps
  FROM directive_paths dp
  JOIN directive_path_steps dps ON
  ```


dp.id = dps.path_id
WHERE dp.id = ?
GROUP BY dp.id;
```

---

### Final Thoughts

With these helper functions, you’ve removed the need for the AI to deal with the low-level complexity of querying the database directly. The AI simply calls a function like `get_next_valid_step_in_path_for_project()`, and it gets the right data back in a clean format, ready for use. This improves efficiency and reduces the cognitive load on the AI.

If you'd like to implement these functions, I can also help with writing them in a specific programming language or with more examples.


=======================================

Got it! So with this additional clarification, the focus should be on handling **non-FP directives** (i.e., **Project Management**, **Git Integration**, and **User Preference Directives**), which require structured **directive paths** for navigating project-related tasks, milestones, dependencies, etc.

In this case, the **FP** directives are more of a "background context" that AI can use as a guideline, but the majority of the heavy lifting and flow control comes from the other types of directives, which need to be organized into **paths** and **steps**.

### Refined Approach for Non-FP Directives

Let's shift focus to the non-FP directives, which need the **path-tree structure** to guide the AI through its project management tasks. Here's an updated and optimized approach.

---

### **1. Directive Path Structure**

Since the non-FP directives (particularly in **Project Management**, **Git Integration**, and **User Preference** categories) are the ones requiring explicit **paths**, we should focus on ensuring that these paths are **well-defined**, **modular**, and can guide AI through project-based workflows with minimal overhead.

* **Project Management Directives** will follow a **project lifecycle**: from creation, task assignment, completion, and archival.
* **Git Integration Directives** will have a flow based on typical version control operations (branch creation, merging, syncing).
* **User Preference Directives** will focus on tracking user settings, preferences, and data synchronization.

### **2. Path Tree Design for Non-FP Directives**

For these categories, paths will be built from tasks, dependencies, and state transitions. Each path represents a **linear or branching sequence** that guides the AI through the actions required to complete a specific part of the project.

#### **Project Management Path Example**

* **Path Name**: `project_task_management_path`
* **Steps**:

  * **Step 1**: `project_task_create` — Create a new task for the project.
  * **Step 2**: `project_task_update` — Update task status, assign resources, etc.
  * **Step 3**: `project_task_complete` — Mark task as completed.
  * **Step 4**: `project_milestone_complete` — Complete the milestone once all tasks are finished.
  * **Step 5**: `project_archive` — Archive project once completed.

Each **step** within the path may depend on previous tasks (like one task completing before another starts) or be independent, depending on the project structure.

#### **Git Integration Path Example**

* **Path Name**: `git_version_control_path`
* **Steps**:

  * **Step 1**: `git_init` — Initialize a Git repository for the project.
  * **Step 2**: `git_create_branch` — Create a new branch for the current feature or task.
  * **Step 3**: `git_sync_state` — Ensure local repository is synced with remote.
  * **Step 4**: `git_merge_branch` — Merge the feature branch back to main or master.
  * **Step 5**: `git_detect_conflicts` — Check for conflicts and resolve if necessary.

#### **User Preference Path Example**

* **Path Name**: `user_preferences_management_path`
* **Steps**:

  * **Step 1**: `user_preferences_sync` — Sync user preferences across devices.
  * **Step 2**: `user_preferences_update` — Update preferences for the user.
  * **Step 3**: `user_preferences_export` — Export user preferences to an external file.
  * **Step 4**: `user_preferences_import` — Import preferences from a previous version.

---

### **3. Optimized Helper Functions**

#### **3.1 Get Path for Directive Type**

We now want to focus on **Project Management**, **Git**, and **User Preference** directives. Each of these requires path management, and the helper functions need to allow AI to easily traverse and manage these paths.

#### **Get Path Steps for Project Management**:

* **Function Name**: `get_project_management_path_steps`
* **Purpose**: Retrieves all steps in the project management workflow (e.g., tasks, milestones, archives).
* **Parameters**: `project_id`
* **Returns**: List of steps for the given project.
* **SQL Example**:

  ```sql
  SELECT * 
  FROM directive_path_steps 
  WHERE path_id = (SELECT path_id FROM directive_paths WHERE path_name = 'project_task_management_path')
  ORDER BY step_order;
  ```

#### **Get Path for Git Integration**:

* **Function Name**: `get_git_integration_path_steps`
* **Purpose**: Retrieves steps related to Git operations (e.g., branch creation, merging).
* **Parameters**: `project_id`
* **Returns**: List of Git steps for the project.
* **SQL Example**:

  ```sql
  SELECT * 
  FROM directive_path_steps 
  WHERE path_id = (SELECT path_id FROM directive_paths WHERE path_name = 'git_version_control_path')
  ORDER BY step_order;
  ```

#### **Get Path for User Preferences**:

* **Function Name**: `get_user_preferences_path_steps`
* **Purpose**: Retrieves all steps in the user preferences management flow (e.g., sync, update, export).
* **Parameters**: `user_id`
* **Returns**: List of preference management steps.
* **SQL Example**:

  ```sql
  SELECT * 
  FROM directive_path_steps 
  WHERE path_id = (SELECT path_id FROM directive_paths WHERE path_name = 'user_preferences_management_path')
  ORDER BY step_order;
  ```

---

### **4. Path Validation and State Transitions**

AI needs to know whether a path step has been completed, and what the next step in the workflow should be. The **state contract** tables help track this.

#### **Validate Step Completion**

* **Function Name**: `validate_step_completion_for_project`
* **Purpose**: Validates if the step for the given project is completed.
* **Parameters**: `project_id`, `step_name`
* **Returns**: Boolean (True if the step is complete, False otherwise).
* **SQL Example**:

  ```sql
  SELECT CASE
      WHEN EXISTS (
          SELECT 1 FROM directive_path_steps 
          WHERE path_id = (SELECT path_id FROM directive_paths WHERE path_name = 'project_task_management_path') 
          AND directive_name = ? 
          AND status = 'completed'
      ) THEN 1 ELSE 0 END;
  ```

#### **Get Next Valid Step**

* **Function Name**: `get_next_valid_step_in_path`
* **Purpose**: Returns the next valid step in the directive path, based on the project's current state.
* **Parameters**: `project_id`, `current_step_name`
* **Returns**: Next valid step in the path.
* **SQL Example**:

  ```sql
  SELECT * 
  FROM directive_path_steps 
  WHERE path_id = (SELECT path_id FROM directive_paths WHERE path_name = 'project_task_management_path')
  AND step_order > (
      SELECT step_order FROM directive_path_steps WHERE path_id = (SELECT path_id FROM directive_paths WHERE path_name = 'project_task_management_path') 
      AND directive_name = ?
  )
  ORDER BY step_order LIMIT 1;
  ```

---

### **5. User Interface for AI**

To make this workflow smooth, it’s important to provide a simple **interface for AI** to interact with the database. The AI would typically query:

1. **What is the next step in the project path?**
2. **What dependencies exist for this task?**
3. **How do I proceed if I hit a roadblock?**

This interface abstracts away the complexity of manually managing queries for the AI, allowing it to focus on decision-making rather than backend database concerns.

---

### Conclusion

With this refined approach, the AI can:

* **Efficiently navigate through the project management paths** and related tasks using predefined paths and steps.
* **Avoid repetitive query construction** by utilizing helper functions and pre-structured paths.
* **Easily validate project states** and track progress through **project-specific paths** (e.g., Git operations, user preferences).
* Stay **FP-agnostic** for non-FP tasks while leveraging FP principles as context when necessary.

The key focus is on organizing non-FP workflows (project tasks, Git operations, and user preferences) into clear, modular paths with well-defined steps and state transitions. This way, the AI can focus on performing tasks and making decisions with minimal overhead, based on a clear set of directives.


===============================================

Thank you for the additional context! This significantly shifts the approach, especially when dealing with **user-defined directives** and their integration with **project management** and **Git workflows**. Here's an updated and refined approach considering these aspects:

---

### **1. Integration of User-Defined Directives**

Since **user-defined directives** are a key feature of your system, the **user_directives** database will play a critical role in allowing users to specify their own project management or automation tasks. These directives must be parsed and translated into actionable steps within the MCP server.

### **How the Approach Changes**

* **User-Defined Directives (UDDs)**: These are highly customizable and user-driven, so the system should support the following:

  * **Flexible Directive Parsing**: The AI should be able to parse and validate user inputs in different formats (CSV, JSON, YAML, etc.) and convert them into machine-readable forms (like the ones in your core directives database). The user can define the project's flow by specifying high-level tasks (e.g., "turn off lights at 9 pm"), which will then need to be mapped to specific actions (e.g., calling functions for controlling smart devices).
  * **Contextual Mapping**: Since user directives will likely span a variety of project management tasks (automation, home assistant control, etc.), there needs to be a dynamic mapping between user intents and the available system tools (e.g., project task management, Git operations, or even external API calls).

* **Git Integration for User Projects**: Since Git is part of the project management workflow, you’ll want to allow users to:

  * **Use Git for Version Control**: Manage their user-defined projects via Git, allowing multiple users or multiple AI agents to collaborate and contribute to the same project.
  * **Version Control for User-Defined Directives**: Track changes in user-defined directives over time. If a user updates their directive (e.g., changing the timing of a task like turning off lights), the system will need to manage this change history and allow for merge requests and version control like any other part of the project.

---

### **2. Revised Approach for User-Defined Directives**

The fundamental change is that **user directives need to be parsed**, and their **execution must be tied into the project management flow** seamlessly. The key here is the **integration of user-defined intents into the system’s operational flow**, which includes **Git workflows**, **project task management**, and the ability to **automate** or **control external systems**.

#### **Flow for User-Defined Directives**

1. **Directive Parsing & Validation**

   * **Input**: User submits their directive (e.g., in CSV, JSON, YAML).
   * **Processing**: AI parses and validates the directive, ensuring it's in an acceptable format.
   * **Transformation**: Convert the user’s high-level directive into one or more **core system tasks** (e.g., turning off the lights might trigger a smart home device API or call a scheduled task within a project).
   * **Storage**: Once validated, the user-defined directive is stored in the **user_directives** database, similar to how core directives are stored in the **core database**.

2. **Mapping User Directives to System Tools**

   * **Mapping**: The system maps user-defined actions to internal **helper functions** or **predefined workflows**. For instance:

     * "Turn off lights at 9 pm" → Call an internal smart-home API or schedule a task for 9 pm.
     * "Manage Home Assistant" → Trigger the creation of a set of predefined tasks related to Home Assistant automation.

3. **Execution and Integration with Git & Project Management**

   * **Git Integration**: If the directive involves changes to the project itself (e.g., adding new tasks, modifying automation), it will be treated as a **commit** in the Git repository.

     * **Git Workflow**: Once the directive is parsed and ready, the system will initiate a **Git commit** for the new directive and track it.
     * **Merge Requests**: If a user (or AI) wants to modify the project, a **merge request** is created, ensuring that changes in user directives can be reviewed, tracked, and merged appropriately.

4. **User Directive Path Management**

   * **Directive Paths**: For each user directive (e.g., "turn off lights at 9 pm"), the system should automatically create a **path** (using the same **path steps** model) that guides the AI through all required actions to achieve that task. This could involve:

     * Task scheduling (e.g., cron jobs or timers).
     * Git operations (e.g., committing changes).
     * Interaction with external APIs (e.g., smart home control).
   * These paths can be dynamic, based on the user’s preferences and the specific nature of their directive.

---

### **3. Revised Helper Functions for User-Defined Directives**

Given the added flexibility of user-defined directives, the helper functions need to not only manage core system tasks but also support the dynamic **integration of user input** and **version control**.

#### **3.1 User Directive Parsing and Mapping**

* **Function Name**: `parse_user_directive`

* **Purpose**: Parses the user's directive (in CSV, JSON, YAML) and converts it into a machine-readable structure.

* **Parameters**: `directive_input (CSV/JSON/YAML)`, `user_id`

* **Returns**: Parsed directive as a JSON object.

* **SQL Example**:

  ```sql
  INSERT INTO user_directives (user_id, directive_name, directive_data, status) 
  VALUES (?, ?, ?, 'parsed');
  ```

* **Function Name**: `map_user_directive_to_system_task`

* **Purpose**: Maps the user directive to a system task (e.g., create a new task, invoke a smart home API, or schedule a Git commit).

* **Parameters**: `user_directive_id`, `directive_data`

* **Returns**: List of system tasks.

* **SQL Example**:

  ```sql
  SELECT * 
  FROM system_tasks 
  WHERE task_type = 'home_automation' AND action = ?
  ```

#### **3.2 Git Integration for User Projects**

* **Function Name**: `git_commit_user_directive_change`

* **Purpose**: Creates a Git commit for the changes associated with a user directive.

* **Parameters**: `user_directive_id`, `commit_message`, `user_id`

* **Returns**: Git commit ID.

* **SQL Example**:

  ```sql
  INSERT INTO git_commits (project_id, commit_message, user_id, directive_id, status) 
  VALUES (?, ?, ?, ?, 'pending');
  ```

* **Function Name**: `git_merge_user_directive_changes`

* **Purpose**: Creates a merge request for the user directive changes and integrates it into the main project.

* **Parameters**: `user_directive_id`, `git_branch`, `commit_id`

* **Returns**: Merge request status.

* **SQL Example**:

  ```sql
  INSERT INTO git_merge_requests (project_id, git_branch, commit_id, status) 
  VALUES (?, ?, ?, 'open');
  ```

#### **3.3 User Task Management and Workflow**

* **Function Name**: `get_user_directive_workflow_steps`
* **Purpose**: Retrieves the workflow steps for a given user directive.
* **Parameters**: `user_directive_id`
* **Returns**: List of steps for executing the user directive (tasks, scheduling, external API calls).
* **SQL Example**:

  ```sql
  SELECT * 
  FROM directive_path_steps 
  WHERE directive_id = ? 
  ORDER BY step_order;
  ```

---

### **4. State Management for User-Defined Projects**

The **state management** aspect becomes particularly important for user-defined projects, especially when users want to see the **current status** of their tasks, **progress** on directives, and whether their **Git commits** have been successfully integrated.

#### **Function to Track User Directive Status**

* **Function Name**: `get_user_directive_status`
* **Purpose**: Tracks the status of a user directive, from initial parsing to completion.
* **Parameters**: `user_directive_id`
* **Returns**: Status (e.g., 'pending', 'in-progress', 'completed', 'failed').
* **SQL Example**:

  ```sql
  SELECT status 
  FROM user_directives 
  WHERE user_directive_id = ?;
  ```

---

### **Conclusion**

With this new understanding, your system will need to manage **user-defined workflows**, **Git integration**, and **version control** for dynamic user inputs. The goal is to ensure the AI can **parse, validate, and transform** user directives into executable tasks within the project while maintaining clear **version control** through Git.

* **Path Management**: For each user directive, AI can create a path and define the necessary steps.
* **User Git Workflow**: Git will be integrated into the user directive lifecycle, with commit and merge request functionality.
* **Flexible Parsing**: User directives (in CSV, JSON, YAML) will be parsed and mapped to actionable system tasks, ensuring a high degree of flexibility and adaptability for different use cases (e.g., home assistant automation).
* **Helper Functions**: These will assist in parsing, mapping, and executing user-defined tasks and Git operations.

This revised approach ensures that user-defined directives are **seamlessly integrated into the broader project management system** while maintaining **flexibility and clarity** for both AI and users.
