{
  "metadata": {
    "version": "1.0.0",
    "last_updated": "2025-11-26",
    "description": "User Directives Database helpers - Custom user directives and automation",
    "database": "user_directives.db",
    "total_helpers": 4,
    "schema_version": "1.0",
    "notes": "This registry is for import into MCP database. Helpers reference directives (not vice versa)."
  },
  "helper_schema": {
    "description": "Schema definition for helper entries",
    "fields": {
      "name": "Function name",
      "file_path": "Path to implementation file",
      "database": "Which database this helper operates on",
      "purpose": "Detailed description of what this helper does",
      "parameters": "Array of parameter objects with name and type",
      "return_statements": "Array of AI behavioral guidance - what to check/do next after calling this helper",
      "error_handling": "How errors are handled",
      "used_by_directives": "Array of directive names that use this helper",
      "is_tool": "Boolean - exposed via MCP as tool",
      "is_sub_helper": "Boolean - internal utility helper not directly called by AI/directives",
      "calls_helpers": "Array of helper names this function calls",
      "category": "Functional category"
    }
  },
  "database": "user_directives.db",
  "file_location": "src/aifp/helpers/user_directives/",
  "helpers": [
    {
      "name": "parse_directive_file",
      "file_path": "src/aifp/helpers/user_directives/tools/parsing_tools.py",
      "database": "user_directives.db",
      "purpose": "Parse user directive file and extract directives with ambiguity detection. Identifies missing parameters, unclear triggers, and required dependencies.",
      "parameters": [
        {
          "name": "file_path",
          "type": "str",
          "required": true,
          "description": "Path to user directive file"
        },
        {
          "name": "file_format",
          "type": "str",
          "required": false,
          "default": "auto",
          "description": "File format (yaml, json, md, auto)"
        }
      ],
      "return_statements": [
        "If success=false, review error and guide user to fix file syntax/format issues",
        "Review ambiguities array - these need resolution before directive can be implemented",
        "If missing_fields present, required information is missing - escalate to user_directive_validate for interactive resolution",
        "Review warnings - these are non-blocking but should be discussed with user",
        "After successful parse with no ambiguities, can proceed to user_directive_implement"
      ],
      "error_handling": "Log parse errors to `.aifp/logs/errors/` and prompt user for manual correction.",
      "used_by_directives": ["user_directive_parse"],
      "is_tool": false,
      "is_sub_helper": false,
      "calls_helpers": [],
      "category": "user_directive_parsing"
    },
    {
      "name": "validate_user_directive",
      "file_path": "src/aifp/helpers/user_directives/tools/validation_tools.py",
      "database": "user_directives.db",
      "purpose": "Validate directive through interactive Q&A to resolve ambiguities. Presents clarifying questions, stores answers, and generates validated configuration.",
      "parameters": [
        {
          "name": "directive",
          "type": "dict",
          "required": true,
          "description": "Directive object to validate"
        },
        {
          "name": "interactive",
          "type": "bool",
          "required": false,
          "default": true,
          "description": "Whether to prompt user interactively"
        }
      ],
      "return_statements": [
        "If success=false, review remaining_issues and either ask more questions or prompt user for manual clarification",
        "If success=true, validated_directive is ready for implementation - proceed to user_directive_implement or generate_implementation_code",
        "Review ambiguities_resolved count to understand how much was clarified",
        "If interactive=false and issues remain, must enable interactive mode or get user to provide missing info another way"
      ],
      "error_handling": "Log validation errors and retry with simpler questions.",
      "used_by_directives": ["user_directive_validate"],
      "is_tool": false,
      "is_sub_helper": false,
      "calls_helpers": ["parse_directive_file"],
      "category": "user_directive_validation"
    },
    {
      "name": "activate_directive",
      "file_path": "src/aifp/helpers/user_directives/tools/activation_tools.py",
      "database": "user_directives.db",
      "purpose": "Deploy and activate directive implementation for real-time execution. Starts schedulers, background services, or event handlers. Initializes logging and execution tracking.",
      "parameters": [
        {
          "name": "directive_id",
          "type": "int",
          "required": true,
          "description": "ID of directive to activate"
        }
      ],
      "return_statements": [
        "If success=false, directive failed to activate - review error and check if dependencies missing or implementation issues",
        "If success=true and pid present, background process is running - inform user they can monitor via log_path",
        "After activation, directive is live and will execute based on its trigger conditions",
        "Inform user where logs can be found for monitoring directive execution",
        "Consider escalating to user_directive_monitor to track execution health"
      ],
      "error_handling": "Rollback activation, stop any started services, log error.",
      "used_by_directives": ["user_directive_activate"],
      "is_tool": false,
      "is_sub_helper": false,
      "calls_helpers": ["validate_user_directive"],
      "category": "user_directive_lifecycle"
    },
    {
      "name": "deactivate_directive",
      "file_path": "src/aifp/helpers/user_directives/tools/activation_tools.py",
      "database": "user_directives.db",
      "purpose": "Stop directive execution and clean up resources. Gracefully stops services (SIGTERM), force kills if necessary (SIGKILL). Preserves execution statistics.",
      "parameters": [
        {
          "name": "directive_id",
          "type": "int",
          "required": true,
          "description": "ID of directive to deactivate"
        }
      ],
      "return_statements": [
        "If success=false, process may still be running - may need manual intervention to kill process",
        "If forced_kill=true, graceful shutdown failed - check if directive implementation has issues with signal handling",
        "Review execution_stats to show user how many times directive executed and if errors occurred",
        "Inform user directive is now inactive and will not execute on triggers",
        "Statistics are preserved even after deactivation - can be reviewed later"
      ],
      "error_handling": "Force kill processes if graceful shutdown fails.",
      "used_by_directives": ["user_directive_deactivate"],
      "is_tool": false,
      "is_sub_helper": false,
      "calls_helpers": [],
      "category": "user_directive_lifecycle"
    }
  ]
}
