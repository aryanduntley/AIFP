{
  "helpers": [
	{
      "name": "reserve_type",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Type name (will have _idxxx appended)"
        },
        {
          "name": "definition_json",
          "type": "object",
          "required": true,
          "default": null,
          "description": "ADT definition (e.g., {'type': 'enum', 'variants': ['A', 'B']})"
        },
        {
          "name": "description",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Type description"
        },
        {
          "name": "links",
          "type": "object",
          "required": false,
          "default": null,
          "description": "Links to related functions"
        },
        {
          "name": "file_id",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "File ID where type is defined"
        }
      ],
      "purpose": "Reserve type ID for naming before creation",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Creates type entry with is_reserved=1 - type not yet defined in code",
        "DATABASE CONTEXT: Returned ID MUST be embedded in type name using _idxxx suffix pattern (e.g., Maybe_id7, Result_id23)",
        "DATABASE CONTEXT: Reserved types excluded from type-function relationship tracking until finalized",
        "NEXT STEP: Write type definition in code with reserved ID embedded in name: {TypeName}_id{id}",
        "NEXT STEP: After type written, finalize reservation within project_reserve_finalize directive",
        "NEXT STEP: After finalization, link type to operating functions (factory/transformer/validator functions)",
        "CHECK: Did you embed the ID in the type name correctly? Pattern is: TypeName_idxxx",
        "CHECK: Is this an ADT? definition_json should specify type (enum/struct/union) and variants/fields",
        "CHECK: Which functions operate on this type? Plan to track factory/transformer/validator relationships after finalization",
        "DIRECTIVE CONTEXT: Called by project_reserve_finalize (sequence_order: 1, execution_context: reserve_type_name)",
        "DIRECTIVE CONTEXT: First step in reservation phase - happens BEFORE code writing",
        "DIRECTIVE FLOW: project_file_write → project_reserve_finalize → reserve_type (this) → write code → finalize → project_update_db",
        "DIRECTIVE FLOW: After project_reserve_finalize completes, flow proceeds to project_update_db for database sync",
        "WORKFLOW PATTERN: Reserve type ID → write type with ID in name → finalize type → link type-function relationships → DB sync",
        "COMMON WORKFLOWS: Defining ADTs → reserve type ID → write enum/struct/union → finalize → track constructor/pattern-match functions",
        "WARNING: Type MUST be defined with ID in name - this enables instant lookups without fragile name dependencies",
        "WARNING: Finalization happens after code writing - reservation allows conflict-free ID allocation"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_reserve_finalize",
          "execution_context": "reserve_type_name",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Reserve type ID before writing code - AI embeds ID in type name for instant lookups (TypeName_id_7)"
        }
      ],
      "implementation_notes": [
        "Returns {success: true, id: reserved_id, is_reserved: true}",
        "SQL: INSERT INTO types (name, definition_json, description, links, file_id, is_reserved) VALUES (?, ?, ?, ?, ?, 1) RETURNING id",
        "Type name pattern: {TypeName}_id{id} (e.g., Maybe_id7, Result_id23, User_id42)"
      ]
    },
    {
      "name": "reserve_types",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "types",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of type objects [{name, definition_json, description, links, file_id}, ...]"
        }
      ],
      "purpose": "Reserve multiple type IDs",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Batch version of reserve_type() - atomically reserves multiple type IDs at once",
        "DATABASE CONTEXT: All types created with is_reserved=1 - more efficient than multiple reserve_type() calls",
        "NEXT STEP: Define all types with their reserved IDs embedded in names using _idxxx pattern",
        "NEXT STEP: After all types defined, call finalize_types() with batch of type metadata objects",
        "CHECK: IDs returned in same order as types array - map IDs back to type objects correctly",
        "CHECK: Are all types related ADTs? Batch operations typically used for type systems (Maybe/Either/Result)",
        "RELATED HELPERS: finalize_types() for batch finalization after defining all types",
        "RELATED HELPERS: Use reserve_type() for single type operations instead of batch with one element",
        "WORKFLOW: reserve_types([...]) → define all types with IDs → finalize_types([...]) → add_types_functions() batch",
        "DIRECTIVE CONTEXT: Not directly used by directives - utility for batch operations when creating multiple related types",
        "COMMON WORKFLOWS: Building type system (Option/Result/Either) → reserve_types() → define all → finalize batch",
        "WARNING: Batch operations are all-or-nothing - if any type reservation fails, entire operation fails"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns {success: true, ids: [id1, id2, ...]} in same order as input types array",
        "SQL: Multiple INSERT INTO types ... RETURNING id (in transaction)",
        "IDs correspond to types array indices: types[0] gets ids[0], types[1] gets ids[1], etc."
      ]
    },
    {
      "name": "finalize_type",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "type_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Reserved type ID"
        },
        {
          "name": "name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Final name with _idxx suffix"
        },
        {
          "name": "definition_json",
          "type": "object",
          "required": true,
          "default": null,
          "description": "ADT definition"
        },
        {
          "name": "description",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Type description"
        },
        {
          "name": "links",
          "type": "object",
          "required": false,
          "default": null,
          "description": "Links to related functions"
        },
        {
          "name": "file_id",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "File ID where type is defined"
        }
      ],
      "purpose": "Finalize reserved type after creation",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Completes type reservation - sets is_reserved=0 after type defined in code",
        "DATABASE CONTEXT: Name must include _idxxx suffix matching reserved ID (e.g., Maybe_id7, Result_id42)",
        "DATABASE CONTEXT: Automatically updates parent file timestamp to track modifications",
        "NEXT STEP: After finalization, type becomes tracked in project database and available for queries",
        "NEXT STEP: Link type to operating functions (factory/transformer/validator) via types_functions table",
        "CHECK: Name parameter must include _idxxx suffix matching the reserved ID",
        "CHECK: Definition_json should contain complete ADT structure (constructors, fields, variants)",
        "CHECK: File_id should reference file where type is defined",
        "DIRECTIVE CONTEXT: Called by project_reserve_finalize (sequence_order: 2, execution_context: finalize_reservation)",
        "DIRECTIVE CONTEXT: Second step in reservation phase - happens AFTER code writing, completes reservation",
        "DIRECTIVE FLOW: project_reserve_finalize → reserve IDs (seq 1) → write code → finalize (this, seq 2) → project_update_db",
        "DIRECTIVE FLOW: After finalization complete, project_reserve_finalize flows to project_update_db for database sync",
        "WORKFLOW PATTERN: Reserve type → write type definition → finalize type → link type-function relationships → DB sync",
        "COMMON WORKFLOWS: Write ADT definition → finalize_type(name='Maybe_id7', definition_json={constructors}) → link factory functions",
        "WARNING: Must finalize after type actually exists in code - finalization marks it as non-reserved and enables tracking"
      ],
      "implementation_notes": [
        "Returns: {success: true, type_id: int, file_id: int}",
        "Sets is_reserved=0 in types table",
        "Calls update_file_timestamp(file_id) automatically",
        "Definition_json stores ADT structure for FP analysis"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_reserve_finalize",
          "execution_context": "finalize_reservation",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Finalize type after code written - sets is_reserved=false and updates file timestamp"
        }
      ]
    },
    {
      "name": "finalize_types",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "types",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of type objects [{type_id, name, definition_json, description, links, file_id}, ...]"
        }
      ],
      "purpose": "Finalize multiple reserved types",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Batch finalization - efficient bulk completion of multiple type reservations",
        "DATABASE CONTEXT: Sets is_reserved=0 for all types, updates file timestamps once per file",
        "NEXT STEP: Use for bulk type definitions - more efficient than multiple finalize_type() calls",
        "CHECK: Each type object must include: {type_id, name (with _idxxx), definition_json, file_id}",
        "CHECK: Optimizes file timestamp updates - one update per file instead of per type",
        "RELATED HELPERS: finalize_type() for single type finalization",
        "RELATED HELPERS: reserve_types() for batch reservation before code generation",
        "WORKFLOW: reserve_types() → define all types in code → finalize_types() → bulk completion",
        "COMMON WORKFLOWS: Generate ADT module with 10 types → finalize_types() → efficient batch update"
      ],
      "implementation_notes": [
        "Returns: {success: true, finalized_ids: [int, ...]}",
        "Groups types by file_id for efficient timestamp updates",
        "Sets is_reserved=0 for all types in batch"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "update_type",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "type_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Type ID to update"
        },
        {
          "name": "name",
          "type": "string",
          "required": false,
          "default": null,
          "description": "New name (NULL = don't update)"
        },
        {
          "name": "file_id",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "New file_id (NULL = don't update)"
        },
        {
          "name": "definition_json",
          "type": "object",
          "required": false,
          "default": null,
          "description": "New definition (NULL = don't update)"
        },
        {
          "name": "description",
          "type": "string",
          "required": false,
          "default": null,
          "description": "New description (NULL = don't update)"
        }
      ],
      "purpose": "Update type metadata",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Updates type metadata - name, file location, definition, or description",
        "DATABASE CONTEXT: Automatically updates file timestamp after modification",
        "NEXT STEP: All parameters optional - only provide fields that need updating",
        "NEXT STEP: After update, file timestamp refreshed to track modifications",
        "CHECK: Name updates must maintain _idxxx suffix format",
        "CHECK: File_id updates move type to different file (rare - use cautiously)",
        "RELATED HELPERS: update_file_timestamp() called automatically after update",
        "WORKFLOW: Refactor type definition → update_type(definition_json) → timestamp refreshed",
        "COMMON WORKFLOWS: Rename type → update_type(name='NewName_id7')",
        "COMMON WORKFLOWS: Update ADT definition → update_type(definition_json={new_structure})"
      ],
      "implementation_notes": [
        "Returns: {success: true, type_id: int, file_id: int}",
        "NULL parameters = don't update that field",
        "Calls update_file_timestamp(file_id) automatically"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "delete_type",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "type_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Type ID to delete"
        },
        {
          "name": "note_reason",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Deletion reason"
        },
        {
          "name": "note_severity",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'info', 'warning', 'error'"
        },
        {
          "name": "note_source",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'ai' or 'user'"
        },
        {
          "name": "note_type",
          "type": "string",
          "required": true,
          "default": "entry_deletion",
          "description": "'entry_deletion'"
        }
      ],
      "purpose": "Delete type with relationship validation",
      "error_handling": "Return error if types_functions exist - requires manual unlinking first",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "NEXT STEP: After successful deletion, remove type definition from filesystem file",
        "NEXT STEP: Search codebase for references to this type - update or remove broken references",
        "NEXT STEP: File timestamp automatically refreshed after type deletion",
        "CHECK: Were functions using this type? Update their type annotations to remove references",
        "CHECK: Was this type exported/imported? Remove from import/export statements",
        "DATABASE CONTEXT: Type entry deleted, audit logged to notes table with reason, severity, source",
        "DATABASE CONTEXT: Deletion only succeeds after all types_functions entries manually unlinked",
        "RELATED HELPERS: delete_type_function() to remove type-function relationships before deletion",
        "RELATED HELPERS: get_type_functions_by_type() to see what relationships need unlinking",
        "WORKFLOW: Query types_functions → delete relationships with delete_type_function() → retry delete_type() → success",
        "COMMON WORKFLOWS: After deletion, remove type from filesystem, verify file timestamp updated, check for orphaned references",
        "WARNING: Deletion is permanent - type entry removed from database with no undo"
      ],
      "implementation_notes": [
        "ERROR LOGIC: Query types_functions WHERE type_id=? - if not empty, return error with function relationships list",
        "ERROR RETURN: {success: false, error: 'types_functions_exist', function_relationships: [{function_id, function_name, role}, ...]}",
        "ERROR MESSAGE: 'Cannot delete type - function relationships exist. Delete types_functions entries first, then retry'",
        "SUCCESS LOGIC: Only proceed if types_functions check returns empty",
        "SUCCESS LOGIC: Get file_id before deletion: SELECT file_id FROM types WHERE id=type_id",
        "SUCCESS LOGIC: Create note entry in notes table with reason, severity, source, type, reference details",
        "SUCCESS LOGIC: Delete type: DELETE FROM types WHERE id=type_id",
        "SUCCESS RETURN: {success: true, deleted_type_id: type_id, file_id: file_id}",
        "NOTE: types_functions must be manually unlinked first"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "add_types_functions",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "relationships",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of tuples [(type_id, function_id, role), ...] - role: 'factory', 'transformer', 'operator', 'pattern_matcher', 'accessor', 'validator', 'combinator'"
        }
      ],
      "purpose": "Add type-function relationship(s)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Links types to functions with semantic roles for FP analysis",
        "DATABASE CONTEXT: Roles: 'factory' (constructors), 'transformer', 'operator', 'pattern_matcher', 'accessor', 'validator', 'combinator'",
        "NEXT STEP: After linking, types and functions tracked together in FP analysis",
        "NEXT STEP: Roles help understand function purpose in type's lifecycle",
        "CHECK: Relationships format: [(type_id, function_id, role), ...] - can pass multiple in one call",
        "CHECK: Factory role = constructors (e.g., Just, Nothing for Maybe)",
        "CHECK: Accessor role = getters (e.g., fromJust)",
        "CHECK: Transformer role = mappers (e.g., fmap for Maybe)",
        "RELATED HELPERS: finalize_type() followed by add_types_functions() to link constructor/accessor functions",
        "RELATED HELPERS: update_type_function_role() to change role classification",
        "RELATED HELPERS: delete_type_function() to remove relationship",
        "WORKFLOW: Define ADT + functions → finalize both → add_types_functions() to link semantics",
        "COMMON WORKFLOWS: Maybe type with Just/Nothing constructors → add_types_functions([(7, 42, 'factory'), (7, 43, 'factory')])",
        "COMMON WORKFLOWS: Link accessor function → add_types_functions([(type_id, func_id, 'accessor')])"
      ],
      "implementation_notes": [
        "Returns: {success: true, ids: [int, ...]} - inserted relationship IDs",
        "For single relationship: pass [(type_id, function_id, role)]",
        "Roles help FP analysis understand type usage patterns",
        "Inserts into types_functions table"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "update_type_function_role",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "type_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Type ID"
        },
        {
          "name": "function_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Function ID"
        },
        {
          "name": "role",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'factory', 'transformer', 'operator', 'pattern_matcher', 'accessor', 'validator', 'combinator'"
        }
      ],
      "purpose": "Update relationship role only",
      "error_handling": "",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Updates only the role field for existing type-function relationship",
        "DATABASE CONTEXT: Not exposed as MCP tool (is_tool: false) - internal helper",
        "NEXT STEP: Use when function role classification changes (e.g., 'factory' → 'transformer')",
        "NEXT STEP: For other changes (type_id or function_id), delete old relationship and add new",
        "CHECK: Only updates role - cannot change type_id or function_id with this helper",
        "RELATED HELPERS: add_types_functions() to create relationships",
        "RELATED HELPERS: delete_type_function() to remove relationships",
        "WORKFLOW: Reclassify function role → update_type_function_role(new_role)",
        "COMMON WORKFLOWS: Function refactored from accessor to transformer → update_type_function_role('transformer')"
      ],
      "implementation_notes": [
        "Returns: {success: true}",
        "Updates role field only in types_functions table",
        "For type_id/function_id changes: delete + add new"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "delete_type_function",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "types_functions junction table ID"
        },
        {
          "name": "note_reason",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Deletion reason"
        },
        {
          "name": "note_severity",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'info', 'warning', 'error'"
        },
        {
          "name": "note_source",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'ai' or 'user'"
        },
        {
          "name": "note_type",
          "type": "string",
          "required": true,
          "default": "entry_deletion",
          "description": "'entry_deletion'"
        }
      ],
      "purpose": "Remove type-function relationship",
      "error_handling": "",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Removes type-function relationship with audit trail",
        "DATABASE CONTEXT: Not exposed as MCP tool (is_tool: false) - internal helper",
        "NEXT STEP: Use before deleting type if types_functions relationships exist",
        "NEXT STEP: Requires note metadata for audit trail (reason, severity, source)",
        "CHECK: ID parameter is types_functions junction table ID (not type_id or function_id)",
        "CHECK: Must provide note_reason, note_severity, note_source for audit trail",
        "RELATED HELPERS: delete_type() validates no relationships exist before deletion",
        "RELATED HELPERS: add_types_functions() to recreate relationships if needed",
        "WORKFLOW: Before delete_type() → delete_type_function() first → then delete_type()",
        "COMMON WORKFLOWS: Remove type-function link → delete_type_function(junction_id, reason, ...)"
      ],
      "implementation_notes": [
        "Returns: {success: true}",
        "Deletes from types_functions table",
        "Creates note record for audit trail"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "add_interaction",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "source",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Source function name"
        },
        {
          "name": "target",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Target function name"
        },
        {
          "name": "type",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Interaction type"
        }
      ],
      "purpose": "Add function dependency/interaction",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Tracks function dependencies/interactions for FP analysis and dependency mapping",
        "DATABASE CONTEXT: Type parameter: 'call', 'chain', 'borrow', 'compose', 'pipe' - describes relationship nature",
        "NEXT STEP: After adding interaction, relationship tracked for refactoring impact analysis",
        "NEXT STEP: Helps understand function dependency chains and identify potential side effects",
        "CHECK: Source and target are function names (not IDs) - resolved to IDs internally",
        "CHECK: Type describes relationship: call=direct invocation, compose=function composition, chain=monadic chain, etc.",
        "DATABASE: For batch operations, use batch interaction insertion (more efficient for multiple relationships)",
        "DIRECTIVE CONTEXT: Called by project_update_db (sequence_order: 4, execution_context: add_function_interactions)",
        "DIRECTIVE CONTEXT: Fourth step in DB sync - happens after files, functions, types are synced",
        "DIRECTIVE FLOW: project_file_write → project_reserve_finalize → project_update_db → add_interaction (this, seq 4)",
        "DIRECTIVE FLOW: project_update_db sequences: sync files (1) → functions (2,3) → interactions (this, 4) → complete",
        "WORKFLOW PATTERN: Generate code → finalize reservations → sync database → track function dependencies (this)",
        "COMMON WORKFLOWS: Function A calls Function B → add_interaction(source='A', target='B', type='call')",
        "COMMON WORKFLOWS: Compose functions → add_interaction(source='compose_AB', target='A', type='compose')"
      ],
      "implementation_notes": [
        "Returns: {success: true, id: int} - new interaction ID",
        "Inserts into interactions table",
        "Source/target are function names - resolved to IDs internally"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_update_db",
          "execution_context": "add_function_interactions",
          "sequence_order": 4,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Track function dependencies after code generation - creates interaction records for function relationships"
        }
      ]
    },
    {
      "name": "add_interactions",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "interactions",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of tuples [(source_function_id, target_function_id, interaction_type, description), ...] - type: 'call', 'chain', 'borrow', 'compose', 'pipe'"
        }
      ],
      "purpose": "Add multiple interactions at once",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Batch insertion of function dependencies - efficient for bulk operations",
        "DATABASE CONTEXT: Types: 'call', 'chain', 'borrow', 'compose', 'pipe' - describes relationship nature",
        "NEXT STEP: Use after code generation to track all dependencies in one call",
        "CHECK: Interactions format: [(source_function_id, target_function_id, interaction_type, description), ...]",
        "CHECK: Uses function IDs (not names) unlike add_interaction()",
        "RELATED HELPERS: add_interaction() for single relationship (uses function names)",
        "WORKFLOW: After generating module with dependencies → add_interactions() → bulk insert all relationships",
        "COMMON WORKFLOWS: Batch dependency tracking → add_interactions([(1, 2, 'call', '...'), (2, 3, 'chain', '...')])"
      ],
      "implementation_notes": [
        "Returns: {success: true, ids: [int, ...]} - inserted interaction IDs",
        "Uses function IDs (not names)",
        "More efficient than multiple add_interaction() calls"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "update_interaction",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Interaction ID"
        },
        {
          "name": "source_function_id",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "New source (NULL = don't update)"
        },
        {
          "name": "target_function_id",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "New target (NULL = don't update)"
        },
        {
          "name": "interaction_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "'call', 'chain', 'borrow', 'compose', 'pipe' (NULL = don't update)"
        },
        {
          "name": "description",
          "type": "string",
          "required": false,
          "default": null,
          "description": "New description (NULL = don't update)"
        }
      ],
      "purpose": "Update interaction metadata",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Updates interaction metadata - source, target, type, or description",
        "NEXT STEP: All parameters optional - only provide fields needing update",
        "CHECK: Can update source/target function IDs (change relationship endpoints)",
        "CHECK: Can update interaction type ('call' → 'compose', etc.)",
        "RELATED HELPERS: add_interaction() to create new relationships",
        "RELATED HELPERS: delete_interaction() to remove relationships",
        "WORKFLOW: Refactor dependency → update_interaction(id, interaction_type='compose')",
        "COMMON WORKFLOWS: Change interaction type → update_interaction(id, interaction_type='chain')"
      ],
      "implementation_notes": [
        "Returns: {success: true}",
        "NULL parameters = don't update that field",
        "Updates interactions table"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "delete_interaction",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Interaction ID"
        },
        {
          "name": "note_reason",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Deletion reason"
        },
        {
          "name": "note_severity",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'info', 'warning', 'error'"
        },
        {
          "name": "note_source",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'ai' or 'user'"
        },
        {
          "name": "note_type",
          "type": "string",
          "required": true,
          "default": "entry_deletion",
          "description": "'entry_deletion'"
        }
      ],
      "purpose": "Delete interaction",
      "error_handling": "",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Deletes function interaction/dependency with audit trail",
        "DATABASE CONTEXT: Not exposed as MCP tool (is_tool: false) - internal helper",
        "NEXT STEP: Requires note metadata for audit trail (reason, severity, source)",
        "CHECK: ID is interaction ID from interactions table",
        "CHECK: Must provide note_reason, note_severity, note_source for audit trail",
        "RELATED HELPERS: add_interaction() to create relationships",
        "RELATED HELPERS: update_interaction() to modify relationships",
        "WORKFLOW: Remove dependency → delete_interaction(id, reason='dependency removed', ...)",
        "COMMON WORKFLOWS: Refactor removes function call → delete_interaction(id, note_reason='call removed')"
      ],
      "implementation_notes": [
        "Returns: {success: true}",
        "Deletes from interactions table",
        "Creates note record for audit trail"
      ],
      "target_database": "project",
      "used_by_directives": []
    }
  ],
  "metadata": {
    "file": "helpers-project-4.json",
    "count": 13,
    "range": "helpers 36-48 of 112",
    "description": "Type reservation/finalization, type-function relationships, and interaction management",
    "first_helper": "reserve_type",
    "last_helper": "delete_interaction",
    "status": "return_statements enhanced - ready for review",
    "last_updated": "2025-12-29"
  }
}