{
  "helpers": [
    {
      "name": "reserve_file",
      "file_path": "helpers/project/files_1.py",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Preliminary file name (will have _id_xxx appended)"
        },
        {
          "name": "path",
          "type": "string",
          "required": true,
          "default": null,
          "description": "File path relative to project root"
        },
        {
          "name": "language",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Programming language (e.g., 'python', 'javascript', 'typescript')"
        }
      ],
      "purpose": "Reserve file ID for naming before creation",
      "error_handling": "Return error if path already exists",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Use returned ID for file naming: {name}_id_{id}.{ext}"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_reserve_finalize",
          "execution_context": "reserve_file_name",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Reserve file ID before writing code - AI embeds ID in filename for instant lookups (filename_id_42.py)"
        },
        {
          "directive_name": "project_file_write",
          "execution_context": "reserve_before_write",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Reserve file ID before generating file content - enables rename-proof references"
        }
      ],
      "implementation_notes": [
        "Returns {success: true, id: reserved_id, is_reserved: true}",
        "SQL: INSERT INTO files (name, path, language, is_reserved) VALUES (?, ?, ?, 1) RETURNING id",
        "Filename pattern: {name}_id_{id}.{extension} (e.g., calculator_id_42.py, utils_id_15.js)"
      ]
    },
    {
      "name": "reserve_files",
      "file_path": "helpers/project/files_1.py",
      "parameters": [
        {
          "name": "files",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of file objects [{name, path, language}, ...]"
        }
      ],
      "purpose": "Reserve multiple file IDs at once",
      "error_handling": "Return error if any path already exists",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Use returned IDs for file naming: {name}_id_{id}.{ext}"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns {success: true, ids: [id1, id2, ...]} in same order as input files array",
        "SQL: Multiple INSERT INTO files ... RETURNING id (in transaction)",
        "IDs correspond to files array indices: files[0] gets ids[0], files[1] gets ids[1], etc."
      ]
    },
    {
      "name": "finalize_file",
      "file_path": "helpers/project/files_1.py",
      "parameters": [
        {
          "name": "file_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Reserved ID"
        },
        {
          "name": "name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Final name with _id_xx suffix"
        },
        {
          "name": "path",
          "type": "string",
          "required": true,
          "default": null,
          "description": "File path"
        },
        {
          "name": "language",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Language"
        }
      ],
      "purpose": "Finalize reserved file after creation",
      "error_handling": "Return error if file doesn't exist at path",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Verify flows are added in file_flows table"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_reserve_finalize",
          "execution_context": "finalize_reservation",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Finalize file after code written - sets is_reserved=false and confirms file exists on filesystem"
        },
        {
          "directive_name": "project_file_write",
          "execution_context": "finalize_after_write",
          "sequence_order": 3,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Finalize file reservation after successful file generation"
        },
        {
          "directive_name": "project_update_db",
          "execution_context": "finalize_new_files",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Finalize file reservations when updating database with new file metadata"
        }
      ],
      "implementation_notes": [
        "Returns {success: true, file_id: file_id}",
        "Verifies file exists at path using os.path.exists()",
        "SQL: UPDATE files SET is_reserved=0, name=?, path=?, language=? WHERE id=?",
        "Name validation: must contain '_id_{file_id}' pattern",
        "Note: File change tracking uses Git, not database checksums"
      ]
    },
    {
      "name": "finalize_files",
      "file_path": "helpers/project/files_1.py",
      "parameters": [
        {
          "name": "files",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of file objects [{file_id, name, path, language}, ...]"
        }
      ],
      "purpose": "Finalize multiple reserved files",
      "error_handling": "Return error if any file doesn't exist at path",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Verify flows are added in file_flows table for all files"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns {success: true, finalized_ids: [...]} confirming which IDs were finalized",
        "Verifies each file exists on filesystem",
        "SQL: Multiple UPDATE files SET is_reserved=0, name=?, path=?, language=? WHERE id=? (in transaction)",
        "All operations succeed or all fail - no partial finalization",
        "Note: File change tracking uses Git, not database checksums"
      ]
    },
    {
      "name": "get_file_by_name",
      "file_path": "helpers/project/files_1.py",
      "parameters": [
        {
          "name": "file_name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "File name to look up (e.g., 'calculator_id_42.py')"
        }
      ],
      "purpose": "Get file by name (high-frequency lookup)",
      "error_handling": "Return null if not found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_dependency_sync",
          "execution_context": "compare_db_and_files",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Look up files by name during DB-filesystem sync - verifies file entries exist before syncing dependencies"
        },
        {
          "directive_name": "project_dependency_map",
          "execution_context": "generate_dependency_graph",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Query files by name for dependency graph generation - maps relationships between files, functions, and flows"
        }
      ],
      "implementation_notes": [
        "Returns file object or null if not found",
        "SQL: SELECT * FROM files WHERE name=? LIMIT 1",
        "Returns: {id, name, path, language, is_reserved, created_at, updated_at}"
      ]
    },
    {
      "name": "get_file_by_path",
      "file_path": "helpers/project/files_1.py",
      "parameters": [
        {
          "name": "file_path",
          "type": "string",
          "required": true,
          "default": null,
          "description": "File path to look up (e.g., 'src/calculator.py')"
        }
      ],
      "purpose": "Get file by path (very high-frequency lookup)",
      "error_handling": "Return null if not found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_file_read",
          "execution_context": "load_with_context",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Load file metadata from database by path - provides full context including functions, dependencies, theme/flow associations"
        },
        {
          "directive_name": "project_file_delete",
          "execution_context": "check_file_tracked",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Check if file exists in database before deletion - ensures proper cleanup of DB records"
        },
        {
          "directive_name": "project_dependency_sync",
          "execution_context": "compare_db_and_files",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Look up files by path during DB-filesystem sync - verifies file entries exist before syncing dependencies"
        },
        {
          "directive_name": "project_dependency_map",
          "execution_context": "generate_dependency_graph",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Query files by path for dependency graph generation - maps relationships between files, functions, and flows"
        },
        {
          "directive_name": "project_integrity_check",
          "execution_context": "run_integrity_queries",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Validate file paths exist in database during integrity checks - detects missing or orphaned file records"
        }
      ],
      "implementation_notes": [
        "Returns file object or null if not found",
        "SQL: SELECT * FROM files WHERE path=? LIMIT 1",
        "Returns: {id, name, path, language, is_reserved, created_at, updated_at}"
      ]
    },
    {
      "name": "update_file",
      "file_path": "helpers/project/files_2.py",
      "parameters": [
        {
          "name": "file_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "File ID to update"
        },
        {
          "name": "name",
          "type": "string",
          "required": false,
          "default": null,
          "description": "New file name (NULL = don't update)"
        },
        {
          "name": "path",
          "type": "string",
          "required": false,
          "default": null,
          "description": "New file path (NULL = don't update)"
        },
        {
          "name": "language",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Language (NULL = don't update)"
        }
      ],
      "purpose": "Update file metadata",
      "error_handling": "Return error if file_id not found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Ensure name or path changes are updated throughout codebase",
        "If name changed, verify _id_xxx suffix is retained"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_update_db",
          "execution_context": "update_files_table",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Update file metadata after code generation - synchronizes file information"
        },
        {
          "directive_name": "project_dependency_sync",
          "execution_context": "update_dependency_entry",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Update stale file metadata during DB-filesystem sync - refreshes file information"
        },
        {
          "directive_name": "project_integrity_check",
          "execution_context": "verify_file_metadata",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Verify file metadata during integrity validation - ensures database matches filesystem"
        }
      ],
      "implementation_notes": [
        "Returns {success: true, file_id: file_id}",
        "SQL: UPDATE files SET name=?, path=?, language=?, updated_at=CURRENT_TIMESTAMP WHERE id=?",
        "Only updates non-NULL parameters - partial updates supported",
        "Note: File change tracking uses Git, not database fields"
      ]
    },
    {
      "name": "file_has_changed",
      "file_path": "helpers/project/files_2.py",
      "parameters": [
        {
          "name": "file_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "File ID to check"
        }
      ],
      "purpose": "Check if file changed using Git (if available) or filesystem timestamp",
      "error_handling": "Return error if file_id not found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_file_read",
          "execution_context": "check_checksum_mismatch",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Detect if file changed since last DB update - warns user about potential staleness"
        },
        {
          "directive_name": "project_integrity_check",
          "execution_context": "recalculate_file_checksum",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Check if files changed during integrity validation - detects checksum mismatches that need correction"
        },
        {
          "directive_name": "project_dependency_sync",
          "execution_context": "compare_db_and_files",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Detect which files changed during DB-filesystem sync - identifies stale entries that need re-syncing"
        }
      ],
      "implementation_notes": [
        "Returns {changed: boolean, method: 'git'|'filesystem'}",
        "Git method: git diff --quiet <path> (if git available)",
        "Filesystem method: Compare file's last modified timestamp with updated_at in database",
        "Prefers git method if available, falls back to filesystem timestamp comparison"
      ]
    },
    {
      "name": "update_file_timestamp",
      "file_path": "helpers/project/files_2.py",
      "parameters": [
        {
          "name": "file_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "File ID to update timestamp for"
        }
      ],
      "purpose": "Update file timestamp (called automatically after function updates)",
      "error_handling": "Return error if file_id not found",
      "is_tool": false,
      "is_sub_helper": true,
      "return_statements": [],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns {success: true}",
        "Sub-helper: not exposed as MCP tool, only called internally",
        "Updates timestamp to mark file as recently modified",
        "SQL: UPDATE files SET updated_at=CURRENT_TIMESTAMP WHERE id=?"
      ]
    },
    {
      "name": "delete_file",
      "file_path": "helpers/project/files_2.py",
      "parameters": [
        {
          "name": "file_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "File ID to delete"
        },
        {
          "name": "note_reason",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Deletion reason"
        },
        {
          "name": "note_severity",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'info', 'warning', 'error'"
        },
        {
          "name": "note_source",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'ai' or 'user'"
        },
        {
          "name": "note_type",
          "type": "string",
          "required": true,
          "default": "entry_deletion",
          "description": "'entry_deletion'"
        }
      ],
      "purpose": "Delete file with comprehensive cross-reference validation",
      "error_handling": "Return error if functions/flows exist for file - requires manual cleanup first",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Ensure the file is also deleted from the filesystem, not just the database"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_file_delete",
          "execution_context": "delete_file_and_db_records",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Delete file from filesystem and database with cascade cleanup of functions and interactions"
        }
      ],
      "implementation_notes": [
        "ERROR LOGIC: Query files table for is_reserved WHERE id=? - if is_reserved=1, return error",
        "ERROR RETURN (reserved): {success: false, error: 'file_reserved', message: 'Cannot delete reserved file. Use delete_reserved helper to clean up abandoned reservation'}",
        "ERROR LOGIC: Query functions table WHERE file_id=? - if not empty, return error with function list",
        "ERROR LOGIC: Query types table WHERE file_id=? - if not empty, return error with type list",
        "ERROR LOGIC: Query file_flows table WHERE file_id=? - if not empty, return error with flow list",
        "ERROR RETURN: {success: false, error: 'dependencies_exist', functions: [...], types: [...], file_flows: [...]}",
        "ERROR MESSAGE: 'Cannot delete file - dependencies exist. Delete functions/types first, remove file_flows entries, then retry'",
        "SUCCESS LOGIC: Only proceed with deletion if is_reserved=0 AND all three dependency checks return empty results",
        "SUCCESS LOGIC: Create note entry in notes table with reason, severity, source, type, reference details",
        "SUCCESS LOGIC: Delete file entry: DELETE FROM files WHERE id=file_id",
        "SUCCESS RETURN: {success: true, deleted_file_id: file_id}",
        "NOTE: Functions and types have SQL ON DELETE CASCADE to files, but we prevent this by checking dependencies first"
      ]
    }
  ],
  "metadata": {
    "file": "helpers-project-2.json",
    "count": 10,
    "range": "helpers 16-25 of 112",
    "description": "File reservation, finalization, and management operations",
    "first_helper": "reserve_file",
    "last_helper": "delete_file",
    "status": "return_statements complete - 6 helpers enhanced",
    "last_updated": "2026-01-02"
  }
}