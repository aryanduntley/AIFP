{
  "helpers": [
    {
      "name": "get_project_tables",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [],
      "purpose": "List all tables in project database",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Project database tables include files, functions, tasks, milestones, completion_path, themes, flows, notes, infrastructure",
        "NEXT STEP: For table structure details, find helper for getting field metadata of specific table",
        "NEXT STEP: For complete schema exploration, find helper that returns all tables with field details at once",
        "CHECK: Do you need full schema or just specific table? Complete schema helpers more efficient for broad exploration"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns array of strings: ['project', 'files', 'functions', 'types', 'interactions', 'themes', 'flows', 'file_flows', 'flow_themes', 'completion_path', 'milestones', 'tasks', 'subtasks', 'sidequests', 'items', 'notes', 'infrastructure', 'types_functions', 'work_branches', 'merge_history']",
        "SQL: SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
      ]
    },
    {
      "name": "get_project_fields",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name to get fields for"
        }
      ],
      "purpose": "Get field names and types for a specific table",
      "error_handling": "Return error if table doesn't exist",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Field metadata includes name, type (TEXT/INTEGER/JSON), nullable, default value, primary key status",
        "CHECK: Before CRUD operations, verify field types to ensure correct data format (INTEGER vs TEXT, proper JSON formatting)",
        "NEXT STEP: Use field metadata to construct valid queries or understand schema constraints for this table"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns array of objects: [{name: str, type: str, nullable: bool, default: any, pk: bool}, ...]",
        "SQL: PRAGMA table_info(table_name)"
      ]
    },
    {
      "name": "get_project_schema",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [],
      "purpose": "Get complete schema for project database",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "PERFORMANCE: Cache this result in your context to avoid repeated calls throughout session",
        "CHECK: Do you need entire schema or just specific tables? Single table queries more efficient for targeted needs",
        "DATABASE CONTEXT: Complete schema shows all tables with field metadata (name, type, nullable, default, pk) for project database"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns object: {table_name: [{name, type, nullable, default, pk}, ...], ...}",
        "Combines get_project_tables() + get_project_fields() for each table"
      ]
    },
    {
      "name": "get_project_json_parameters",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name to get available fields for"
        }
      ],
      "purpose": "Get available fields for table to use with generic add/update operations",
      "error_handling": "Return error if table doesn't exist",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Returns field list template for add/update operations (excludes id, created_at, updated_at which are auto-managed)",
        "NEXT STEP: Use returned field names as template for data objects in add/update operations - only include fields being set",
        "CHECK: Are specialized helpers available for this table? Prefer specialized helpers (files, functions, tasks, milestones) over generic CRUD",
        "WARNING: Generic CRUD operations bypass business logic and validation - specialized helpers enforce consistency and relationships"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns object: {field_name: type_hint, ...}",
        "Example: {name: 'TEXT', path: 'TEXT', language: 'TEXT', is_reserved: 'INTEGER'}",
        "Filters out id, created_at, updated_at from PRAGMA table_info() results"
      ]
    },
    {
      "name": "get_from_project",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "id_array",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "**MUST contain at least one ID**"
        }
      ],
      "purpose": "Get records by ID(s) - **EMPTY ARRAY NOT ALLOWED**",
      "error_handling": "- Return empty array if no matches",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Requires at least one ID - empty array NOT allowed (prevents accidental full table scans on large database)",
        "CHECK: Do you have IDs? If not, find helper for filtered queries using conditions or find specialized getter by name/attribute",
        "NEXT STEP: For all records without IDs, find helper that accepts WHERE conditions parameter with empty conditions object",
        "WARNING: Empty id_array will raise error - intentional protection against performance issues on large tables"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns array of records or empty array if no matches",
        "Raises error if id_array is empty",
        "SQL: SELECT * FROM table WHERE id IN (?, ?, ...)"
      ]
    },
    {
      "name": "get_from_project_where",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "conditions",
          "type": "object",
          "required": true,
          "default": null,
          "description": "Field-value pairs (AND logic)"
        },
        {
          "name": "limit",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "Maximum rows to return"
        },
        {
          "name": "orderby",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Sort order"
        }
      ],
      "purpose": "Flexible filtering with structured JSON conditions",
      "error_handling": "Return empty array if no matches, error if invalid fields",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Empty conditions {} returns ALL records - use with caution, add limit parameter to prevent overwhelming results",
        "DATABASE CONTEXT: Uses AND logic - all conditions must match (field1=value1 AND field2=value2)",
        "CHECK: For complex queries (OR logic, LIKE, ranges), find helper that accepts raw WHERE clause strings",
        "CHECK: Are specialized query helpers available for this operation? Check for helpers specific to the entity type",
        "CHECK: Use limit parameter for large result sets to avoid overwhelming context",
        "NEXT STEP: After getting results, extract IDs for focused re-queries if needed"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns array of records or empty array if no matches",
        "Builds WHERE clause from conditions object using AND logic",
        "SQL: SELECT * FROM table WHERE field1=? AND field2=? [ORDER BY ...] [LIMIT ...]"
      ]
    },
    {
      "name": "query_project",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "query",
          "type": "string",
          "required": true,
          "default": null,
          "description": "WHERE clause without \"WHERE\" keyword"
        }
      ],
      "purpose": "Execute complex SQL WHERE clause (advanced, rare use)",
      "error_handling": "Return error if SQL syntax invalid",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Advanced query for complex SQL WHERE conditions (OR, LIKE, IN, BETWEEN, comparison operators)",
        "DATABASE CONTEXT: Examples: \"status IN ('pending', 'in_progress')\" or \"name LIKE '%api%' AND is_reserved = 0\"",
        "CHECK: Try helpers with structured conditions first (AND-logic helpers) - safer and cleaner than raw SQL",
        "CHECK: Verify field names exist in table schema before constructing query to avoid SQL syntax errors",
        "CHECK: Is there a specialized helper for this query pattern? Prefer specialized over raw SQL",
        "WARNING: SQL injection safe (parameterized), but syntax errors will fail - validate field names first",
        "WARNING: Rarely needed - most queries handled by structured condition helpers or specialized helpers"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns array of records or empty array if no matches",
        "SQL: SELECT * FROM table WHERE {query}",
        "Query string is raw SQL WHERE clause without the WHERE keyword"
      ]
    },
    {
      "name": "add_project_entry",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "data",
          "type": "object",
          "required": true,
          "default": null,
          "description": "Field-value pairs"
        }
      ],
      "purpose": "Add new entry to project database",
      "error_handling": "Return error if used on restricted tables",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Generic insert for any table - returns new record ID",
        "CHECK: Are specialized add helpers available for this table? Specialized helpers enforce business logic and relationships",
        "CHECK: For files, functions, types: Use reserve/finalize workflow pattern instead of direct insert",
        "CHECK: After adding, do relationships need to be established in junction tables (file_flows, types_functions)?",
        "WARNING: Generic CRUD bypasses validation logic - prefer specialized helpers for core entities (files, functions, tasks, milestones)",
        "WARNING: Restricted tables (files, functions, types) require reserve/finalize workflow for ID embedding in names"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns {success: true, id: new_id}",
        "SQL: INSERT INTO table (field1, field2, ...) VALUES (?, ?, ...) RETURNING id",
        "Validate table exists and is not restricted before insert"
      ]
    },
    {
      "name": "update_project_entry",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Record ID"
        },
        {
          "name": "data",
          "type": "object",
          "required": true,
          "default": null,
          "description": "Field-value pairs to update"
        }
      ],
      "purpose": "Update existing entry",
      "error_handling": "Return error if ID not found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Partial update - only fields in data object are modified, omitted fields remain unchanged",
        "DATABASE CONTEXT: Auto-updates updated_at timestamp via database trigger - do not include in data object",
        "CHECK: Are specialized update helpers available for this table? They provide validation and relationship consistency",
        "CHECK: If updating critical fields (status, foreign keys), verify no cascade effects on dependent records",
        "CHECK: After updating, consider verifying changes succeeded by re-querying the record",
        "WARNING: Generic updates bypass business logic - prefer specialized update helpers for core entities",
        "WARNING: Updating foreign key relationships without validation can create orphaned or inconsistent data"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns {success: true, id: id}",
        "SQL: UPDATE table SET field1=?, field2=? WHERE id=?",
        "Only updates fields present in data object - partial updates supported"
      ]
    },
    {
      "name": "delete_project_entry",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Record ID"
        },
        {
          "name": "note_reason",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Deletion reason"
        },
        {
          "name": "note_severity",
          "type": "string",
          "required": true,
          "default": null,
          "description": "\"info\", \"warning\", \"error\""
        },
        {
          "name": "note_source",
          "type": "string",
          "required": true,
          "default": null,
          "description": "\"ai\" or \"user\""
        },
        {
          "name": "note_type",
          "type": "string",
          "required": true,
          "default": null,
          "description": "\"entry_deletion\""
        }
      ],
      "purpose": "Smart delete with automatic routing to specialized functions when needed",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Smart delete automatically routes to specialized delete helpers when they exist (with relationship validation)",
        "DATABASE CONTEXT: All deletions logged to notes table with reason, severity, source for permanent audit trail",
        "DATABASE CONTEXT: Requires note metadata: reason (TEXT), severity ('info'/'warning'/'error'), source ('ai'/'user'), type ('entry_deletion')",
        "CHECK: Before deleting, verify no dependent records exist - check foreign key relationships in related tables",
        "CHECK: Is soft delete (status='deleted') better than hard delete? Soft deletes are reversible",
        "CHECK: Have you clearly documented deletion reason? Audit trail is permanent and required",
        "CHECK: After deletion, verify no orphaned records in junction tables (file_flows, types_functions, flow_themes)",
        "WARNING: Deletion is permanent with no undo - specialized delete helpers provide relationship validation",
        "WARNING: Generic delete may not catch all relationship constraints - prefer specialized delete helpers for safety",
        "WARNING: Deleting from junction tables breaks relationships - ensure intent is clear before proceeding"
      ],
      "target_database": "project",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns {success: true} or error if dependencies exist",
        "Routes to specialized delete if available (delete_file, delete_type, delete_theme, delete_flow, etc.)",
        "Logs deletion to notes table: {reason: note_reason, severity: note_severity, source: note_source, type: note_type}",
        "SQL: DELETE FROM table WHERE id=? (after validation)"
      ]
    },
    {
      "name": "create_project",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project name (e.g., 'MatrixCalculator')"
        },
        {
          "name": "purpose",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project purpose (e.g., 'Build a pure functional matrix math library')"
        },
        {
          "name": "goals",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of goal strings (e.g., ['Fast computation', 'No OOP'])"
        },
        {
          "name": "status",
          "type": "string",
          "required": true,
          "default": "active",
          "description": "'active', 'paused', 'completed', 'abandoned'"
        },
        {
          "name": "version",
          "type": "integer",
          "required": true,
          "default": 1,
          "description": "Tracks idea evolution (starts at 1)"
        },
        {
          "name": "user_directives_status",
          "type": "string",
          "required": false,
          "default": null,
          "description": "NULL (no user directives), 'in_progress', 'active', 'disabled'"
        }
      ],
      "purpose": "Initialize project entry (one per database)",
      "error_handling": "Return error if project already exists",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Single row table - only one project record per database, represents entire project metadata",
        "DATABASE CONTEXT: Auto-populates git tracking fields (last_known_git_hash, last_git_sync) from current HEAD if git available",
        "DATABASE CONTEXT: Fields: version (blueprint evolution tracking), user_directives_status (NULL=UseCase1, 'active'=UseCase2)",
        "DIRECTIVE CONTEXT: Called by project_init (sequence_order: 1, execution_context: create_project_structure)",
        "DIRECTIVE CONTEXT: First step in initialization - creates project database record before theme/flow population",
        "DIRECTIVE FLOW: aifp_status → project_init (when project not initialized) → create_project (this, seq 1) → populate themes/flows → aifp_status",
        "DIRECTIVE FLOW: After project_init completes, flow proceeds to aifp_status via completion_loop to show initialized state",
        "NEXT STEP: After creating project record, populate themes and flows from parsed ProjectBlueprint.md",
        "NEXT STEP: Create completion_path and initial milestones based on project goals",
        "CHECK: ProjectBlueprint.md should exist before calling - parse it for name, purpose, goals parameters",
        "CHECK: Git recommended for external change detection - last_known_git_hash enables blueprint sync checks",
        "WARNING: Single-use helper - can only be called once per database, returns error if project already exists",
        "WARNING: user_directives_status should be NULL unless explicitly building Use Case 2 (automation project)"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_init",
          "execution_context": "create_project_structure",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Initialize project entry during .aifp-project/ creation - creates single project record with metadata"
        }
      ],
      "implementation_notes": [
        "Returns {success: true, project_id: 1}",
        "Auto-populates last_known_git_hash from git rev-parse HEAD (if git available)",
        "Auto-populates last_git_sync with current timestamp",
        "SQL: INSERT INTO project (name, purpose, goals, status, version, user_directives_status, ...) VALUES (...)"
      ]
    },
    {
      "name": "get_project",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [],
      "purpose": "Get project metadata (single entry)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Single project record contains: name, purpose, goals, status, version, user_directives_status, git tracking",
        "DIRECTIVE CONTEXT: Called by project_blueprint_read (sequence_order: 1, execution_context: database_fallback)",
        "DIRECTIVE CONTEXT: Called by project_blueprint_update (sequence_order: 1, execution_context: read_current_blueprint)",
        "DIRECTIVE CONTEXT: For blueprint_read: fallback when ProjectBlueprint.md file missing - reconstructs from database",
        "DIRECTIVE CONTEXT: For blueprint_update: retrieves current version before incrementing and syncing changes",
        "DIRECTIVE FLOW: aifp_status → project_blueprint_read → get_project (this, seq 1) → reconstruct blueprint file → aifp_status",
        "DIRECTIVE FLOW: aifp_status → project_blueprint_update → get_project (this, seq 1) → increment version → sync file → aifp_status",
        "CHECK: user_directives_status field determines Use Case (NULL=regular dev, 'active'=automation project)",
        "CHECK: Compare last_known_git_hash with current HEAD to detect external blueprint modifications",
        "NEXT STEP: For blueprint_read, use returned data to reconstruct ProjectBlueprint.md content if file missing",
        "NEXT STEP: For blueprint_update, increment version field and prepare updated data for sync"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_blueprint_read",
          "execution_context": "database_fallback",
          "sequence_order": 1,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Fallback to database when ProjectBlueprint.md missing - retrieves project metadata from database"
        },
        {
          "directive_name": "project_blueprint_update",
          "execution_context": "read_current_blueprint",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Get current project version before updating blueprint - checks version for increment"
        }
      ],
      "implementation_notes": [
        "Returns project object: {id: 1, name, purpose, goals: [...], status, version, user_directives_status, last_known_git_hash, last_git_sync, created_at, updated_at}",
        "SQL: SELECT * FROM project LIMIT 1",
        "Always returns single row or null if project not initialized"
      ]
    },
    {
      "name": "update_project",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Project name (NULL = don't update)"
        },
        {
          "name": "purpose",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Project purpose (NULL = don't update)"
        },
        {
          "name": "goals",
          "type": "array",
          "required": false,
          "default": null,
          "description": "Array of goal strings (NULL = don't update)"
        },
        {
          "name": "status",
          "type": "string",
          "required": false,
          "default": null,
          "description": "'active', 'paused', 'completed', 'abandoned' (NULL = don't update)"
        },
        {
          "name": "version",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "Version number (NULL = don't update)"
        },
        {
          "name": "user_directives_status",
          "type": "string",
          "required": false,
          "default": null,
          "description": "NULL, 'in_progress', 'active', 'disabled' (NULL = don't update)"
        }
      ],
      "purpose": "Update project metadata",
      "error_handling": "Return error if no project exists",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Partial update - only non-NULL parameter values are updated, omitted parameters unchanged",
        "DATABASE CONTEXT: Common updates: version increment (blueprint changes), status transitions, user_directives_status changes",
        "DIRECTIVE CONTEXT: Called by project_blueprint_update (sequence_order: 2, execution_context: update_version_and_date)",
        "DIRECTIVE CONTEXT: Second step in blueprint update - increments version after blueprint modifications synced",
        "DIRECTIVE FLOW: aifp_status → project_blueprint_update → get_project (seq 1) → update_project (this, seq 2) → sync file → aifp_status",
        "CHECK: Version increments should reflect significant changes (architecture, goals, major features) - document changes",
        "CHECK: Status field values: 'active', 'paused', 'completed', 'abandoned' - status transitions may cascade to tasks/milestones",
        "CHECK: After updating version, ensure ProjectBlueprint.md file is synced to maintain consistency",
        "WARNING: user_directives_status change to 'active' requires Use Case 2 setup complete (directives implemented)"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_blueprint_update",
          "execution_context": "update_version_and_date",
          "sequence_order": 2,
          "is_required": false,
          "parameters_mapping": {
            "version": "incremented_version",
            "last_updated": "current_timestamp"
          },
          "description": "Increment project version after blueprint update - updates version and last_updated timestamp in database"
        }
      ],
      "implementation_notes": [
        "Returns {success: true}",
        "SQL: UPDATE project SET field1=?, field2=? WHERE id=1",
        "Only updates provided fields - NULL values are ignored (not set to NULL, just skipped)",
        "updated_at timestamp auto-updated by trigger"
      ]
    },
    {
      "name": "blueprint_has_changed",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [],
      "purpose": "Check if ProjectBlueprint.md has changed using Git or filesystem timestamp",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Detects external ProjectBlueprint.md modifications - git method (hash comparison) or filesystem method (timestamp)",
        "DATABASE CONTEXT: Git method compares file hash vs last_known_git_hash, filesystem compares modified time vs updated_at",
        "DIRECTIVE CONTEXT: Called by project_blueprint_read (sequence_order: 2, execution_context: parse_complete)",
        "DIRECTIVE CONTEXT: Called by project_blueprint_update (sequence_order: 1, execution_context: validate_parameters)",
        "DIRECTIVE CONTEXT: For blueprint_read: detects staleness after parsing - determines if resync needed",
        "DIRECTIVE CONTEXT: For blueprint_update: pre-check for conflicts before applying updates - prevents overwriting external changes",
        "DIRECTIVE FLOW: Session start → git_detect_external_changes → blueprint_has_changed → if true → project_blueprint_read → sync → proceed",
        "DIRECTIVE FLOW: Before update → project_blueprint_update → blueprint_has_changed (this, seq 1) → if true → warn user → get confirmation",
        "CHECK: Git method preferred (detects actual content changes), filesystem method less reliable (false positives on touch)",
        "CHECK: If changed=true, in-memory state may be stale - trigger project_blueprint_read before making changes",
        "NEXT STEP: After syncing external changes, update last_known_git_hash to mark blueprint as processed",
        "WARNING: Filesystem method can show false positives - file timestamp changed but content unchanged"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_blueprint_read",
          "execution_context": "parse_complete",
          "sequence_order": 2,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Check if blueprint changed since last read - uses Git diff or filesystem timestamp for staleness detection"
        },
        {
          "directive_name": "project_blueprint_update",
          "execution_context": "validate_parameters",
          "sequence_order": 1,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Pre-check if blueprint already modified - prevents conflicting updates"
        }
      ],
      "implementation_notes": [
        "Returns {changed: boolean, method: 'git'|'filesystem'}",
        "Git method: git diff --quiet .aifp/ProjectBlueprint.md || compute hash and compare with project.last_known_git_hash",
        "Filesystem method: Compare os.path.getmtime() with project.updated_at",
        "Prefers git method if available, falls back to filesystem"
      ]
    },
    {
      "name": "get_infrastructure_by_type",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Infrastructure type (e.g., 'language', 'package', 'testing', 'database', 'build_tool')"
        }
      ],
      "purpose": "Get all infrastructure of specific type",
      "error_handling": "Return empty array if none found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Infrastructure types tracked: 'language', 'package', 'testing', 'database', 'build_tool'",
        "DATABASE CONTEXT: Records include name, version, purpose - used for environment configuration and validation",
        "DIRECTIVE CONTEXT: Called by project_init (sequence_order: 2, execution_context: create_project_structure)",
        "DIRECTIVE CONTEXT: Called by project_blueprint_read (sequence_order: 2, execution_context: database_fallback)",
        "DIRECTIVE CONTEXT: For project_init: populate initial infrastructure after creating project record - verifies language, build tool",
        "DIRECTIVE CONTEXT: For blueprint_read: query infrastructure when blueprint file missing - reconstructs infrastructure section from DB",
        "DIRECTIVE FLOW: aifp_status → project_init → create_project (seq 1) → get_infrastructure_by_type (this, seq 2) → add missing → aifp_status",
        "DIRECTIVE FLOW: aifp_status → project_blueprint_read → get_project (seq 1) → get_infrastructure_by_type (this, seq 2) → reconstruct → aifp_status",
        "CHECK: Empty results may indicate fresh project initialization needed",
        "CHECK: language type determines file extensions and syntax (Python/.py, TypeScript/.ts)",
        "CHECK: testing type determines test framework for test generation (pytest, jest)"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "project_init",
          "execution_context": "create_project_structure",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Check and populate initial infrastructure during project initialization - verifies database, language, build tool"
        },
        {
          "directive_name": "project_blueprint_read",
          "execution_context": "database_fallback",
          "sequence_order": 2,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Query infrastructure when blueprint missing - retrieves language, runtime, build tool from database"
        }
      ],
      "implementation_notes": [
        "Returns array of infrastructure objects: [{id, type, name, version, purpose, created_at, updated_at}, ...]",
        "SQL: SELECT * FROM infrastructure WHERE type=? ORDER BY created_at",
        "Returns empty array if no infrastructure of that type exists"
      ]
    }
  ],
  "metadata": {
    "file": "helpers-project-1.json",
    "count": 15,
    "range": "helpers 1-15 of 112",
    "description": "Database schema queries, generic CRUD operations, project metadata management",
    "first_helper": "get_project_tables",
    "last_helper": "get_infrastructure_by_type",
    "status": "return_statements enhanced - ready for review",
    "last_updated": "2025-12-29"
  }
}