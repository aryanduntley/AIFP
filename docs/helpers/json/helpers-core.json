{
  "helpers": [
    {
      "name": "core_get_allowed_db_enum",
      "file_path": "helpers/core/validation.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name to check for CHECK constraints"
        },
        {
          "name": "field",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Field name to get allowed values for"
        }
      ],
      "purpose": "Returns list of allowed values for CHECK constraint enum fields in aifp_core.db. Parses schema to extract CHECK(field IN (...)) constraints.",
      "error_handling": "Returns error if table does not exist, field does not exist, or field does not have a CHECK constraint list",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Returns array of allowed string values: [\"value1\", \"value2\", ...]",
        "Error: \"Table {table} not found in core database\"",
        "Error: \"Field {field} not found in table {table}\"",
        "Error: \"Field {field} does not have a CHECK constraint list\""
      ],
      "target_database": "core",
      "used_by_directives": [],
      "implementation_notes": [
        "Parse schema SQL for table definition",
        "Find field with CHECK constraint: CHECK (field IN (...))",
        "Extract values from IN clause",
        "Return as array of strings",
        "Examples: core_get_allowed_db_enum(\"directives\", \"type\") -> [\"fp\", \"project\", \"git\", \"user_system\", \"user_preference\"]",
        "Examples: core_get_allowed_db_enum(\"directive_flow\", \"flow_type\") -> [\"status_branch\", \"completion_loop\", \"conditional\", \"error\", \"reference_consultation\", \"canonical\", \"error_handler\", \"utility\"]",
        "Examples: core_get_allowed_db_enum(\"directive_flow\", \"flow_category\") -> [\"project\", \"fp\", \"user_preferences\", \"git\"]",
        "Examples: core_get_allowed_db_enum(\"helper_functions\", \"target_database\") -> [\"core\", \"project\", \"user_preferences\", \"user_directives\", \"orchestrator\", \"system\"]"
      ]
    },
    {
      "name": "get_core_tables",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "List all tables in core database",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_core_fields",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        }
      ],
      "purpose": "Get field names and types for a specific table",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_core_schema",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get complete schema for core database (all tables and fields)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_from_core",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "id_array",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "IDs to fetch, **empty array [] returns ALL records**"
        }
      ],
      "purpose": "Get records by ID(s), or all records if empty array",
      "error_handling": "Return empty array if no matches",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_from_core_where",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "conditions",
          "type": "object",
          "required": true,
          "default": null,
          "description": "Field-value pairs (AND logic), e.g., `{\"type\": \"fp\", \"category\": \"purity\"}`"
        },
        {
          "name": "limit",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "Maximum rows to return"
        },
        {
          "name": "orderby",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Sort order, e.g., \"name ASC\" or \"id DESC\""
        }
      ],
      "purpose": "Flexible filtering with structured JSON conditions",
      "error_handling": "Return empty array if no matches, error if invalid field names",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "query_core",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name"
        },
        {
          "name": "query",
          "type": "string",
          "required": true,
          "default": null,
          "description": "WHERE clause without \"WHERE\" keyword"
        }
      ],
      "purpose": "Execute complex SQL WHERE clause (advanced, rare use)",
      "error_handling": "Return error if SQL syntax invalid",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_directive_by_name",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "directive_name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Directive name to look up"
        }
      ],
      "purpose": "Get specific directive by name (high-frequency operation)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Directive object with workflow, description, category, etc.",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for this directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {
            "directive_name": "user_specified_directive_name"
          },
          "description": "Look up specific directive by name when user asks about it - retrieves directive details for help display"
        }
      ]
    },
    {
      "name": "get_all_directives",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Load all directives for caching (special orchestrator)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of all directive objects with workflow, description, category, etc.",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_run",
          "execution_context": "load_directive_library",
          "sequence_order": 1,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Load all directives into memory when AI needs comprehensive directive library - provides guidance on available directives"
        }
      ]
    },
    {
      "name": "search_directives",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "keyword",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Keyword to search in directive names, descriptions, and intent_keywords"
        },
        {
          "name": "type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Directive type filter: 'fp', 'project', 'user-system', 'user-pref', 'git'"
        },
        {
          "name": "category",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Directive category filter (e.g., 'purity', 'error_handling', 'task_management')"
        }
      ],
      "purpose": "Search directives with filters (orchestrator)",
      "error_handling": "Returns empty array if no matches found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of matching directive objects with workflow, description, category, etc.",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {
            "keyword": "user_search_term",
            "type": "directive_type_filter (optional)"
          },
          "description": "User searches for directives by keyword or topic"
        }
      ]
    },
    {
      "name": "find_directive_by_intent",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "user_request",
          "type": "string",
          "required": true,
          "default": null,
          "description": "User's natural language request describing behavior to change"
        },
        {
          "name": "threshold",
          "type": "float",
          "required": false,
          "default": "0.7",
          "description": "Confidence threshold"
        }
      ],
      "purpose": "Map user intent to directives using NLP/keyword matching",
      "error_handling": "Returns empty array if no matches above threshold",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "user_preferences_update",
          "execution_context": "parse_preference_request",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {
            "user_request": "user's preference change request (e.g., 'always add docstrings')",
            "threshold": "0.6 (lower threshold for preference updates)"
          },
          "description": "Map user preference request to specific directive name for storing in directive_preferences table. Searches directive name, description, and intent_keywords."
        }
      ]
    },
    {
      "name": "find_directives_by_intent_keyword",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "keywords",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Single keyword string or array of keywords"
        },
        {
          "name": "match_mode",
          "type": "string",
          "required": false,
          "default": null,
          "description": "\"any\" for OR logic, \"all\" for AND logic"
        }
      ],
      "purpose": "Find directive IDs matching one or more intent keywords (direct keyword lookup)",
      "error_handling": "",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_directives_with_intent_keywords",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "keywords",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Single keyword or array of keywords"
        },
        {
          "name": "match_mode",
          "type": "string",
          "required": false,
          "default": null,
          "description": "\"any\" for OR logic, \"all\" for AND logic"
        },
        {
          "name": "include_keyword_matches",
          "type": "boolean",
          "required": false,
          "default": null,
          "description": "Include which keywords matched"
        }
      ],
      "purpose": "Search directives by intent keywords and return full directive objects",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of directive objects matching keywords with workflow, description, category, etc.",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "user_preferences_update",
          "execution_context": "parse_preference_request",
          "sequence_order": 2,
          "is_required": false,
          "parameters_mapping": {
            "keywords": "extracted_keywords_from_user_request",
            "match_mode": "any (default) or all based on request specificity"
          },
          "description": "Search for directives by keywords when find_directive_by_intent returns multiple candidates - provides full directive objects for preference mapping"
        },
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 2,
          "is_required": false,
          "parameters_mapping": {
            "keywords": "user_search_keywords",
            "match_mode": "any or all based on query"
          },
          "description": "Search directives by keywords for help queries - returns full directive details for display to user"
        }
      ]
    },
    {
      "name": "add_directive_intent_keyword",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "directive_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Directive ID"
        },
        {
          "name": "keyword",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Intent keyword to add"
        }
      ],
      "purpose": "Add an intent keyword to a directive",
      "error_handling": "",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "remove_directive_intent_keyword",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "directive_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Directive ID"
        },
        {
          "name": "keyword",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Intent keyword to remove"
        }
      ],
      "purpose": "Remove an intent keyword from a directive",
      "error_handling": "",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_directive_keywords",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "directive_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Directive ID"
        }
      ],
      "purpose": "Get all intent keywords for a specific directive",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 4,
          "is_required": false,
          "parameters_mapping": {
            "directive_id": "directive_id_from_previous_lookup"
          },
          "description": "Show keywords associated with specific directive when providing help - displays searchable terms for directive"
        }
      ]
    },
    {
      "name": "get_all_directive_keywords",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get list of all unique intent keywords available for searching (simple list)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 5,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Show all available search keywords to user when browsing help - provides keyword reference for directive search"
        }
      ]
    },
    {
      "name": "get_all_intent_keywords_with_counts",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get all unique intent keywords with usage counts for analytics",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 6,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Show popular/frequently used keywords when browsing help - helps user discover common search terms"
        }
      ]
    },
    {
      "name": "get_next_directives_from_status",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "from_directive",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Usually 'aifp_status'"
        }
      ],
      "purpose": "Get all possible next directives with condition evaluation (sequential workflow flows only, ignores wildcard '*' flows)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of possible next directive objects based on flows, with evaluated conditions",
        "Implementation MUST retrieve current project status internally using get_project_status() - DO NOT require AI to pass status objects",
        "This prevents AI from moving data objects around - helper handles status retrieval",
        "Queries directive_flow WHERE from_directive = parameter (NOT wildcard '*')",
        "Evaluates condition_key/condition_value against retrieved status",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_status",
          "execution_context": "determine_next_steps",
          "sequence_order": 10,
          "is_required": true,
          "parameters_mapping": {
            "from_directive": "aifp_status"
          },
          "description": "Query directive_flow table to determine what directives AI should suggest next based on project state - enables status-driven workflow navigation"
        },
        {
          "directive_name": "project_auto_resume",
          "execution_context": "determine_resume_point",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {
            "from_directive": "last_completed_directive"
          },
          "description": "Determine where to resume work after interruption - finds next directive in workflow based on last completed state"
        }
      ]
    },
    {
      "name": "get_matching_next_directives",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "from_directive",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Directive name (usually 'aifp_status')"
        }
      ],
      "purpose": "Get ONLY directives whose conditions match current state (filtered subset, ignores wildcard '*' flows)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of directive objects whose conditions match current state",
        "Implementation MUST retrieve current project status internally using get_project_status() - DO NOT require AI to pass status objects",
        "This prevents AI from moving data objects around - helper handles status retrieval",
        "Queries directive_flow WHERE from_directive = parameter (NOT wildcard '*')",
        "Filters flows to only those whose conditions evaluate to true against retrieved status",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_status",
          "execution_context": "determine_next_steps",
          "sequence_order": 11,
          "is_required": false,
          "parameters_mapping": {
            "from_directive": "aifp_status"
          },
          "description": "Filter next directives to only those whose conditions match current state - provides refined recommendations to user"
        }
      ]
    },
    {
      "name": "get_completion_loop_target",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "from_directive",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Directive name"
        }
      ],
      "purpose": "Get where to loop back after completing directive",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "project_task_complete",
          "execution_context": "determine_next_directive",
          "sequence_order": 10,
          "is_required": true,
          "parameters_mapping": {
            "from_directive": "project_task_complete"
          },
          "description": "Query directive_flow table to determine where to loop back after task completion - typically returns aifp_status"
        },
        {
          "directive_name": "project_subtask_complete",
          "execution_context": "determine_next_directive",
          "sequence_order": 10,
          "is_required": true,
          "parameters_mapping": {
            "from_directive": "project_subtask_complete"
          },
          "description": "Query directive_flow table to determine where to loop back after subtask completion - typically returns aifp_status"
        },
        {
          "directive_name": "project_sidequest_complete",
          "execution_context": "determine_next_directive",
          "sequence_order": 10,
          "is_required": true,
          "parameters_mapping": {
            "from_directive": "project_sidequest_complete"
          },
          "description": "Query directive_flow table to determine where to loop back after sidequest completion - typically returns aifp_status"
        },
        {
          "directive_name": "project_milestone_complete",
          "execution_context": "determine_next_directive",
          "sequence_order": 10,
          "is_required": true,
          "parameters_mapping": {
            "from_directive": "project_milestone_complete"
          },
          "description": "Query directive_flow table to determine where to loop back after milestone completion - typically returns aifp_status"
        }
      ]
    },
    {
      "name": "get_conditional_work_paths",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "from_directive",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Directive name (e.g., 'aifp_status', 'project_file_write')"
        }
      ],
      "purpose": "Query directive_flow table for flow_type='conditional' to determine context-based next directive (ignores wildcard '*' flows, sequential flows only)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of conditional flow objects with evaluated conditions",
        "Implementation MUST retrieve current work context internally - DO NOT require AI to pass context objects",
        "For aifp_status: retrieve via get_project_status()",
        "For project_file_write: retrieve last file write result from project.db",
        "For project_task_complete: retrieve milestone completion status from project.db",
        "This prevents AI from moving data objects around - helper handles context retrieval",
        "Queries directive_flow WHERE from_directive = parameter AND flow_type = 'conditional' (NOT wildcard '*')",
        "Evaluates condition_key/condition_value against retrieved context"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_status",
          "execution_context": "determine_next_steps",
          "sequence_order": 12,
          "is_required": true,
          "parameters_mapping": {
            "from_directive": "aifp_status"
          },
          "description": "Query conditional flows from aifp_status to route to correct next directive based on project state - handles routing to project_init, task_decomposition, file_write, etc."
        },
        {
          "directive_name": "project_file_write",
          "execution_context": "post_write_routing",
          "sequence_order": 10,
          "is_required": false,
          "parameters_mapping": {
            "from_directive": "project_file_write"
          },
          "description": "Route to compliance_check if auto-check enabled in user preferences - conditional flow based on preference settings"
        },
        {
          "directive_name": "project_task_complete",
          "execution_context": "check_milestone_completion",
          "sequence_order": 5,
          "is_required": false,
          "parameters_mapping": {
            "from_directive": "project_task_complete"
          },
          "description": "Route to project_milestone_complete if all milestone tasks complete - conditional flow based on task completion state"
        }
      ]
    },
    {
      "name": "get_helper_by_name",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "helper_name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Helper name to look up"
        }
      ],
      "purpose": "Get specific helper function details (high-frequency)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_helpers_by_database",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "target_database",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Database name ('core', 'project', 'settings', 'user_custom')"
        }
      ],
      "purpose": "Get all helpers for a specific database",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_helpers_are_tool",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get all MCP tools (is_tool=true)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_helpers_not_tool_not_sub",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get all directive-callable helpers",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_helpers_are_sub",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get all sub-helpers (is_sub_helper=true)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_helpers_for_directive",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "include_helpers_data",
          "type": "boolean",
          "required": true,
          "default": null,
          "description": "If true, includes full helper_functions data"
        }
      ],
      "purpose": "Get all helpers used by a directive",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 7,
          "is_required": false,
          "parameters_mapping": {
            "include_helpers_data": "true (show full helper details)"
          },
          "description": "Show which helpers a directive uses when providing help - displays helper details for directive implementation understanding"
        }
      ]
    },
    {
      "name": "get_directives_for_helper",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "helper_name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Helper name"
        }
      ],
      "purpose": "Get all directives that use a helper (reciprocal lookup)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 8,
          "is_required": false,
          "parameters_mapping": {
            "helper_name": "user_specified_helper_name"
          },
          "description": "Reverse lookup showing which directives use a specific helper - helps user understand helper usage across directives"
        }
      ]
    },
    {
      "name": "get_category_by_name",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "category_name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Category name"
        }
      ],
      "purpose": "Get category by name (fairly frequent)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 9,
          "is_required": false,
          "parameters_mapping": {
            "category_name": "user_specified_category_name"
          },
          "description": "Look up specific category when user asks about it - retrieves category details for help display"
        }
      ]
    },
    {
      "name": "get_categories",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get all directive categories",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 10,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Browse all available categories when user explores help system - provides category list for navigation"
        }
      ]
    },
    {
      "name": "get_directives_by_category",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "category_name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Category name"
        }
      ],
      "purpose": "Get all directives in a category",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of directive objects in the specified category",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 11,
          "is_required": false,
          "parameters_mapping": {
            "category_name": "user_specified_category"
          },
          "description": "Filter directives by category when user browses help - shows all directives in a specific category like 'purity' or 'task_management'"
        }
      ]
    },
    {
      "name": "get_directives_by_type",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "required": true,
          "default": null,
          "description": "One of: 'fp', 'project', 'git', 'user_system', 'user_preference'"
        },
        {
          "name": "include_md_content",
          "type": "boolean",
          "required": false,
          "default": "false",
          "description": "Include full MD file content"
        }
      ],
      "purpose": "Get all directives filtered by type (orchestration vs reference)",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of directive objects of the specified type (with optional MD content)",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_help",
          "execution_context": "user_requests_help",
          "sequence_order": 12,
          "is_required": false,
          "parameters_mapping": {
            "type": "user_specified_type (fp, project, git, user_system, user_preference)",
            "include_md_content": "false (default) or true if user wants full documentation"
          },
          "description": "Filter directives by type when user browses help - shows all FP directives, all project directives, etc."
        }
      ]
    },
    {
      "name": "get_fp_directive_index",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [],
      "purpose": "Get lightweight FP directive index grouped by category (names only, not full definitions)",
      "error_handling": "Returns empty object if no FP directives found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "FP directives are REFERENCE material for when AI is uncertain about implementation details - consult as needed, not mandatory execution paths",
        "AI writes FP code naturally as baseline behavior - only consult these directives when genuinely uncertain",
        "No strict workflows with FP directives - they're available on-demand for guidance on complex FP patterns (monads, currying, lazy evaluation, etc.)"
      ],
      "implementation_notes": [
        "Returns: {category_name: [directive_name, ...]}",
        "Example: {'error_handling': ['fp_optionals', 'fp_result_types'], 'purity': ['fp_purity', 'fp_immutability']}",
        "Query: SELECT d.name, c.name as category FROM directives d JOIN directive_categories dc ON d.id=dc.directive_id JOIN categories c ON dc.category_id=c.id WHERE d.type='fp' ORDER BY c.name, d.name",
        "Groups by category name",
        "Lightweight: ~1-2k tokens vs ~10-15k for full FP flows",
        "Does NOT return full directive definitions or flows - just names grouped by category",
        "Use search_directives(type='fp') or get_directive_by_name(name) for full details"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_run",
          "execution_context": "new_session_startup",
          "sequence_order": 3,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Called by aifp_run when is_new_session=true - provides FP directive quick reference grouped by category"
        }
      ]
    },
    {
      "name": "get_all_directive_names",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "types",
          "type": "array",
          "required": false,
          "default": null,
          "description": "Optional array of directive types to filter: ['fp', 'project', 'git', 'user_preferences', 'user_system']. If not provided, returns ALL directive names."
        }
      ],
      "purpose": "Get list of all directive names (or filtered by types). Returns names only, NOT full directive data. AI queries by name when needs details.",
      "error_handling": "Returns empty array if no directives found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "implementation_notes": [
        "Returns: Array of directive names as strings ['aifp_run', 'aifp_status', 'project_init', 'fp_purity', ...]",
        "If types provided: Filters to only those types (e.g., types=['fp', 'project'] returns only FP and project directives)",
        "If types=null: Returns ALL directive names across all types",
        "Query: SELECT name FROM directives WHERE type IN (types) ORDER BY type, name",
        "Lightweight: ~1k tokens for all names vs ~100k+ for all full directive data",
        "AI caches these names at startup, queries get_directive(name) when needs details",
        "Complements get_fp_directive_index() which groups FP directives by category"
      ],
      "target_database": "core",
      "used_by_directives": [
        {
          "directive_name": "aifp_run",
          "execution_context": "new_session_startup",
          "sequence_order": 4,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Called by aifp_run when is_new_session=true - provides complete list of ALL directive names for AI to cache"
        }
      ]
    },
    {
      "name": "get_directive_flows",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "flow_category",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by category: 'project', 'fp', 'user_preferences', 'git'"
        },
        {
          "name": "flow_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by type: 'status_branch', 'completion_loop', 'conditional', 'error'"
        },
        {
          "name": "from_directive",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by source directive name"
        },
        {
          "name": "to_directive",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by target directive name"
        }
      ],
      "purpose": "General-purpose query for directive flows by category, type, or directive names. Complements navigation helpers (get_next_directives_from_status, etc.) which are specialized for workflow routing.",
      "error_handling": "Returns empty array if no flows match filters",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "When flow_category='fp': These are CONSULTATION flows - FP directives are reference material for when AI needs guidance, not mandatory execution workflows",
        "FP flows show available reference directives, not required execution paths - AI consults them on-demand when uncertain about complex FP patterns"
      ],
      "implementation_notes": [
        "Returns: Array of flow objects with all fields (id, from_directive, to_directive, flow_category, flow_type, condition_key, condition_value, condition_description, priority, description)",
        "All parameters are optional - can combine filters for targeted queries",
        "Example: get_directive_flows(flow_category='fp') returns all FP consultation flows",
        "Example: get_directive_flows(flow_category='git', flow_type='conditional') returns git conditional flows",
        "Query: SELECT * FROM directive_flow WHERE 1=1 [AND flow_category=?] [AND flow_type=?] [AND from_directive=?] [AND to_directive=?]",
        "Complements existing navigation helpers which are workflow-focused (what's next during execution)",
        "Use for: Browsing flows by category, analyzing flow structure, debugging, querying specific flow paths",
        "Differs from get_next_directives_from_status: That evaluates conditions for workflow navigation, this is pure query"
      ],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "search_fp_references",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "keyword",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Keyword to search in directive names, descriptions, and intent_keywords"
        },
        {
          "name": "category",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Category filter (e.g., 'purity', 'error_handling', 'functional_composition')"
        },
        {
          "name": "pattern",
          "type": "string",
          "required": false,
          "default": null,
          "description": "FP pattern name (e.g., 'monad', 'option', 'curry', 'lazy')"
        }
      ],
      "purpose": "Get FP directives available for consultation from ANY context. Handles wildcard '*' reference_consultation flows. Returns FP directives AI can consult as reference material DURING any operation.",
      "error_handling": "Returns empty array if no matches found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "FP directives are REFERENCE material for when AI is uncertain about implementation details",
        "These are NOT workflow steps - they're available on-demand for guidance",
        "AI writes FP code naturally - only consult these when genuinely uncertain about complex patterns"
      ],
      "implementation_notes": [
        "Returns: Array of FP directive objects with usage descriptions from flows",
        "Query: SELECT d.*, df.description as usage_hint FROM directives d JOIN directive_flow df ON d.name = df.to_directive WHERE df.from_directive = '*' AND df.flow_type = 'reference_consultation' AND d.type = 'fp'",
        "Wildcard '*' means: Available from ANY context (not sequential workflow)",
        "Optional filters: keyword match (directive name, description, intent_keywords), category filter, pattern filter",
        "Example: search_fp_references(keyword='null') returns ['fp_null_elimination', 'fp_optionals']",
        "Example: search_fp_references(category='error_handling') returns all error handling FP directives",
        "Example: search_fp_references(pattern='monad') returns monadic FP directives",
        "Use when: AI needs FP guidance during coding, uncertain about implementation pattern",
        "Implementation should also query and include directive-specific preferences from directive_preferences table (if any exist for each directive)"
      ],
      "target_database": "core",
      "used_by_directives": []
    },
    {
      "name": "get_contextual_utilities",
      "file_path": "TODO_helpers/core/module.py",
      "parameters": [
        {
          "name": "current_directive",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Current directive being executed (optional - if null, returns only wildcard '*' utilities)"
        },
        {
          "name": "condition",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Condition key to filter by (e.g., 'user_correction_detected')"
        }
      ],
      "purpose": "Get utility directives available in current context. Handles wildcard '*' utility and conditional flows. Returns cross-cutting utilities AI can invoke from any directive.",
      "error_handling": "Returns empty array if no utilities match filters",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Utilities are cross-cutting concerns available across directives",
        "Wildcard '*' utilities can be called from ANY directive context",
        "Conditional utilities trigger when specific conditions are met"
      ],
      "implementation_notes": [
        "Returns: Array of utility flow objects with to_directive, condition_key, condition_value, description",
        "Query: SELECT * FROM directive_flow WHERE (from_directive = '*' OR from_directive = ?) AND flow_type IN ('utility', 'conditional') AND (condition_key = ? OR ? IS NULL)",
        "Wildcard '*' means: Available from ANY directive (not workflow-specific)",
        "If current_directive provided: includes both '*' utilities AND directive-specific utilities",
        "If current_directive NULL: returns only '*' utilities",
        "If condition provided: filters to utilities matching that condition",
        "Example: get_contextual_utilities(current_directive='project_file_write', condition='user_correction_detected') returns user_preferences_learn",
        "Example: get_contextual_utilities(current_directive='project_task_create') returns project_notes_log (available from any context)",
        "Use when: AI detects condition trigger (user correction, error logging need, etc.)",
        "Does NOT retrieve current status internally - utilities are context-agnostic or triggered by explicit conditions"
      ],
      "target_database": "core",
      "used_by_directives": []
    }
  ],
  "metadata": {
    "file": "helpers-core.json",
    "count": 38,
    "first_helper": "core_get_allowed_db_enum",
    "status": "UPDATED - removed get_directive_content (useless middleman), removed status_object/work_context parameters, added wildcard-aware helpers",
    "mapped_helpers": 15,
    "unmapped_helpers": 23,
    "note": "23 helpers are generic AI query/navigation tools (schema queries, generic helper lookups, CHECK constraint validation, wildcard flow queries) - intentionally empty. 15 helpers mapped to directives (primarily aifp_help for browsing/querying, aifp_status and completion directives for flow navigation, conditional routing helpers). Status-passing helpers fixed to retrieve status internally. get_directive_content removed - AI should read MD files directly.",
    "total_mappings": 26,
    "last_updated": "2026-01-10"
  }
}