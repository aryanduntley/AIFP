{
  "helpers": [
    {
      "name": "get_current_commit_hash",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "project_root",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project directory path"
        }
      ],
      "purpose": "Get current Git HEAD commit hash",
      "error_handling": "Return null if not Git repository",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Sub-helper (is_tool: false) - called internally, not exposed as MCP tool",
        "NEXT STEP: After calling, store hash in project.last_known_git_hash using project_update_git_status()",
        "NEXT STEP: Compare with stored project.last_known_git_hash - if differs, external commits occurred",
        "CHECK: If hash differs from stored value, must call git_detect_external_changes directive to analyze impact",
        "CHECK: Handle null case (Git unavailable) - skip Git tracking or prompt user to initialize Git",
        "RELATED HELPERS: project_update_git_status() stores hash in project table after this call",
        "RELATED HELPERS: detect_external_changes() analyzes impact when hash mismatch detected",
        "RELATED HELPERS: get_current_branch() often called together for complete Git context",
        "WORKFLOW: Session boot → git_sync_state → get_current_commit_hash() → compare hashes → trigger detection if mismatch",
        "WORKFLOW: git_init → setup repo → get_current_commit_hash() → project_update_git_status() → establish baseline",
        "DIRECTIVE: Used by git_init (sequence_order: 3) - establishes baseline hash after repository initialized",
        "DIRECTIVE: Used by git_sync_state (sequence_order: 1) - critical first step to detect external changes",
        "DIRECTIVE FLOW: git_init → get_current_hash → update_project_last_known_git_hash → create_git_tables → report_success",
        "DIRECTIVE FLOW: git_sync_state → get_current_git_hash → compare_hashes → if hash_differs → trigger git_detect_external_changes",
        "DIRECTIVE FLOW: If no hash mismatch → git_sync_state updates timestamp only (project.last_git_sync)",
        "COMMON WORKFLOWS: After any external Git operation (commits outside AIFP), hash comparison reveals changes"
      ],
      "implementation_notes": [
        "Returns string commit hash (40-char SHA-1) or null if Git unavailable",
        "Uses subprocess to run: git rev-parse HEAD",
        "No database writes - pure Git query"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_init",
          "execution_context": "get_current_hash_after_init",
          "sequence_order": 3,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Get current Git HEAD to store in project.last_known_git_hash for external change tracking"
        },
        {
          "directive_name": "git_sync_state",
          "execution_context": "get_current_git_hash",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Get current Git HEAD to compare with stored hash and detect external changes"
        }
      ]
    },
    {
      "name": "get_current_branch",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "project_root",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project directory path"
        }
      ],
      "purpose": "Get current Git branch name",
      "error_handling": "Return null if Git unavailable",
      "is_tool": false,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Sub-helper (is_tool: false) - called for display purposes, not stored in database",
        "DATABASE CONTEXT: Git itself tracks current branch - no need to duplicate in project.db",
        "NEXT STEP: Display in success reports after git_init or git_sync_state completes",
        "NEXT STEP: Often combined with get_current_commit_hash() for complete Git context in user messages",
        "CHECK: Is user on detached HEAD? Handle differently (shows commit hash instead of branch name)",
        "CHECK: Before git_create_branch, verify base branch matches expectations (usually 'main' or 'master')",
        "RELATED HELPERS: get_current_commit_hash() for commit info (often called together for Git status)",
        "RELATED HELPERS: get_git_status() provides comprehensive snapshot including branch + tracking status",
        "RELATED HELPERS: list_active_branches() shows all AIFP work branches from work_branches table",
        "WORKFLOW: git_init → repository setup complete → report_success (display branch + tracking status)",
        "WORKFLOW: git_sync_state → sync complete → return_success (show current_branch + commit_hash)",
        "DIRECTIVE: Used by git_init (sequence_order: 4, optional) - part of success report",
        "DIRECTIVE: Used by git_sync_state (sequence_order: 3, optional) - part of sync confirmation",
        "DIRECTIVE FLOW: git_init → tables_created → report_success → show [git_status, current_branch, tracking_status]",
        "DIRECTIVE FLOW: git_sync_state → sync_complete → return_success → show [current_branch, commit_hash]",
        "COMMON WORKFLOWS: After any Git operation → display current context (branch + commit) to user",
        "COMMON WORKFLOWS: Before creating work branch → verify user is on expected base branch (main/master)"
      ],
      "implementation_notes": [
        "Returns string branch name or null if Git unavailable",
        "Uses subprocess to run: git branch --show-current",
        "Returns commit hash if in detached HEAD state",
        "No database writes - pure Git query for display purposes"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_init",
          "execution_context": "report_success",
          "sequence_order": 4,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Display current branch in success report after Git initialization"
        },
        {
          "directive_name": "git_sync_state",
          "execution_context": "return_success",
          "sequence_order": 3,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Display current branch in sync success report"
        }
      ]
    },
    {
      "name": "get_git_status",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "project_root",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project directory path"
        }
      ],
      "purpose": "Get comprehensive Git state snapshot (orchestrator)",
      "error_handling": "Returns git_available=false if Git unavailable",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Orchestrator tool (is_tool: true) - combines multiple Git queries into comprehensive snapshot",
        "DATABASE CONTEXT: Does NOT write to database - pure Git query for status display to user",
        "NEXT STEP: Display comprehensive report in git_init success message (branch, tracking, uncommitted files)",
        "NEXT STEP: Use file lists (staged/unstaged/untracked) to warn user before destructive operations",
        "NEXT STEP: Check ahead/behind counts - inform user if push/pull needed",
        "CHECK: Are there unstaged changes? May indicate work in progress that shouldn't be committed",
        "CHECK: Are there untracked files? May need to be added to Git or .gitignore",
        "CHECK: Is branch ahead of remote? User may need to push commits",
        "CHECK: Is branch behind remote? User may need to pull updates before continuing",
        "CHECK: Handle git_available=false case - Git not installed or not a repository",
        "RELATED HELPERS: get_current_commit_hash() returns just hash (subset of this helper)",
        "RELATED HELPERS: get_current_branch() returns just branch (subset of this helper)",
        "RELATED HELPERS: detect_external_changes() analyzes impact of detected changes",
        "WORKFLOW: git_init complete → report_success → get_git_status() → display comprehensive state to user",
        "WORKFLOW: Before destructive operations → get_git_status() → verify clean working directory",
        "DIRECTIVE: Used by git_init (sequence_order: 4, optional) - comprehensive status in success report",
        "DIRECTIVE FLOW: git_init → tables_created → report_success → show [git_status, current_branch, tracking_status]",
        "COMMON WORKFLOWS: Session boot → optionally call for detailed Git state (if debugging or verbose mode)",
        "COMMON WORKFLOWS: Before major operations (merge, rebase) → verify no uncommitted work",
        "COMMON WORKFLOWS: Troubleshooting Git issues → comprehensive snapshot for diagnosis"
      ],
      "implementation_notes": [
        "Returns object: {git_available, branch, commit_hash, remote_tracking, ahead, behind, staged_files[], unstaged_files[], untracked_files[]}",
        "Uses multiple git commands: git branch --show-current, git rev-parse HEAD, git status --porcelain, git rev-list --left-right --count",
        "Returns git_available=false if Git not installed/not a repository",
        "Comprehensive orchestrator - combines get_current_commit_hash + get_current_branch + file status"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_init",
          "execution_context": "report_success",
          "sequence_order": 4,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Show comprehensive Git status (branch, tracking status, uncommitted files) in initialization success report"
        }
      ]
    },
    {
      "name": "detect_external_changes",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "project_root",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project directory path"
        }
      ],
      "purpose": "Compare current Git HEAD with project.last_known_git_hash",
      "error_handling": "Return empty changes if Git unavailable",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Orchestrator tool - implements git_detect_external_changes directive entirely",
        "DATABASE CONTEXT: Queries project.last_known_git_hash, compares with current HEAD, analyzes theme/function impact",
        "NEXT STEP: Present changes to user - show changed_files, affected_themes, affected_functions, commit_range",
        "NEXT STEP: After user acknowledges changes, call project_update_git_status() to update stored hash",
        "NEXT STEP: If organizational_impact detected → suggest reconciliation (update_themes, update_flows, mark_functions_for_review)",
        "CHECK: If no_last_hash → store current hash as baseline (first run case)",
        "CHECK: If hash_matches → return 'No external changes detected'",
        "CHECK: If hash_differs → analyze impact using git diff + database queries",
        "CHECK: If too_many_changes → present summary instead of full diff, offer detailed analysis",
        "RELATED HELPERS: get_current_commit_hash() gets current hash for comparison",
        "RELATED HELPERS: project_update_git_status() updates stored hash after user acknowledges changes",
        "RELATED HELPERS: Query project.db files/functions/themes tables to assess organizational impact",
        "WORKFLOW: git_sync_state → get_current_git_hash → compare_hashes → if differs → detect_external_changes",
        "WORKFLOW: detect_external_changes → git_diff_names → query_file_themes → query_file_functions → build_impact_report",
        "WORKFLOW: changes_analyzed → present_to_user → user_acknowledged → update_project_table",
        "DIRECTIVE: Implements git_detect_external_changes directive (self_implementation, sequence_order: 1)",
        "DIRECTIVE: Called by git_sync_state (sequence_order: 2) when hash mismatch detected",
        "DIRECTIVE FLOW: git_sync_state → compare_hashes → if hash_differs → trigger_external_change_detection (this helper)",
        "DIRECTIVE FLOW: detect_external_changes → present_to_user → suggest_reconciliation if organizational impact",
        "COMMON WORKFLOWS: Session boot → git_sync_state detects hash mismatch → this helper analyzes impact",
        "COMMON WORKFLOWS: After user commits outside AIFP → hash differs → show affected themes/flows",
        "WARNING: Must call project_update_git_status() after user acknowledges - keeps tracking in sync"
      ],
      "implementation_notes": [
        "Returns object: {hash_changed, old_hash, new_hash, changed_files[], affected_themes[], affected_functions[], commit_range, organizational_impact}",
        "Uses git diff {old_hash}...{new_hash} --name-only to get changed files",
        "Queries project.db to map changed files to themes/flows/functions",
        "Returns empty changes if Git unavailable"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_detect_external_changes",
          "execution_context": "self_implementation",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Tool that implements the git_detect_external_changes directive - compares stored hash with current HEAD, analyzes changed files, queries theme/function impact"
        },
        {
          "directive_name": "git_sync_state",
          "execution_context": "compare_hashes",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Detect if external changes occurred during sync - triggers git_detect_external_changes if hash differs"
        }
      ]
    },
    {
      "name": "create_user_branch",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "user",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Username"
        },
        {
          "name": "purpose",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Branch purpose description"
        }
      ],
      "purpose": "Create work branch following aifp-{user}-{number} convention",
      "error_handling": "Auto-increment number if branch exists",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Orchestrator tool - implements git_create_branch directive entirely",
        "DATABASE CONTEXT: Creates Git branch + stores metadata in work_branches table (branch_name, user_name, purpose, status=active)",
        "NEXT STEP: After branch created, user can start working on task-specific code",
        "NEXT STEP: Optionally link branch to specific tasks/themes using tasks.git_branch column",
        "NEXT STEP: After work complete, use git_merge_branch to merge back to main with FP-powered conflict resolution",
        "CHECK: Verify base branch before creating (usually main or master) - avoid creating from feature branches",
        "CHECK: If branch_exists → auto-increment number (aifp-alice-002, aifp-alice-003, etc.)",
        "CHECK: If uncommitted_changes → prompt user to commit or stash before branching",
        "CHECK: User parameter should come from get_user_name_for_branch() if not explicitly provided",
        "RELATED HELPERS: get_user_name_for_branch() detects username from git config/environment/system",
        "RELATED HELPERS: list_active_branches() shows all AIFP work branches from work_branches table",
        "RELATED HELPERS: git_merge_branch() merges work branch back to main with FP intelligence",
        "WORKFLOW: git_create_branch → get_user_identification → format_branch_name (aifp-{user}-{number:03d}) → create_git_branch",
        "WORKFLOW: git_branch_created → store_branch_metadata (work_branches table) → optional task link → report_success",
        "DIRECTIVE: Implements git_create_branch directive (self_implementation, sequence_order: 1)",
        "DIRECTIVE FLOW: git_create_branch → branch created → loop back to aifp_status",
        "DIRECTIVE FLOW: Typically: project_task_decomposition → git_create_branch → aifp_status",
        "COMMON WORKFLOWS: Multi-user collaboration → create separate branches per user/AI instance",
        "COMMON WORKFLOWS: Feature development → git_create_branch → implement → git_merge_branch",
        "COMMON WORKFLOWS: Before major refactoring → create branch → test changes → merge if successful",
        "WARNING: Branch naming convention aifp-{user}-{number} must be preserved - used for AIFP branch identification"
      ],
      "implementation_notes": [
        "Returns object: {success, branch_name, user, purpose, linked_tasks[]}",
        "Format: aifp-{user}-{number:03d} (e.g., aifp-alice-001, aifp-bob-042)",
        "Queries MAX(branch_number) FROM work_branches WHERE user_name = ? to get next number",
        "Creates Git branch: git checkout -b {branch_name} main",
        "Inserts into work_branches table: {branch_name, user_name, purpose, status=active, created_from=main}"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_create_branch",
          "execution_context": "self_implementation",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {
            "user": "workflow.detected_user",
            "purpose": "workflow.branch_purpose"
          },
          "description": "Tool that implements git_create_branch directive - detects user, formats branch name (aifp-{user}-{number}), creates Git branch, stores metadata in work_branches table"
        }
      ]
    },
    {
      "name": "get_user_name_for_branch",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [],
      "purpose": "Detect username from git config/environment/system",
      "error_handling": "Fallback to \"user\" if all detection fails",
      "is_tool": false,
      "is_sub_helper": true,
      "return_statements": [
        "DATABASE CONTEXT: Sub-helper (is_sub_helper: true) - called internally by create_user_branch()",
        "DATABASE CONTEXT: Detection order: git config user.name → env USER → env USERNAME → system username → fallback 'user'",
        "NEXT STEP: Pass detected username to create_user_branch(user, purpose) for branch creation",
        "NEXT STEP: Username formatted into branch name: aifp-{user}-{number} (e.g., aifp-alice-001)",
        "CHECK: If all detection methods fail, returns 'user' as fallback - never returns null",
        "CHECK: Git config user.name preferred (most accurate for development context)",
        "CHECK: Environment variables (USER, USERNAME) used if git config not set",
        "RELATED HELPERS: create_user_branch() calls this to detect user parameter if not explicitly provided",
        "RELATED HELPERS: list_active_branches() can filter by detected username to show user's branches",
        "WORKFLOW: git_create_branch → get_user_identification → get_user_name_for_branch() → use_provided_user or detect_user",
        "WORKFLOW: user_determined → get_next_branch_number → format_branch_name (aifp-{user}-{number:03d})",
        "DIRECTIVE: Used by git_create_branch (get_user_identification, sequence_order: 1) - first step in branch creation",
        "DIRECTIVE FLOW: git_create_branch starts with get_user_identification → this helper provides username",
        "COMMON WORKFLOWS: Multi-user/multi-AI projects → each user/AI instance gets unique branch naming",
        "COMMON WORKFLOWS: Automated branch creation → detect user automatically without prompting"
      ],
      "implementation_notes": [
        "Returns string username (never null) - guarantees 'user' fallback",
        "Detection order: git config user.name → env USER → env USERNAME → os.getlogin() → fallback 'user'",
        "Used to format branch names: aifp-{user}-{number:03d}"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_create_branch",
          "execution_context": "get_user_identification",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Detect username from git config, environment variables (USER, USERNAME), or system user - used to format branch name aifp-{user}-{number}"
        }
      ]
    },
    {
      "name": "list_active_branches",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [],
      "purpose": "List all AIFP work branches from work_branches table",
      "error_handling": "Return empty array if table doesn't exist",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Queries work_branches table - shows all AIFP work branches (aifp-{user}-{number} naming)",
        "DATABASE CONTEXT: Does NOT query Git directly - shows metadata stored during git_create_branch",
        "NEXT STEP: Review active branches before creating new one - avoid duplicate work",
        "NEXT STEP: Identify branches ready for merging (status, purpose, user)",
        "NEXT STEP: Use branch_name to call git_merge_branch when work complete",
        "CHECK: Are there abandoned branches (created long ago, never merged)? May need cleanup",
        "CHECK: Are there multiple branches for same purpose? May indicate collaboration or duplicated effort",
        "CHECK: Returns empty array if work_branches table doesn't exist (Git not initialized)",
        "RELATED HELPERS: create_user_branch() creates branches and adds them to work_branches table",
        "RELATED HELPERS: git_merge_branch() merges branches and updates status to 'merged'",
        "RELATED HELPERS: get_user_name_for_branch() detects current user for filtering branches",
        "WORKFLOW: Before git_create_branch → list_active_branches() → check if similar branch exists",
        "WORKFLOW: Review branches → identify completed work → git_merge_branch for each",
        "DIRECTIVE: Not used by any directive - standalone query tool for AI",
        "COMMON WORKFLOWS: Multi-user collaboration → list_active_branches() → see who's working on what",
        "COMMON WORKFLOWS: Branch management → periodically review active branches → merge or delete stale ones",
        "COMMON WORKFLOWS: Before starting new feature → check if branch already exists for that purpose"
      ],
      "implementation_notes": [
        "Returns array of objects: [{branch_name, user_name, purpose, status, created_at, created_from, merged_at}, ...]",
        "Queries SELECT * FROM work_branches WHERE status = 'active' (or all if filter not applied)",
        "Returns empty array if table doesn't exist"
      ],
      "target_database": "project",
      "used_by_directives": []
    },
    {
      "name": "detect_conflicts_before_merge",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "source_branch",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Branch to merge from"
        },
        {
          "name": "project_root",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project directory path"
        }
      ],
      "purpose": "FP-powered conflict analysis before merging (complex orchestrator)",
      "error_handling": "Fall back to file-level conflicts if DB query fails",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Complex orchestrator - implements git_detect_conflicts directive entirely",
        "DATABASE CONTEXT: Queries project.db from BOTH branches to analyze function-level conflicts with FP metadata",
        "DATABASE CONTEXT: Analyzes file conflicts, function conflicts, database conflicts with confidence scores",
        "NEXT STEP: If no_conflicts → proceed directly to git_merge_branch",
        "NEXT STEP: If conflicts_detected and all auto_resolvable (confidence >0.8) → prompt user for auto-resolution approval",
        "NEXT STEP: If manual_conflicts_remain → present to user via project_user_referral with AI recommendations",
        "CHECK: Categorize changes: files_only_in_source, files_only_in_target, files_modified_in_both",
        "CHECK: For files_modified_in_both → analyze function signatures, purity levels, dependencies, test results",
        "CHECK: Apply FP rules: one_pure_one_impure → prefer_pure; both_pure_different_logic → compare_tests",
        "CHECK: If project_db_query_fails → fall back to file-level conflict detection only",
        "RELATED HELPERS: merge_with_fp_intelligence() calls this before attempting merge",
        "RELATED HELPERS: Queries functions table for purity metadata from both branches",
        "RELATED HELPERS: Queries interactions table for dependency analysis",
        "WORKFLOW: git_detect_conflicts → git_diff_branches → categorize_changes → analyze_function_conflicts → apply_fp_analysis",
        "WORKFLOW: fp_analysis_complete → check_database_conflicts → build_conflict_report → return_analysis",
        "DIRECTIVE: Implements git_detect_conflicts directive (self_implementation, sequence_order: 1)",
        "DIRECTIVE: Called by git_merge_branch (call_git_detect_conflicts, sequence_order: 2) before merge attempt",
        "DIRECTIVE FLOW: git_detect_conflicts → if auto_resolvable → git_merge_branch",
        "DIRECTIVE FLOW: git_detect_conflicts → if manual_resolution_needed → project_user_referral",
        "COMMON WORKFLOWS: Before merge → detect conflicts → assess auto-resolvability → decide merge strategy",
        "COMMON WORKFLOWS: FP purity analysis enables high-confidence automatic conflict resolution (>0.8 threshold)",
        "WARNING: Queries project.db from both branches - ensure both branches have FP metadata populated"
      ],
      "implementation_notes": [
        "Returns object: {file_conflicts[], function_conflicts[], db_conflicts[], auto_resolvable_count, manual_review_count, confidence_scores{}, ai_recommendations{}}",
        "Uses git diff to identify changed files",
        "Extracts project.db from both branches, queries functions/interactions/themes for FP analysis",
        "Applies FP purity rules to assign confidence scores (>0.8 = auto-resolvable)",
        "Falls back to file-level analysis if database queries fail"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_detect_conflicts",
          "execution_context": "self_implementation",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Tool that implements git_detect_conflicts directive - performs dry-run merge analysis, compares branches at file/function level, queries function metadata (purity, dependencies, tests), classifies conflicts, assigns confidence scores for auto-resolution"
        },
        {
          "directive_name": "git_merge_branch",
          "execution_context": "call_git_detect_conflicts",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Called before merge to analyze potential conflicts and determine if auto-resolution possible - prevents merge failures"
        }
      ]
    },
    {
      "name": "merge_with_fp_intelligence",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "source_branch",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Branch to merge from"
        },
        {
          "name": "project_root",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project directory path"
        }
      ],
      "purpose": "Git merge with FP-powered conflict auto-resolution (complex orchestrator)",
      "error_handling": "Abort merge (git merge --abort) if unresolvable",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Complex orchestrator - implements git_merge_branch directive entirely",
        "DATABASE CONTEXT: Calls detect_conflicts_before_merge → auto-resolves high-confidence conflicts → logs to merge_history table",
        "DATABASE CONTEXT: Updates work_branches status=merged after successful merge",
        "NEXT STEP: After merge_successful → log_merge_history (conflicts_detected, auto_resolved, manual_resolved counts)",
        "NEXT STEP: After history_logged → update_work_branches (status=merged, merged_at=now)",
        "NEXT STEP: After all complete → loop back to aifp_status for project state refresh",
        "CHECK: Validate merge request - branch_not_found → return error",
        "CHECK: Validate uncommitted_changes → prompt_commit_first before merging",
        "CHECK: If no_conflicts → perform_merge directly (git merge {branch_name})",
        "CHECK: If all_auto_resolvable (>0.8 confidence) → prompt_auto_resolution before applying",
        "CHECK: If manual_conflicts_remain → present_conflicts_to_user with AI recommendations (purity levels, test results, dependencies)",
        "CHECK: If merge fails → abort_merge (git merge --abort) and log failure",
        "RELATED HELPERS: detect_conflicts_before_merge() performs FP-powered conflict analysis first",
        "RELATED HELPERS: project_update_git_status() updates Git hash after merge completes",
        "RELATED HELPERS: sync_git_state() called after merge to update project.last_known_git_hash",
        "WORKFLOW: git_merge_branch → validate → call_git_detect_conflicts → analyze_auto_resolvable → apply_auto_resolutions",
        "WORKFLOW: manual_conflicts_remain → present_conflicts_to_user → apply_user_resolutions → complete_merge",
        "WORKFLOW: merge_successful → log_merge_history → update_work_branches → report_success",
        "DIRECTIVE: Implements git_merge_branch directive (self_implementation, sequence_order: 1)",
        "DIRECTIVE FLOW: git_merge_branch → complete → loop back to aifp_status",
        "DIRECTIVE FLOW: FP purity rules: prefer_pure_functions, prefer_more_tests, keep_both_if_equal",
        "COMMON WORKFLOWS: Feature complete → git_merge_branch → FP auto-resolution → back to main",
        "COMMON WORKFLOWS: Multi-user collaboration → merge with confidence-based conflict resolution",
        "WARNING: Abort merge (git merge --abort) if unresolvable conflicts detected",
        "WARNING: Ensure both branches have FP metadata populated for intelligent conflict resolution"
      ],
      "implementation_notes": [
        "Returns object: {success, merge_result, conflicts_resolved{auto, manual}, commit_hash, aborted}",
        "Calls detect_conflicts_before_merge() first to analyze conflicts",
        "Auto-resolves conflicts >0.8 confidence using FP purity rules",
        "Presents low-confidence conflicts to user with recommendations",
        "Logs to merge_history table: {source_branch, conflicts_detected, auto_resolved, manual_resolved, resolution_details_json, merged_by, commit_hash}",
        "Updates work_branches: {status=merged, merged_at=now}",
        "Calls git merge --abort if merge fails or conflicts unresolvable"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_merge_branch",
          "execution_context": "self_implementation",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Tool that implements git_merge_branch directive - validates merge request, calls detect_conflicts_before_merge, auto-resolves high-confidence conflicts (>0.8), presents manual conflicts to user with AI recommendations, logs merge history, updates work_branches status"
        }
      ]
    },
    {
      "name": "sync_git_state",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [
        {
          "name": "project_root",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Project directory path"
        }
      ],
      "purpose": "Update project.last_known_git_hash with current Git HEAD",
      "error_handling": "Log warning if Git unavailable, continue with cached",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "DATABASE CONTEXT: Orchestrator tool - implements git_sync_state directive entirely",
        "DATABASE CONTEXT: Updates project.last_known_git_hash and project.last_git_sync timestamp",
        "DATABASE CONTEXT: Critical for external change detection - keeps baseline hash current",
        "NEXT STEP: If no_last_hash (first run) → initialize hash in project table",
        "NEXT STEP: If hash_differs → trigger git_detect_external_changes directive to analyze impact",
        "NEXT STEP: If hash_same → update timestamp only (project.last_git_sync = now)",
        "NEXT STEP: After sync_complete → return_success (show current_branch, commit_hash to user)",
        "CHECK: Compare stored project.last_known_git_hash with current Git HEAD",
        "CHECK: If Git unavailable → log warning, continue with cached hash (don't fail)",
        "CHECK: If database_locked → retry with exponential backoff",
        "RELATED HELPERS: get_current_commit_hash() gets current Git HEAD for comparison",
        "RELATED HELPERS: project_update_git_status() updates project table with new hash + timestamp",
        "RELATED HELPERS: detect_external_changes() triggered if hash mismatch detected",
        "RELATED HELPERS: get_current_branch() called to display branch name in success message",
        "WORKFLOW: git_sync_state → get_current_git_hash → compare_hashes → detect_external_changes if differs",
        "WORKFLOW: hash_same → update_sync_timestamp → return_success",
        "DIRECTIVE: Implements git_sync_state directive (self_implementation, sequence_order: 1)",
        "DIRECTIVE FLOW: Called after project_file_write, project_function_write, git_merge_branch to keep tracking current",
        "DIRECTIVE FLOW: Session boot → git_sync_state → ensures baseline hash is current before work begins",
        "COMMON WORKFLOWS: Session start → git_sync_state → detect external commits since last session",
        "COMMON WORKFLOWS: After AI commits code → git_sync_state → update stored hash",
        "COMMON WORKFLOWS: After git_merge_branch → git_sync_state → update hash to merged commit",
        "WARNING: If Git unavailable, logs warning but continues - external change detection disabled until Git available"
      ],
      "implementation_notes": [
        "Returns object: {success, hash_synced, external_changes_detected, current_branch, commit_hash}",
        "Calls get_current_commit_hash() to get Git HEAD",
        "Queries project.last_known_git_hash for comparison",
        "If differs → calls detect_external_changes()",
        "Updates project.last_known_git_hash and project.last_git_sync",
        "Logs warning if Git unavailable, continues with cached hash"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_sync_state",
          "execution_context": "self_implementation",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Tool that implements git_sync_state directive - gets current Git HEAD, compares with stored hash, triggers external change detection if hash differs, updates last_known_git_hash and last_git_sync timestamp"
        }
      ]
    },
    {
      "name": "project_update_git_status",
      "file_path": "TODO_helpers/project/module.py",
      "parameters": [],
      "purpose": "Update last_known_git_hash and last_git_sync in project table",
      "error_handling": "",
      "is_tool": false,
      "is_sub_helper": true,
      "return_statements": [
        "DATABASE CONTEXT: Sub-helper (is_sub_helper: true) - convenience wrapper for common Git sync operation",
        "DATABASE CONTEXT: Updates two fields in project table: last_known_git_hash and last_git_sync timestamp",
        "DATABASE CONTEXT: Critical for external change detection baseline - must be kept current",
        "NEXT STEP: After updating, stored hash becomes new baseline for future comparisons",
        "NEXT STEP: Called after git_init to establish initial tracking baseline",
        "NEXT STEP: Called after user acknowledges external changes to update baseline",
        "NEXT STEP: Called by git_sync_state to keep hash current after operations",
        "CHECK: Must be called after any operation that changes Git state (commits, merges, external changes acknowledged)",
        "CHECK: Failure to update leaves stale hash → false positives in external change detection",
        "RELATED HELPERS: get_current_commit_hash() provides hash value to store",
        "RELATED HELPERS: detect_external_changes() calls this after user acknowledges changes",
        "RELATED HELPERS: sync_git_state() calls this to update hash and timestamp",
        "WORKFLOW: git_init → get_current_commit_hash → project_update_git_status → store initial baseline",
        "WORKFLOW: detect_external_changes → user_acknowledged → project_update_git_status → update baseline",
        "WORKFLOW: git_sync_state → project_update_git_status → keep hash and timestamp current",
        "DIRECTIVE: Used by git_init (update_project_last_known_git_hash, sequence_order: 3) - establish baseline",
        "DIRECTIVE: Used by git_detect_external_changes (update_project_table, sequence_order: 4) - update after acknowledgment",
        "DIRECTIVE: Used by git_sync_state (initialize_hash_or_update_sync_timestamp, sequence_order: 2) - maintain currency",
        "DIRECTIVE FLOW: git_init → create_git_tables → project_update_git_status → report_success",
        "DIRECTIVE FLOW: git_detect_external_changes → user_acknowledged → project_update_git_status → suggest_reconciliation",
        "DIRECTIVE FLOW: git_sync_state → compare_hashes → project_update_git_status → return_success",
        "COMMON WORKFLOWS: Any Git operation complete → project_update_git_status → baseline refreshed",
        "WARNING: Must call after user acknowledges external changes - keeps tracking synchronized with reality"
      ],
      "implementation_notes": [
        "Returns object: {success: true, hash: string, sync_time: timestamp}",
        "Updates project table: SET last_known_git_hash = ?, last_git_sync = NOW()",
        "Gets current hash from get_current_commit_hash() if not provided",
        "Convenience wrapper - reduces boilerplate for common operation"
      ],
      "target_database": "project",
      "used_by_directives": [
        {
          "directive_name": "git_init",
          "execution_context": "update_project_last_known_git_hash",
          "sequence_order": 3,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Store initial Git hash in project table after repository initialization or integration"
        },
        {
          "directive_name": "git_detect_external_changes",
          "execution_context": "update_project_table",
          "sequence_order": 4,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Update stored hash after user acknowledges external changes - keeps tracking in sync"
        },
        {
          "directive_name": "git_sync_state",
          "execution_context": "initialize_hash_or_update_sync_timestamp",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Update last_known_git_hash and last_git_sync timestamp in project table"
        }
      ]
    }
  ],
  "metadata": {
    "file": "helpers-git.json",
    "count": 11,
    "status": "Phase 8 Priority 1 COMPLETE - All 11 git helpers mapped to 6 git directives",
    "mapped_helpers": 11,
    "unmapped_helpers": 0,
    "total_mappings": 17,
    "last_updated": "2025-12-20"
  }
}