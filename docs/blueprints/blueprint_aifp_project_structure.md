# AIFP Project Structure Blueprint

## Overview

This blueprint defines the `.aifp/` project folder structure, the ProjectBlueprint.md document, and the enhanced status/initialization workflow that enables context-aware project management across AI sessions.

---

## 1. Directory Structure

```
<project-root>/
‚îú‚îÄ‚îÄ .aifp/
‚îÇ   ‚îú‚îÄ‚îÄ ProjectBlueprint.md          # High-level project overview (human & AI readable)
‚îÇ   ‚îú‚îÄ‚îÄ project.db                   # Project state database
‚îÇ   ‚îú‚îÄ‚îÄ user_preferences.db          # User customization database
‚îÇ   ‚îú‚îÄ‚îÄ config.json                  # Project-specific AIFP configuration
‚îÇ   ‚îî‚îÄ‚îÄ backups/                     # Optional: automated backups
‚îÇ       ‚îú‚îÄ‚îÄ project.db.backup
‚îÇ       ‚îî‚îÄ‚îÄ ProjectBlueprint.md.backup
‚îú‚îÄ‚îÄ .git/
‚îÇ   ‚îî‚îÄ‚îÄ .aifp/                       # Optional: archived project state
‚îÇ       ‚îú‚îÄ‚îÄ ProjectBlueprint.md      # Snapshot for recovery
‚îÇ       ‚îî‚îÄ‚îÄ project.db.backup
‚îî‚îÄ‚îÄ src/                             # Actual project code
```

### Design Rationale

- **`.aifp/` at project root**: Primary location for active AIFP state
- **`.git/.aifp/` archive**: Optional backup/recovery mechanism for project resets
- **ProjectBlueprint.md**: Markdown for human readability and AI context loading

---

## 2. ProjectBlueprint.md Specification

### Purpose

The ProjectBlueprint.md serves as:
1. **High-level project overview** - Explains the idea, goals, and vision
2. **Context anchor** - First document AI reads in new sessions
3. **Evolution tracker** - Updated when project-wide changes occur
4. **Onboarding document** - Helps new developers/AI understand the project

### Structure Template

```markdown
# Project Blueprint: {Project Name}

**Version**: {version_number}
**Status**: {active|paused|completed|archived}
**Last Updated**: {YYYY-MM-DD}
**AIFP Compliance**: {strict|standard|relaxed}

---

## 1. Project Overview

### Idea
{1-3 paragraphs explaining the core project idea and motivation}

### Goals
- {Primary goal 1}
- {Primary goal 2}
- {Primary goal 3}

### Success Criteria
- {Criterion 1 with measurable outcome}
- {Criterion 2 with measurable outcome}

---

## 2. Technical Blueprint

### Language & Runtime
- **Primary Language**: {language}
- **Runtime/Framework**: {runtime/framework}
- **Build Tool**: {build_tool}

### Architecture Style
- **Paradigm**: Functional Procedural (AIFP)
- **Pattern**: {e.g., "Pure functions with explicit data flow"}
- **State Management**: {e.g., "Immutable data structures with Result/Option types"}

### Key Infrastructure
- {Infrastructure item 1}
- {Infrastructure item 2}
- {Infrastructure item 3}

---

## 3. Project Themes & Flows

### Themes
{AI-generated or user-defined thematic groupings}

1. **{Theme 1 Name}**
   - Purpose: {description}
   - Files: {key files}

2. **{Theme 2 Name}**
   - Purpose: {description}
   - Files: {key files}

### Flows
{Sequential execution patterns}

1. **{Flow 1 Name}**
   - Steps: {high-level steps}
   - Related Themes: {theme links}

---

## 4. Completion Path

### Stage 1: {Stage Name}
- Status: {pending|in_progress|completed}
- Key Milestones:
  - {Milestone 1}
  - {Milestone 2}

### Stage 2: {Stage Name}
- Status: {pending|in_progress|completed}
- Key Milestones:
  - {Milestone 1}
  - {Milestone 2}

### Stage 3: {Stage Name}
- Status: {pending|in_progress|completed}
- Key Milestones:
  - {Milestone 1}

---

## 5. Evolution History

### Version {version} - {date}
- **Change**: {description of major change}
- **Rationale**: {why this change was made}

### Version {version-1} - {date}
- **Change**: {description}
- **Rationale**: {why}

---

## 6. Key Decisions & Constraints

### Architectural Decisions
- {Decision 1}: {rationale}
- {Decision 2}: {rationale}

### Constraints
- {Constraint 1}: {impact}
- {Constraint 2}: {impact}

---

## 7. Notes & References

### Important Context
{Any context AI should always remember about this project}

### External References
- {Link to docs}
- {Link to research}

---

*Generated by AIFP v{version} on {date}*
```

---

## 3. Directive Enhancements

### 3.1 Enhanced `project_init` Directive

**Name**: `project_init`
**Type**: `project`
**Level**: 1
**Parent**: `aifp_run`

**Purpose**: Initialize new AIFP project with interactive ProjectBlueprint creation and database setup.

**Workflow**:

```json
{
  "trunk": "initialize_project",
  "branches": [
    {
      "step": "check_existing_state",
      "actions": [
        {"check": ".aifp/ folder exists", "if_exists": "call project_status"},
        {"check": ".git/.aifp/ folder exists", "if_exists": "prompt_restore_or_new"}
      ]
    },
    {
      "step": "interactive_blueprint_creation",
      "actions": [
        {"prompt": "What is the project name?", "store": "project.name"},
        {"prompt": "What is the project's core idea/purpose?", "store": "project.purpose"},
        {"prompt": "What are the primary goals? (Enter 3-5)", "store": "project.goals_json"},
        {"prompt": "What programming language?", "store": "infrastructure.language"},
        {"prompt": "What build tool/framework?", "store": "infrastructure.build_tool"},
        {"prompt": "What is the AIFP compliance level? (strict/standard/relaxed)", "store": "user_settings.fp_strictness_level"}
      ]
    },
    {
      "step": "create_project_structure",
      "actions": [
        {"create": ".aifp/ directory"},
        {"create": ".aifp/backups/ directory"},
        {"generate": "ProjectBlueprint.md from template"},
        {"initialize": "project.db with schema"},
        {"initialize": "user_preferences.db with schema"}
      ]
    },
    {
      "step": "populate_database",
      "actions": [
        {"insert": "project table (name, purpose, goals_json, version=1)"},
        {"insert": "infrastructure table (language, build_tool)"},
        {"insert": "completion_path table (default stages: Setup, Core Dev, Finalization)"},
        {"insert": "milestones table (initial milestone under Setup stage)"},
        {"insert": "user_settings table (fp_strictness_level)"}
      ]
    },
    {
      "step": "finalize",
      "actions": [
        {"backup": "ProjectBlueprint.md to .aifp/backups/"},
        {"backup": "project.db to .aifp/backups/"},
        {"report": "Project initialized successfully"}
      ]
    }
  ],
  "error_handling": {
    "on_failure": "prompt_user_for_manual_setup",
    "retry": "max 2 attempts"
  }
}
```

**Output**:
```
‚úÖ Project initialized: {ProjectName}
üìÅ Created: .aifp/ directory
üìÑ Created: ProjectBlueprint.md
üóÑÔ∏è  Initialized: project.db, user_preferences.db
üìä Completion path set up with {X} stages

Next steps:
1. Review ProjectBlueprint.md
2. Run 'aifp status' to see project overview
3. Begin with: {first milestone/task}
```

---

### 3.2 New `aifp_status` Directive

**Name**: `aifp_status`
**Type**: `project`
**Level**: 1
**Parent**: `aifp_run`

**Purpose**: Retrieve comprehensive project status with historical context for task continuation.

**Workflow**:

```json
{
  "trunk": "determine_project_state",
  "branches": [
    {
      "condition": "existing_project",
      "then": "call get_existing_project_status"
    },
    {
      "condition": "new_project_or_incomplete_init",
      "then": "call detect_and_init_project"
    }
  ],
  "error_handling": {
    "on_failure": "prompt_user_for_clarification",
    "retry": "max 1 attempt"
  }
}
```

#### 3.2.1 Sub-Directive: `get_existing_project_status`

**Execution Steps**:

1. **Load Project Blueprint**
   ```sql
   -- Read .aifp/ProjectBlueprint.md
   -- Parse: version, status, goals, themes, flows
   ```

2. **Load Infrastructure Context**
   ```sql
   SELECT type, value, description
   FROM infrastructure
   WHERE project_id = ?;
   ```

3. **Build Priority Status Tree**

   **Priority 1: Open Sidequests**
   ```sql
   -- Find open sidequests
   SELECT sq.id, sq.name, sq.status, sq.paused_task_id, sq.paused_subtask_id
   FROM sidequests sq
   WHERE sq.status IN ('pending', 'in_progress')
   ORDER BY sq.created_at ASC;

   -- For each sidequest:
   -- Get parent task or subtask
   SELECT t.name, t.status, t.description
   FROM tasks t
   WHERE t.id = sq.paused_task_id;

   -- Get all items for parent task/subtask
   SELECT i.name, i.status, i.description
   FROM items i
   WHERE i.reference_table = 'tasks' AND i.reference_id = ?;

   -- Get all items for sidequest
   SELECT i.name, i.status, i.description
   FROM items i
   WHERE i.reference_table = 'sidequests' AND i.reference_id = sq.id;

   -- If no completed items in task/subtask:
   -- Get previous task + last X items
   SELECT t.name, t.status, i.name AS item_name, i.status AS item_status
   FROM tasks t
   LEFT JOIN items i ON i.reference_table = 'tasks' AND i.reference_id = t.id
   WHERE t.milestone_id = ? AND t.created_at < ?
   ORDER BY t.created_at DESC, i.created_at DESC
   LIMIT 10;
   ```

   **Priority 2: Current Subtask (if no sidequests)**
   ```sql
   -- Find open subtask
   SELECT st.id, st.name, st.status, st.parent_task_id
   FROM subtasks st
   WHERE st.status IN ('pending', 'in_progress')
   ORDER BY st.priority DESC, st.created_at ASC
   LIMIT 1;

   -- Get all items for subtask
   SELECT i.name, i.status, i.description
   FROM items i
   WHERE i.reference_table = 'subtasks' AND i.reference_id = st.id;

   -- If no completed items, get previous task context
   -- (same logic as sidequests)
   ```

   **Priority 3: Current Task (if no subtasks)**
   ```sql
   -- Find open task
   SELECT t.id, t.name, t.status, t.milestone_id
   FROM tasks t
   WHERE t.status IN ('pending', 'in_progress')
   ORDER BY t.priority DESC, t.created_at ASC
   LIMIT 1;

   -- Get all items for task
   SELECT i.name, i.status, i.description
   FROM items i
   WHERE i.reference_table = 'tasks' AND i.reference_id = t.id;

   -- Evaluate completed vs incomplete items
   -- Order incomplete items by priority
   ```

4. **Check for Ambiguity**
   ```sql
   -- Query notes for recent clarifications or warnings
   SELECT content, note_type, directive_name, severity
   FROM notes
   WHERE source IN ('directive', 'ai')
     AND severity IN ('warning', 'error')
   ORDER BY created_at DESC
   LIMIT 5;
   ```

5. **Auto-Browse for Context (if auto-run mode)**
   ```sql
   -- Get related flows
   SELECT f.name, f.description
   FROM flows f
   JOIN file_flows ff ON ff.flow_id = f.id
   JOIN files fi ON fi.id = ff.file_id
   WHERE fi.path IN (SELECT path FROM files WHERE updated_at > ?);

   -- Get related functions
   SELECT fn.name, fn.purpose
   FROM functions fn
   WHERE fn.file_id IN (SELECT id FROM files WHERE updated_at > ?);
   ```

6. **Generate Status Report**
   ```
   üìä Project Status: {ProjectName}
   Version: {version} | Status: {active|paused|completed}

   üéØ Current Focus:
   {Priority item: sidequest/subtask/task}

   üìù Open Items:
   {List of incomplete items with status}

   ‚úÖ Recently Completed:
   {List of last X completed items for context}

   üîç Context:
   {Historical context from previous task if applicable}

   ‚ö†Ô∏è Ambiguities:
   {List any ambiguities found, or "None"}

   Next Actions:
   1. {Recommended next step}
   2. {Alternative step}

   Ready to continue? (yes/no/browse more)
   ```

#### 3.2.2 Sub-Directive: `detect_and_init_project`

**Execution Steps**:

1. **Check `.aifp/` Folder**
   ```bash
   if [ -d ".aifp" ]; then
     echo "Found .aifp/ folder"
   else
     echo ".aifp/ folder not found"
   fi
   ```

2. **If Not Found, Check `.git/.aifp/`**
   ```bash
   if [ -d ".git/.aifp" ] && [ -f ".git/.aifp/ProjectBlueprint.md" ]; then
     echo "Found archived project in .git/.aifp/"
     # Prompt: "Restore or begin new project?"
   fi
   ```

3. **If `.aifp/` Exists, Check ProjectBlueprint.md**
   ```bash
   if [ ! -f ".aifp/ProjectBlueprint.md" ]; then
     echo "ProjectBlueprint.md not found"
     # Check for database
   fi
   ```

4. **If No ProjectBlueprint, Check Database**
   ```sql
   -- Attempt to connect to project.db
   SELECT name, purpose, status FROM project LIMIT 1;

   -- If results empty:
   -- "Folder created but no project setup exists. Ready to initialize?"

   -- If no database:
   -- "Project not initialized. Ready to initialize?"
   ```

5. **If ProjectBlueprint Exists, Check Database**
   ```sql
   -- Follow same database check as above
   ```

6. **Prompt User**
   ```
   üîç Project State Detected:
   {Description of findings}

   Options:
   1. Initialize new AIFP project
   2. Restore from .git/.aifp/ (if found)
   3. Exit and investigate manually

   What would you like to do?
   ```

---

### 3.3 Enhanced `project_evolution` Directive

**Name**: `project_evolution`
**Type**: `project`
**Level**: 3
**Parent**: `aifp_run`

**Purpose**: Handle project-wide changes and update ProjectBlueprint.md accordingly.

**Triggers**:
- Discussion results in architectural changes
- Goals or success criteria change
- Themes or flows are added/modified
- Infrastructure changes (language, framework, build tool)
- Project pivot or major scope change

**Workflow**:

```json
{
  "trunk": "detect_project_wide_change",
  "branches": [
    {
      "if": "architecture_change",
      "then": "update_blueprint_section_2_and_db",
      "details": {
        "update_blueprint": "Section 2: Technical Blueprint",
        "update_db": "project table (increment version), infrastructure table"
      }
    },
    {
      "if": "goals_change",
      "then": "update_blueprint_section_1_and_db",
      "details": {
        "update_blueprint": "Section 1: Project Overview (Goals, Success Criteria)",
        "update_db": "project table (goals_json, increment version)"
      }
    },
    {
      "if": "themes_or_flows_change",
      "then": "update_blueprint_section_3_and_db",
      "details": {
        "update_blueprint": "Section 3: Project Themes & Flows",
        "update_db": "themes table, flows table, increment project.version"
      }
    },
    {
      "if": "completion_path_change",
      "then": "update_blueprint_section_4_and_db",
      "details": {
        "update_blueprint": "Section 4: Completion Path",
        "update_db": "completion_path table, milestones table, increment project.version"
      }
    },
    {
      "if": "infrastructure_change",
      "then": "update_blueprint_section_2_and_db",
      "details": {
        "update_blueprint": "Section 2: Technical Blueprint (Key Infrastructure)",
        "update_db": "infrastructure table, increment project.version"
      }
    },
    {
      "parallel": [
        "backup_blueprint_to_aifp_backups",
        "log_evolution_to_notes"
      ],
      "details": {
        "note_type": "evolution",
        "source": "directive",
        "directive_name": "project_evolution"
      }
    }
  ],
  "error_handling": {
    "on_failure": "prompt_user_to_manually_update_blueprint",
    "retry": "max 1 attempt"
  }
}
```

**Evolution Logging**:
```sql
-- Log to notes table
INSERT INTO notes (content, note_type, reference_table, reference_id, source, directive_name, severity)
VALUES (
  'Project evolution: {description of change}',
  'evolution',
  'project',
  {project_id},
  'directive',
  'project_evolution',
  'info'
);

-- Increment version
UPDATE project SET version = version + 1 WHERE id = ?;

-- Add to ProjectBlueprint.md Section 5: Evolution History
### Version {new_version} - {current_date}
- **Change**: {description}
- **Rationale**: {why this change was made}
```

---

## 4. Helper Functions

### 4.1 `create_project_blueprint`

**Purpose**: Generate ProjectBlueprint.md from template and user input.

**Parameters**:
- `project_name` (string)
- `project_purpose` (string)
- `goals_json` (JSON array)
- `language` (string)
- `build_tool` (string)
- `fp_strictness_level` (string)

**Implementation**:
```python
def create_project_blueprint(project_name, project_purpose, goals_json,
                               language, build_tool, fp_strictness_level):
    """
    Generate ProjectBlueprint.md from template and user input.

    Returns:
        str: Path to created ProjectBlueprint.md
    """
    template = load_template("ProjectBlueprint_template.md")

    # Parse goals
    goals = json.loads(goals_json)
    goals_markdown = "\n".join([f"- {goal}" for goal in goals])

    # Fill template
    content = template.format(
        project_name=project_name,
        version_number=1,
        status="active",
        last_updated=datetime.now().strftime("%Y-%m-%d"),
        aifp_compliance=fp_strictness_level,
        project_purpose=project_purpose,
        goals_markdown=goals_markdown,
        language=language,
        build_tool=build_tool
    )

    # Write to .aifp/ProjectBlueprint.md
    blueprint_path = ".aifp/ProjectBlueprint.md"
    with open(blueprint_path, 'w') as f:
        f.write(content)

    # Create backup
    backup_path = ".aifp/backups/ProjectBlueprint.md.backup"
    shutil.copy(blueprint_path, backup_path)

    return blueprint_path
```

### 4.2 `read_project_blueprint`

**Purpose**: Parse ProjectBlueprint.md and return structured data.

**Parameters**:
- `blueprint_path` (string, default: `.aifp/ProjectBlueprint.md`)

**Implementation**:
```python
def read_project_blueprint(blueprint_path=".aifp/ProjectBlueprint.md"):
    """
    Parse ProjectBlueprint.md and return structured data.

    Returns:
        dict: {
            "name": str,
            "version": int,
            "status": str,
            "last_updated": str,
            "aifp_compliance": str,
            "overview": {
                "idea": str,
                "goals": list[str],
                "success_criteria": list[str]
            },
            "technical": {
                "language": str,
                "runtime": str,
                "build_tool": str,
                "architecture_style": dict
            },
            "themes": list[dict],
            "flows": list[dict],
            "completion_path": list[dict]
        }
    """
    with open(blueprint_path, 'r') as f:
        content = f.read()

    # Parse markdown sections
    parsed = parse_markdown_blueprint(content)

    return parsed
```

### 4.3 `update_project_blueprint_section`

**Purpose**: Update specific section of ProjectBlueprint.md.

**Parameters**:
- `section_number` (int)
- `section_content` (string)
- `increment_version` (bool, default: True)

**Implementation**:
```python
def update_project_blueprint_section(section_number, section_content,
                                      increment_version=True):
    """
    Update specific section of ProjectBlueprint.md.

    Returns:
        bool: Success status
    """
    blueprint_path = ".aifp/ProjectBlueprint.md"

    # Read current content
    with open(blueprint_path, 'r') as f:
        content = f.read()

    # Parse and update section
    updated_content = replace_section(content, section_number, section_content)

    # Increment version if needed
    if increment_version:
        updated_content = increment_blueprint_version(updated_content)

    # Backup current version
    backup_path = f".aifp/backups/ProjectBlueprint.md.v{get_current_version()}"
    shutil.copy(blueprint_path, backup_path)

    # Write updated content
    with open(blueprint_path, 'w') as f:
        f.write(updated_content)

    # Update checksum in project table
    new_checksum = calculate_checksum(updated_content)
    update_project_checksum(project_id, new_checksum)

    return True
```

### 4.4 `get_status_tree`

**Purpose**: Build hierarchical status tree with historical context.

**Parameters**:
- `project_id` (int)
- `context_limit` (int, default: 10) - Number of previous items to include

**Implementation**:
```python
def get_status_tree(project_id, context_limit=10):
    """
    Build hierarchical status tree with historical context.

    Returns:
        dict: {
            "priority": "sidequest|subtask|task",
            "current": {
                "id": int,
                "name": str,
                "status": str,
                "items": list[dict]
            },
            "parent": dict or None,
            "historical_context": list[dict],
            "ambiguities": list[str]
        }
    """
    conn = get_project_db_connection(project_id)

    # Check for open sidequests (Priority 1)
    sidequests = query_open_sidequests(conn)
    if sidequests:
        return build_sidequest_tree(conn, sidequests[0], context_limit)

    # Check for open subtasks (Priority 2)
    subtasks = query_open_subtasks(conn)
    if subtasks:
        return build_subtask_tree(conn, subtasks[0], context_limit)

    # Check for open tasks (Priority 3)
    tasks = query_open_tasks(conn)
    if tasks:
        return build_task_tree(conn, tasks[0], context_limit)

    # No open work items
    return {"priority": None, "current": None, "message": "No open tasks"}
```

---

## 5. Interaction Flows

### 5.1 New Project Initialization Flow

```
User: "aifp run initialize new project"
  ‚Üì
AI: Call aifp_run tool
  ‚Üì
aifp_run ‚Üí routes to project_init
  ‚Üì
project_init checks existing state
  ‚Üì
No .aifp/ folder found
  ‚Üì
Interactive blueprint creation:
  - What is the project name?
  - What is the core idea?
  - What are the goals?
  - What language?
  - What build tool?
  - AIFP compliance level?
  ‚Üì
Create .aifp/ structure:
  - ProjectBlueprint.md
  - project.db
  - user_preferences.db
  ‚Üì
Populate databases:
  - project table
  - infrastructure table
  - completion_path table
  ‚Üì
AI: "‚úÖ Project initialized: {name}
     üìÑ Created: ProjectBlueprint.md
     Next: Run 'aifp status' to begin"
```

### 5.2 Existing Project Status Flow

```
User: "aifp run continue work"
  ‚Üì
AI: Call aifp_run tool
  ‚Üì
aifp_run ‚Üí routes to aifp_status
  ‚Üì
aifp_status ‚Üí get_existing_project_status
  ‚Üì
Read ProjectBlueprint.md
  ‚Üì
Query infrastructure from DB
  ‚Üì
Build priority status tree:
  1. Check open sidequests
  2. If none, check open subtasks
  3. If none, check open tasks
  ‚Üì
For current priority item:
  - Get all items
  - Evaluate completed vs incomplete
  - Get historical context (previous task + last X items)
  ‚Üì
Check for ambiguities:
  - Query notes for warnings/errors
  - Check for incomplete information
  ‚Üì
Auto-browse for context (if auto-run):
  - Related flows
  - Recent functions
  - Task descriptions
  ‚Üì
Generate status report:
  - Current focus
  - Open items
  - Recently completed
  - Historical context
  - Ambiguities
  - Recommended next actions
  ‚Üì
AI: "üìä Project Status: {name}
     üéØ Current Focus: {current item}
     üìù Open Items: {list}
     ‚úÖ Recently Completed: {list}
     Ready to continue?"
```

### 5.3 Project Evolution Flow

```
User: "Actually, let's change to TypeScript and add React"
  ‚Üì
AI: Recognizes project-wide change
  ‚Üì
AI: Call aifp_run tool
  ‚Üì
aifp_run ‚Üí routes to project_evolution
  ‚Üì
project_evolution detects:
  - Infrastructure change (language: TypeScript)
  - Infrastructure change (framework: React)
  ‚Üì
Update ProjectBlueprint.md:
  - Section 2: Technical Blueprint
  - Section 5: Evolution History (new entry)
  - Increment version
  ‚Üì
Update project.db:
  - infrastructure table (language=TypeScript, framework=React)
  - project table (version += 1)
  - notes table (evolution log)
  ‚Üì
Backup ProjectBlueprint.md:
  - .aifp/backups/ProjectBlueprint.md.v{old_version}
  ‚Üì
AI: "‚úÖ Project evolved to v{new_version}
     üîÑ Changes:
       - Language: Python ‚Üí TypeScript
       - Framework: React added
     üìÑ ProjectBlueprint.md updated
     üóÑÔ∏è  Database updated

     Next: Review updated blueprint and adjust tasks"
```

---

## 6. Database Schema Additions

### 6.1 Modified Table: `project`

Added field to existing `project` table:

```sql
ALTER TABLE project ADD COLUMN blueprint_checksum TEXT; -- MD5/SHA256 checksum of ProjectBlueprint.md for sync validation
```

**Rationale**: Since AIFP uses one project per database (not multi-project), storing blueprint metadata in a separate table is unnecessary. The `project` table already has `version` and `updated_at` fields. We only need to add `blueprint_checksum` for validation. Blueprint path is always `.aifp/ProjectBlueprint.md` (convention), and backup path follows convention: `.aifp/backups/ProjectBlueprint.md.v{version}`.

### 6.2 Enhanced `notes` Table Usage

Add note types for blueprint-related events:

```sql
-- Note types:
-- 'evolution' - Project evolution events
-- 'blueprint_update' - Manual blueprint updates
-- 'clarification' - User clarifications
-- 'pivot' - Major direction changes
-- 'research' - Research notes
-- 'ambiguity' - Detected ambiguities

INSERT INTO notes (content, note_type, reference_table, reference_id, source, directive_name, severity)
VALUES (
  'Project evolution: Changed language to TypeScript, added React framework',
  'evolution',
  'project',
  1,
  'directive',
  'project_evolution',
  'info'
);
```

---

## 7. Configuration: config.json

```json
{
  "aifp_version": "1.0",
  "project_name": "{ProjectName}",
  "blueprint_path": ".aifp/ProjectBlueprint.md",
  "databases": {
    "project_db": ".aifp/project.db",
    "user_preferences_db": ".aifp/user_preferences.db"
  },
  "backups": {
    "enabled": true,
    "directory": ".aifp/backups/",
    "auto_backup_on_evolution": true
  },
  "status": {
    "context_limit": 10,
    "auto_browse": false,
    "ambiguity_threshold": 0.7
  },
  "git_integration": {
    "archive_to_git_aifp": true,
    "sync_on_commit": false
  }
}
```

---

## 8. Testing Scenarios

### Test 1: Fresh Project Initialization
```bash
# User in empty project directory
aifp run "initialize new calculator project"

# Expected:
# - Interactive prompts for project details
# - .aifp/ folder created
# - ProjectBlueprint.md generated
# - Databases initialized
# - Success message with next steps
```

### Test 2: Restore from .git/.aifp/
```bash
# User deleted .aifp/ but .git/.aifp/ exists
aifp run "check project status"

# Expected:
# - Detection of .git/.aifp/ backup
# - Prompt: "Restore or begin new?"
# - If restore: copy from .git/.aifp/ to .aifp/
# - Status report generated
```

### Test 3: Existing Project Status with Sidequest
```bash
# Project has open sidequest
aifp run "continue work"

# Expected:
# - ProjectBlueprint.md read
# - Infrastructure loaded
# - Sidequest detected as priority
# - Parent task context loaded
# - Historical context from previous task
# - Status report with recommendations
```

### Test 4: Project Evolution
```bash
# User changes core architecture
aifp run "change language to Rust and use Tokio framework"

# Expected:
# - project_evolution directive triggered
# - ProjectBlueprint.md Section 2 updated
# - infrastructure table updated
# - project.version incremented
# - Evolution logged to notes
# - Backup created
```

---

## 9. Future Enhancements

1. **Blueprint Templates**
   - Pre-defined templates for common project types
   - Web app, CLI tool, library, microservice

2. **Blueprint Diffing**
   - Show changes between versions
   - Visual diff in markdown format

3. **Blueprint Validation**
   - Ensure blueprint sections match database state
   - Auto-repair inconsistencies

4. **Multi-Project Blueprints**
   - Blueprint for monorepo with multiple sub-projects
   - Shared infrastructure sections

5. **AI Blueprint Suggestions**
   - AI suggests blueprint improvements based on project evolution
   - Recommend new themes/flows based on code patterns

---

## 10. Integration with Existing Directives

### Directives That Should Call Blueprint Functions:

1. **project_init** ‚Üí `create_project_blueprint()`
2. **aifp_status** ‚Üí `read_project_blueprint()`
3. **project_evolution** ‚Üí `update_project_blueprint_section()`
4. **project_themes_flows_init** ‚Üí Update ProjectBlueprint.md Section 3
5. **project_completion_check** ‚Üí Update ProjectBlueprint.md Section 4
6. **project_blueprint_update** ‚Üí Sync blueprint checksum in `project.blueprint_checksum`

---

## Summary

This blueprint defines:
- ‚úÖ `.aifp/` project folder structure with ProjectBlueprint.md
- ‚úÖ ProjectBlueprint.md specification and template
- ‚úÖ Enhanced `project_init` directive with interactive blueprint creation
- ‚úÖ New `aifp_status` directive with priority-based status tree
- ‚úÖ Enhanced `project_evolution` directive for project-wide changes
- ‚úÖ Helper functions for blueprint management
- ‚úÖ Database schema additions
- ‚úÖ Complete interaction flows
- ‚úÖ Testing scenarios

The ProjectBlueprint.md serves as the **context anchor** for AI across sessions, ensuring continuity and understanding of project goals, architecture, and evolution history.
