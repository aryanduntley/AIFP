Read:
README.md
sys-prompt/aifp_system_prompt.txt
.aifp/ProjectBlueprint.md

docs/directives-project-updates-needed.md
docs/directive-review-master-checklist.md
docs/schema-updates-decisions.md
docs/directive-review-plan.md
docs/directive-json-schema-alignment-analysis.md

dev blueprints are in docs/blueprints/{}.md and the directive json files are located in docs/directives-json/{}, production directive md files located in src/aifp/reference/directives/{}.md. .aifp/ is our project management folder for dev, our project management/tracking database is there. We are following the FP coding style and managing the project through the project database in .aifp to ensure consistent and updated status. After every batch of completions, update the database to reflect the completed work.

src/aifp/database/schemas/user_preferences.sql
src/aifp/database/schemas/aifp_core.sql
src/aifp/database/schemas/project.sql
src/aifp/database/schemas/user_directives.sql
docs/sync-directives.py
docs/implementation-plans/phase-1-mcp-server-bootstrap.md
docs/implementation-plans/overview-all-phases.md

docs/helpers/helper-functions-reference.md

docs/db-schema/schemaExampleMCP.sql
docs/db-schema/schemaExampleProject.sql
docs/db-schema/schemaExampleSettings.sql
docs/db-schema/schemaExampleUserDirectives.sql
docs/blueprints/blueprint_system_prompt.md
docs/blueprints/blueprint_aifp_project_structure.md
docs/directives-markdown-reference.md

docs/directive-documentation-status.md
docs/directive-md-mapping.csv

Notes are md examples and init structuring are the idea evolution files
docs/directiveNotes/*
docs/initialStructuring/*

docs/directives-json/helpers_parsed.json
update with new helpers, fix paths (tools/ subdir and file names)

docs/directives-json/sync-directives.py
docs/helpers/helper-architecture.md
docs/helpers/generic-tools-project.md
docs/helpers/generic-tools-mcp.md

--help add_function, add_file, add_type.. etc. any that require reservation.

docs/directives-json/sync-directives.py needs full overhaul based on new schema, structure and decisions

use the helpers/tools:
docs/helpers/info-helpers-core.txt :
get_helpers_for_directive(directive_id, include_helpers_data=false)
   include_helpers_data=false return all directive_helpers data for matches
   include_helpers_data=true calls get_helpers_by_id(helper_id array)
      returns all directive_helpers data AND helper_functions data for matches
get_directives_for_helper(helper_function_id, include_directives_data=false)
   include_directives_data=false return all directive_helpers data for matches
   include_directives_data=true calls get_directives(directive_id array)
      returns all directive_helpers data AND directives data for matches

need to flesh out return statements

must handle existing projects that are oop: NO. We will recommend NOT to use AIFP for existing OOP projects.

Read:
README.md
sys-prompt/aifp_system_prompt.txt
.aifp/ProjectBlueprint.md

=======

docs/helpers/info-helpers-user-settings.txt
docs/helpers/info-helpers-project.txt
docs/helpers/info-helpers-core.txt
docs/helpers/info-helpers-user-custom.txt

docs/helpers/CONSOLIDATION_COMPLETE.md
docs/aifp-oop-policy.md
docs/helpers/IMPLEMENTATION_LOG.md

consolidated helpers:
docs/helpers/consolidated/helpers-consolidated-user-custom.md
docs/helpers/consolidated/helpers-consolidated-core.md
docs/helpers/consolidated/helpers-consolidated-git.md
docs/helpers/consolidated/helpers-consolidated-index.md
docs/helpers/consolidated/helpers-consolidated-orchestrators.md
docs/helpers/consolidated/helpers-consolidated-project.md
docs/helpers/consolidated/helpers-consolidated-settings.md

directives next steps:
docs/directives-json/Tasks/DIRECTIVE_CLEANUP_TASK.md
docs/directives-json/Tasks/DIRECTIVES_QUICK_REF.md
docs/directives-json/Tasks/HELPER_FUNCTIONS_QUICK_REF.md
docs/directives-json/Tasks/MD_HELPER_REFS_ANALYSIS.md
docs/temp.txt
docs/directives-json/Tasks/MD_CLEANUP_CHECKLIST.md

docs/directives-json/Tasks/SQL_CLEANUP_NEEDED.md
docs/directives-json/DIRECTIVE_ARCHITECTURE.md

docs/HELPER_IMPORT_ANALYSIS_2025-12-16.md
docs/DIRECTIVE_JSON_CLEANUP_REPORT_2025-12-16.md
docs/HELPER_IMPORT_ANALYSIS_2025-12-16.md

used_by_directive field in the helper json files needs to be evaluated when re-evaluating directives


> Read:
README.md
sys-prompt/aifp_system_prompt.txt
.aifp/ProjectBlueprint.md\
\
We have directives and helpers. We need to map directives in 
preparation for the directive_flow table and while we do this, 
we need to add the used_by_directive list for each helper \
\\
\
consolidated helpers:
docs/helpers/consolidated/helpers-consolidated-user-custom.md
docs/helpers/consolidated/helpers-consolidated-core.md
docs/helpers/consolidated/helpers-consolidated-git.md
docs/helpers/consolidated/helpers-consolidated-index.md
docs/helpers/consolidated/helpers-consolidated-orchestrators.md
docs/helpers/consolidated/helpers-consolidated-project.md
docs/helpers/consolidated/helpers-consolidated-settings.md\
\
directives json are in docs/directives-json/
directives md are in src/aifp/resource/directives/
Everything above src/aifp/ is dev. \
\

docs/directives-json/DIRECTIVE_ARCHITECTURE.md
docs/HELPER_IMPORT_ANALYSIS_2025-12-16.md
docs/DIRECTIVE_JSON_CLEANUP_REPORT_2025-12-16.md
docs/HELPER_IMPORT_ANALYSIS_2025-12-16.md\ 

Here are our contextual files for the mapping work:
docs/helpers/json/README.md
docs/MAPPING_SETUP_COMPLETE.md
docs/directives-json/Tasks/DIRECTIVES_MAPPING_PROGRESS.md
docs/directives-json/Tasks/HELPER_FUNCTIONS_MAPPING_PROGRESS.md

docs/DIRECTIVE_WORKFLOW_PATH.md
docs/DIRECTIVE_HELPER_MAPPING_IMPLEMENTATION_PLAN.md

docs/PHASE_1_COMPLETE.md

helpers json file path updates needed

MUST make OOP wrapper examples

docs/directives-json/directive_flow.json
verify number of project directives. 38 mentioned

OLD, but still useful info:

for docs/directive-graph.txt please review. Should we incorporate this path system into our core database for AI clarity in directive usage? We have example helper functions but we don't need to implement those right away. We should first work with and assess the core project management system. Later we can reviwe our consolidated helpers and determine what we should add for any new tables and directive querying for AI we improved. 
This is very linear. I proposed a tree because it really does 
depend on what the current action is and what is needed next. So
 depending on current action, there may be choices instead of 
just one next action. Any table we create should have a many to 
many relationship so that when getting one directive, returned 
are a list of possible next steps. This can limit the "thinking"
 to a defined list and based on description and AI's current 
state in the project, AI can determine which to go to. But these
 should all have a loop back as well. An end point doesn't mean 
stop work, it means: is completion path, current path complete? 
If so, move to next completion path, move to first milestone, 
create first task. If not, check for open milestone. If no oopen
 milestone, move to next pending milestone, create first task 
for milestone. If open milestone, check for open task. If no 
open task, create next task. If open task, check for open task 
items. If no open task items, should task be marked complete? 
Should new task items be created (all task items should be 
created as soon as task is created, is something wrong?)? If new
 task, create task items. If open task items, work on next task 
item. file creations/updates function creations/updates, etc. 
etc. Loop back when anything is marked complete. This is the 
standard project management that really needs to be mapped out 
well. I believe we have directives for all of these so a map or 
tree of following the directives in this type of order should be
 quickly and easliy available.\
\
  -- Starting point
  INSERT INTO directive_flow (from_directive, to_directive, 
flow_type, priority, description)
  VALUES ('aifp_run', 'project_init', 'canonical', 100, 'First 
directive on initial run');

  -- After project init
  INSERT INTO directive_flow (from_directive, to_directive, 
flow_type, priority, condition_description)
  VALUES ('project_init', 'blueprint_read', 'canonical', 100, 
'Read ProjectBlueprint.md');\
\
In your examples here, project init is next step, but if project
 is initialized, is there an automatic jump to blueprint_read? \
\
aifp_run should actually first start with aifp_status. Status 
should accurately get current state programmatically for AI to 
process and determine what to do (init, continue working, etc.).
 We could potentially offer starting points based on the 
returned value (if not initialized, suggest init. If in 
progress, suggest continuation directive(s)).\
\
status should query the database using all of the helpers and 
potentially some custom queries as well, getting if user_custom 
exists, if project initialized (db's in place, blueprint in 
place, infrastructure in place, etc), get themes and determing 
point in completion path. Determine current milestone and task. 
Determine task/subtask/sidequest state and item state relative 
to any of those. Get last X number of completed items for 
context. If X not available, get previous task/subtask/sidequest
 and last X number of completed items for context. Get current 
incomplete item and next item for context. All should be 
returned as a comprehensive current state, to include 
infrastructure guidance, project blueprint location for AI read,
 etc. \
\
From status state some starting point suggestions can be offered
 and AI can determine how to proceed. 
