{
  "helpers": [
    {
      "name": "user_directives_allowed_check_constraints",
      "file_path": "helpers/user_directives/validation.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name to check for CHECK constraints"
        },
        {
          "name": "field",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Field name to get allowed values for"
        }
      ],
      "purpose": "Returns list of allowed values for CHECK constraint enum fields in user_directives.db. Parses schema to extract CHECK(field IN (...)) constraints.",
      "error_handling": "Returns error if table does not exist, field does not exist, or field does not have a CHECK constraint list",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "Parse schema SQL for table definition",
        "Find field with CHECK constraint: CHECK (field IN (...))",
        "Extract values from IN clause",
        "Return as array of strings",
        "Examples: user_directives_allowed_check_constraints(\"user_directives\", \"status\") -> [\"pending_validation\", \"validated\", \"implementing\", \"implemented\", \"active\", \"paused\", \"error\", \"deprecated\"]",
        "Examples: user_directives_allowed_check_constraints(\"user_directives\", \"trigger_type\") -> [\"time\", \"event\", \"condition\", \"manual\"]",
        "Examples: user_directives_allowed_check_constraints(\"user_directives\", \"action_type\") -> [\"api_call\", \"script_execution\", \"function_call\", \"command\", \"notification\"]",
        "Examples: user_directives_allowed_check_constraints(\"notes\", \"note_type\") -> [\"implementation\", \"validation\", \"execution\", \"dependency\", \"error\", \"optimization\", \"user_feedback\", \"lifecycle\", \"testing\", \"general\"]"
      ]
    },
    {
      "name": "get_user_custom_tables",
      "file_path": "helpers/user_directives/schema.py",
      "parameters": [],
      "purpose": "List all tables in user directives database",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "Returns array of strings: ['user_directives', 'directive_executions', 'directive_dependencies', 'directive_implementations', 'directive_relationships', 'helper_functions', 'directive_helpers', 'source_files', 'logging_config', 'notes', 'schema_version']",
        "SQL: SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name",
        "NOTE: Generic AI tool - not typically called by directives"
      ]
    },
    {
      "name": "get_user_custom_fields",
      "file_path": "helpers/user_directives/schema.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name to get fields for"
        }
      ],
      "purpose": "Get field names and types for a specific table in user_directives.db",
      "error_handling": "Returns error if table does not exist",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "SQL: PRAGMA table_info(table_name)",
        "Returns array of {name, type, notnull, default_value, pk} for each field",
        "NOTE: Generic AI tool for schema introspection"
      ]
    },
    {
      "name": "get_user_custom_schema",
      "file_path": "helpers/user_directives/schema.py",
      "parameters": [],
      "purpose": "Get complete schema SQL for user directives database",
      "error_handling": "",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "SQL: SELECT sql FROM sqlite_master WHERE type IN ('table', 'trigger', 'index') AND name NOT LIKE 'sqlite_%' ORDER BY type, name",
        "Returns complete schema as string for AI reference",
        "NOTE: Generic AI tool for schema introspection"
      ]
    },
    {
      "name": "get_user_custom_json_parameters",
      "file_path": "helpers/user_directives/schema.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name to get available fields for"
        }
      ],
      "purpose": "Get available fields for table to use with generic add/update operations. Returns field names, types, and whether required.",
      "error_handling": "Returns error if table does not exist",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "SQL: PRAGMA table_info(table_name)",
        "Returns array of {name, type, required (notnull=1 and no default), has_default}",
        "Excludes auto-managed fields: id, created_at, updated_at",
        "Used by AI to know which fields to pass to add_user_custom_entry or update_user_custom_entry"
      ]
    },
    {
      "name": "get_from_user_custom",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name in user_directives.db"
        },
        {
          "name": "id_array",
          "type": "array",
          "required": true,
          "default": null,
          "description": "Array of integer IDs - **MUST contain at least one ID**"
        }
      ],
      "purpose": "Get records by ID(s) from user_directives.db - **EMPTY ARRAY NOT ALLOWED**",
      "error_handling": "Return error if id_array is empty. Return error if table does not exist.",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "SQL: SELECT * FROM {table} WHERE id IN ({id_array})",
        "Validate table exists before querying",
        "Return all columns as dict/row objects",
        "Return empty array if no IDs match (not an error)"
      ]
    },
    {
      "name": "get_from_user_custom_where",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name in user_directives.db"
        },
        {
          "name": "conditions",
          "type": "object",
          "required": true,
          "default": null,
          "description": "Field-value pairs combined with AND logic"
        }
      ],
      "purpose": "Flexible filtering with structured JSON conditions on user_directives.db tables",
      "error_handling": "Return error if table does not exist. Return empty array if no matches.",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "Builds WHERE clause from conditions object using AND logic",
        "SQL: SELECT * FROM {table} WHERE field1=? AND field2=? ...",
        "Use parameterized queries to prevent SQL injection",
        "Return all columns as dict/row objects"
      ]
    },
    {
      "name": "query_user_custom",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name in user_directives.db"
        },
        {
          "name": "query",
          "type": "string",
          "required": true,
          "default": null,
          "description": "WHERE clause without 'WHERE' keyword"
        }
      ],
      "purpose": "Execute complex SQL WHERE clause on user_directives.db (advanced, rare use)",
      "error_handling": "Return error if table does not exist or SQL is invalid",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "SQL: SELECT * FROM {table} WHERE {query}",
        "For complex queries that get_from_user_custom_where cannot express (OR, LIKE, subqueries, etc.)",
        "Validate table exists before querying",
        "READ-ONLY: This is a SELECT query only, never INSERT/UPDATE/DELETE"
      ]
    },
    {
      "name": "add_user_custom_entry",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name in user_directives.db"
        },
        {
          "name": "data",
          "type": "object",
          "required": true,
          "default": null,
          "description": "Field-value pairs to insert"
        }
      ],
      "purpose": "Add entry to user_directives.db table. Returns inserted record with ID.",
      "error_handling": "Return error if table does not exist, required fields missing, or UNIQUE constraint violated",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Returns inserted record with generated ID.",
        "If called during user_directive_parse: all directives parsed \u2192 proceed to user_directive_validate for interactive Q&A validation."
      ],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_parse",
          "execution_context": "store_raw_directives",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {
            "table": "user_directives",
            "fields": "status=pending_validation, raw_content, source_file"
          },
          "description": "Insert parsed directives into user_directives table with pending_validation status"
        },
        {
          "directive_name": "user_directive_parse",
          "execution_context": "store_source_file",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {
            "table": "source_files",
            "fields": "file_path, file_format, file_checksum, parse_status"
          },
          "description": "Insert source file record with checksum for change detection"
        },
        {
          "directive_name": "user_directive_update",
          "execution_context": "handle_new_directives",
          "sequence_order": 5,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Insert new directives found in updated source file"
        }
      ],
      "implementation_notes": [
        "SQL: INSERT INTO {table} ({fields}) VALUES ({values}) RETURNING *",
        "Validate table exists and fields are valid column names",
        "Use parameterized queries",
        "Return the full inserted row including auto-generated id and timestamps"
      ]
    },
    {
      "name": "update_user_custom_entry",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name in user_directives.db"
        },
        {
          "name": "record_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Record ID to update"
        },
        {
          "name": "data",
          "type": "object",
          "required": true,
          "default": null,
          "description": "Field-value pairs to update"
        }
      ],
      "purpose": "Update entry in user_directives.db table",
      "error_handling": "Return error if table does not exist, ID not found, or invalid fields",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "If called during user_directive_implement: all code generated \u2192 proceed to user_directive_approve for user testing and approval.",
        "If called during user_directive_approve: user approved \u2192 proceed to user_directive_activate to deploy."
      ],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_validate",
          "execution_context": "store_validated_directives",
          "sequence_order": 3,
          "is_required": true,
          "parameters_mapping": {
            "table": "user_directives",
            "fields": "status=validated, validated_content, validated_at"
          },
          "description": "Update directive with validated configuration after Q&A resolution"
        },
        {
          "directive_name": "user_directive_implement",
          "execution_context": "write_implementation_files",
          "sequence_order": 4,
          "is_required": true,
          "parameters_mapping": {
            "table": "user_directives",
            "fields": "status=implemented, implementation_status=completed, implementation_file_path"
          },
          "description": "Update directive with implementation details after code generation"
        },
        {
          "directive_name": "user_directive_approve",
          "execution_context": "mark_approved",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {
            "table": "user_directives",
            "fields": "approved=true, approved_at=current_timestamp"
          },
          "description": "Mark directive as approved after user testing confirmation"
        },
        {
          "directive_name": "user_directive_update",
          "execution_context": "handle_modified_directives",
          "sequence_order": 4,
          "is_required": true,
          "parameters_mapping": {
            "table": "user_directives",
            "fields": "approved=false, status=pending_validation"
          },
          "description": "Reset approval status when directive modified - requires re-validation and re-approval"
        }
      ],
      "implementation_notes": [
        "SQL: UPDATE {table} SET field1=?, field2=? WHERE id=?",
        "Validate table exists, ID exists, and fields are valid column names",
        "Use parameterized queries",
        "Timestamp triggers handle updated_at automatically",
        "Return updated row or success confirmation"
      ]
    },
    {
      "name": "delete_user_custom_entry",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [
        {
          "name": "table",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Table name in user_directives.db"
        },
        {
          "name": "record_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "Record ID to delete"
        }
      ],
      "purpose": "Delete entry from user_directives.db table",
      "error_handling": "Returns error if table not found or ID doesn't exist",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_update",
          "execution_context": "handle_removed_directives",
          "sequence_order": 6,
          "is_required": false,
          "parameters_mapping": {
            "table": "user_directives"
          },
          "description": "Delete directives removed from source file - alternative to updating status=deprecated"
        }
      ],
      "implementation_notes": [
        "SQL: DELETE FROM {table} WHERE id=?",
        "Validate table exists and ID exists before deletion",
        "CASCADE rules handle dependent records (directive_executions, directive_dependencies, etc.)",
        "Return confirmation with deleted record count"
      ]
    },
    {
      "name": "get_active_user_directives",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [],
      "purpose": "Get all user directives with status='active'. Convenience query for checking active directive count.",
      "error_handling": "Returns empty array if no active directives",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_deactivate",
          "execution_context": "check_remaining_active_directives",
          "sequence_order": 5,
          "is_required": true,
          "parameters_mapping": {},
          "description": "After deactivating a directive, check if any active directives remain. If none, update project.user_directives_status='disabled'."
        },
        {
          "directive_name": "user_directive_status",
          "execution_context": "query_directive_statistics",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Get active directives for status report"
        },
        {
          "directive_name": "aifp_status",
          "execution_context": "check_user_directive_status",
          "sequence_order": 16,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Include active user directive count in overall project status report"
        }
      ],
      "implementation_notes": [
        "SQL: SELECT * FROM user_directives WHERE status='active' ORDER BY name",
        "Returns full directive records for all active directives",
        "Commonly used after deactivation to check if project.user_directives_status should change to 'disabled'"
      ]
    },
    {
      "name": "search_user_directives",
      "file_path": "helpers/user_directives/crud.py",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by directive name (LIKE match, case-insensitive)"
        },
        {
          "name": "domain",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by domain (exact match, e.g. 'home_automation', 'aws_infrastructure')"
        },
        {
          "name": "status",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by status (exact match)"
        },
        {
          "name": "trigger_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by trigger_type (exact match)"
        },
        {
          "name": "source_file",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by source_file path (LIKE match)"
        }
      ],
      "purpose": "Search user directives with optional filters. At least one filter required.",
      "error_handling": "Returns error if no filters provided. Returns empty array if no matches.",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_status",
          "execution_context": "query_directive_statistics",
          "sequence_order": 2,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Search directives by status for building status report sections (pending, error, paused, etc.)"
        }
      ],
      "implementation_notes": [
        "Build WHERE clause from provided filters (AND logic)",
        "Name and source_file use LIKE with % wildcards (case-insensitive)",
        "Domain, status, trigger_type use exact match",
        "SQL: SELECT * FROM user_directives WHERE {conditions} ORDER BY name",
        "At least one filter parameter must be non-null"
      ]
    },
    {
      "name": "get_user_directive_by_name",
      "file_path": "helpers/user_directives/management.py",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Directive name (exact match)"
        }
      ],
      "purpose": "Get a single user directive by its unique name",
      "error_handling": "Returns null/None if directive not found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_validate",
          "execution_context": "interactive_clarification",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Fetch directive record to access raw_content and identify ambiguities for validation Q&A"
        },
        {
          "directive_name": "user_directive_implement",
          "execution_context": "analyze_requirements",
          "sequence_order": 1,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Fetch validated directive to read validated_content for code generation"
        },
        {
          "directive_name": "user_directive_update",
          "execution_context": "parse_updated_file",
          "sequence_order": 3,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Fetch existing directive by name to compare with re-parsed version and detect changes"
        }
      ],
      "implementation_notes": [
        "SQL: SELECT * FROM user_directives WHERE name=?",
        "Returns single directive record or null",
        "Name is UNIQUE in user_directives table so at most one result"
      ]
    },
    {
      "name": "activate_user_directive",
      "file_path": "helpers/user_directives/management.py",
      "parameters": [
        {
          "name": "directive_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "ID of the directive to activate"
        }
      ],
      "purpose": "Set directive status to 'active' and record activated_at timestamp. Does NOT deploy services - AI handles deployment via directive workflow.",
      "error_handling": "Returns error if directive not found or approved != true",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Directive activated. Consider initializing execution tracking in directive_executions table via add_user_custom_entry.",
        "Check if project.user_directives_status needs updating to 'active' if this is the first activation."
      ],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_activate",
          "execution_context": "update_status",
          "sequence_order": 3,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Set status=active and activated_at after AI has completed deployment steps"
        }
      ],
      "implementation_notes": [
        "Verify directive exists: SELECT approved FROM user_directives WHERE id=?",
        "Verify approved=true before proceeding, return error if not approved",
        "SQL: UPDATE user_directives SET status='active', activated_at=CURRENT_TIMESTAMP WHERE id=?",
        "Returns updated directive record",
        "NOTE: This only updates DB status. Actual deployment (scheduler, service, event handler) is AI's responsibility via user_directive_activate directive workflow."
      ]
    },
    {
      "name": "deactivate_user_directive",
      "file_path": "helpers/user_directives/management.py",
      "parameters": [
        {
          "name": "directive_id",
          "type": "integer",
          "required": true,
          "default": null,
          "description": "ID of the directive to deactivate"
        }
      ],
      "purpose": "Set directive status to 'paused'. Does NOT stop services - AI handles service shutdown via directive workflow.",
      "error_handling": "Returns error if directive not found",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [
        "Directive paused. Use get_active_user_directives to check if any directives remain active.",
        "If no active directives remain, update project.user_directives_status to 'disabled'."
      ],
      "target_database": "user_directives",
      "used_by_directives": [
        {
          "directive_name": "user_directive_deactivate",
          "execution_context": "update_status",
          "sequence_order": 2,
          "is_required": true,
          "parameters_mapping": {},
          "description": "Set status=paused after AI has completed service shutdown steps"
        },
        {
          "directive_name": "user_directive_update",
          "execution_context": "handle_modified_directives",
          "sequence_order": 1,
          "is_required": false,
          "parameters_mapping": {},
          "description": "Deactivate directive before re-validation when source file changes"
        }
      ],
      "implementation_notes": [
        "Verify directive exists: SELECT id FROM user_directives WHERE id=?",
        "SQL: UPDATE user_directives SET status='paused' WHERE id=?",
        "Also clear deployment info: UPDATE directive_implementations SET deployed=0, process_id=NULL WHERE directive_id=?",
        "Returns updated directive record",
        "NOTE: This only updates DB status. Actual service shutdown is AI's responsibility via user_directive_deactivate directive workflow."
      ]
    },
    {
      "name": "add_user_directive_note",
      "file_path": "helpers/user_directives/management.py",
      "parameters": [
        {
          "name": "content",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Note content/message"
        },
        {
          "name": "note_type",
          "type": "string",
          "required": true,
          "default": null,
          "description": "'implementation', 'validation', 'execution', 'dependency', 'error', 'optimization', 'user_feedback', 'lifecycle', 'testing', 'general'"
        },
        {
          "name": "reference_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Type of reference: 'directive', 'helper', 'dependency', 'file'"
        },
        {
          "name": "reference_name",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Name of referenced entity (e.g., directive name, helper name, file path)"
        },
        {
          "name": "reference_id",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "Optional ID linking to user_directives, helper_functions, etc."
        },
        {
          "name": "severity",
          "type": "string",
          "required": false,
          "default": "info",
          "description": "'info', 'warning', 'error' (default 'info')"
        },
        {
          "name": "metadata_json",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Additional context as JSON string"
        }
      ],
      "purpose": "Add note to user_directives.db notes table for AI record-keeping",
      "error_handling": "Returns error if note_type is not in allowed CHECK constraint values",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "SQL: INSERT INTO notes (content, note_type, reference_type, reference_name, reference_id, severity, metadata_json) VALUES (?, ?, ?, ?, ?, ?, ?)",
        "Validate note_type against CHECK constraint: ('implementation', 'validation', 'execution', 'dependency', 'error', 'optimization', 'user_feedback', 'lifecycle', 'testing', 'general')",
        "Validate severity against CHECK constraint: ('info', 'warning', 'error')",
        "Return inserted note with generated ID"
      ]
    },
    {
      "name": "get_user_directive_notes",
      "file_path": "helpers/user_directives/management.py",
      "parameters": [
        {
          "name": "note_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by note_type"
        },
        {
          "name": "reference_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by reference_type"
        },
        {
          "name": "reference_name",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by reference_name"
        },
        {
          "name": "reference_id",
          "type": "integer",
          "required": false,
          "default": null,
          "description": "Filter by reference_id"
        },
        {
          "name": "severity",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Filter by severity"
        },
        {
          "name": "limit",
          "type": "integer",
          "required": false,
          "default": 100,
          "description": "Maximum number of notes to return (default 100)"
        }
      ],
      "purpose": "Get notes from user_directives.db with optional filters. All filters are AND logic. No filters returns all notes.",
      "error_handling": "Returns empty array if no matches",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "Build WHERE clause from provided non-null filters (AND logic)",
        "SQL: SELECT * FROM notes WHERE {conditions} ORDER BY created_at DESC LIMIT ?",
        "All filters are exact match",
        "If no filters provided, returns most recent notes up to limit",
        "Order by created_at DESC (newest first)"
      ]
    },
    {
      "name": "search_user_directive_notes",
      "file_path": "helpers/user_directives/management.py",
      "parameters": [
        {
          "name": "search_string",
          "type": "string",
          "required": true,
          "default": null,
          "description": "Search string for note content (case-insensitive LIKE match)"
        },
        {
          "name": "note_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Optional filter by note_type"
        },
        {
          "name": "reference_type",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Optional filter by reference_type"
        },
        {
          "name": "severity",
          "type": "string",
          "required": false,
          "default": null,
          "description": "Optional filter by severity"
        },
        {
          "name": "limit",
          "type": "integer",
          "required": false,
          "default": 100,
          "description": "Maximum number of notes to return (default 100)"
        }
      ],
      "purpose": "Search note content in user_directives.db with optional additional filters",
      "error_handling": "Returns empty array if no matches",
      "is_tool": true,
      "is_sub_helper": false,
      "return_statements": [],
      "target_database": "user_directives",
      "used_by_directives": [],
      "implementation_notes": [
        "SQL: SELECT * FROM notes WHERE content LIKE '%' || ? || '%' {AND additional_filters} ORDER BY created_at DESC LIMIT ?",
        "search_string uses case-insensitive LIKE match on content field",
        "Additional filters (note_type, reference_type, severity) are exact match AND conditions",
        "Order by created_at DESC (newest first)"
      ]
    }
  ],
  "metadata": {
    "file": "helpers-user-custom.json",
    "count": 19,
    "first_helper": "user_directives_allowed_check_constraints",
    "status": "REFACTORED 2026-01-28 - Removed 6 orchestrator helpers, added 5 CRUD helpers",
    "mapped_helpers": 8,
    "unmapped_helpers": 11,
    "note": "Removed 6 orchestrators that contained deep logic (parse_directive_file, validate_directive_config, generate_handler_code, deploy_background_service, get_user_directive_status, monitor_directive_execution). These operations are AI's responsibility guided by directive workflows. Replaced with CRUD-oriented helpers: get_user_directive_by_name, get_active_user_directives, search_user_directives, activate_user_directive, deactivate_user_directive. 11 helpers are generic AI tools (schema/CRUD/notes). 8 helpers mapped to directives.",
    "total_mappings": 14,
    "last_updated": "2026-01-28",
    "changes": [
      "REMOVED: parse_directive_file (orchestrator - AI follows user_directive_parse directive workflow)",
      "REMOVED: validate_directive_config (orchestrator - AI follows user_directive_validate directive workflow)",
      "REMOVED: generate_handler_code (orchestrator - AI follows user_directive_implement directive workflow)",
      "REMOVED: deploy_background_service (orchestrator - AI follows user_directive_activate directive workflow)",
      "REMOVED: get_user_directive_status (orchestrator - AI uses get_active_user_directives + search_user_directives + generic CRUD)",
      "REMOVED: monitor_directive_execution (orchestrator - AI uses generic CRUD on directive_executions table)",
      "ADDED: get_user_directive_by_name (simple WHERE name=? query)",
      "ADDED: get_active_user_directives (simple WHERE status='active' query)",
      "ADDED: search_user_directives (multi-filter search on user_directives table)",
      "ADDED: activate_user_directive (status update to 'active' with approval check)",
      "ADDED: deactivate_user_directive (status update to 'paused' with deployment cleanup)",
      "UPDATED: All helpers now have implementation_notes filled in",
      "UPDATED: return_statements added to activate/deactivate for chaining guidance",
      "FIXED: CHECK constraint examples now match actual schema values"
    ]
  }
}
